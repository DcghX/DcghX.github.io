<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>酱油村-记事录</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dcghx.github.io/"/>
  <updated>2020-05-28T14:30:22.529Z</updated>
  <id>https://dcghx.github.io/</id>
  
  <author>
    <name>酱油君</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程————AQS</title>
    <link href="https://dcghx.github.io/2020/05/09/dxc-aqs/"/>
    <id>https://dcghx.github.io/2020/05/09/dxc-aqs/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-28T14:30:22.529Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="多线程" scheme="https://dcghx.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程————CAS</title>
    <link href="https://dcghx.github.io/2020/05/09/dxc-cas/"/>
    <id>https://dcghx.github.io/2020/05/09/dxc-cas/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-29T14:29:20.204Z</updated>
    
    <content type="html"><![CDATA[<p>什么是悲观锁、乐观锁？在java语言里，总有一些名词看语义跟本不明白是啥玩意儿，也就总有部分面试官拿着这样的词来忽悠面试者，以此来找优越感，其实理解清楚了，这些词也就唬不住人了。<a id="more"></a></p><ul><li><p>synchronized是悲观锁，这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁。</p></li><li><p>CAS操作的就是乐观锁，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p></li></ul><p>在进入正题之前，我们先理解下下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.private static int count &#x3D; 0;  </span><br><span class="line">2.  </span><br><span class="line">3.   public static void main(String[] args) &#123;  </span><br><span class="line">4.       for (int i &#x3D; 0; i &lt; 2; i++) &#123;  </span><br><span class="line">5.           new Thread(new Runnable() &#123;  </span><br><span class="line">6.               @Override  </span><br><span class="line">7.               public void run() &#123;  </span><br><span class="line">8.                   try &#123;  </span><br><span class="line">9.                       Thread.sleep(10);  </span><br><span class="line">10.                   &#125; catch (Exception e) &#123;  </span><br><span class="line">11.                       e.printStackTrace();  </span><br><span class="line">12.                   &#125;  </span><br><span class="line">13.                   &#x2F;&#x2F;每个线程让count自增100次  </span><br><span class="line">14.                   for (int i &#x3D; 0; i &lt; 100; i++) &#123;  </span><br><span class="line">15.                       count++;  </span><br><span class="line">16.                   &#125;  </span><br><span class="line">17.               &#125;  </span><br><span class="line">18.           &#125;).start();  </span><br><span class="line">19.       &#125;  </span><br><span class="line">20.  </span><br><span class="line">21.       try&#123;  </span><br><span class="line">22.           Thread.sleep(2000);  </span><br><span class="line">23.       &#125;catch (Exception e)&#123;  </span><br><span class="line">24.           e.printStackTrace();  </span><br><span class="line">25.       &#125;  </span><br><span class="line">26.       System.out.println(count);  </span><br><span class="line">27.   &#125;</span><br></pre></td></tr></table></figure><p>请问cout的输出值是否为200？答案是否定的，因为这个程序是线程不安全的，所以造成的结果count值可能小于200;</p><p>那么如何改造成线程安全的呢，其实我们可以使用上Synchronized同步锁,我们只需要在count++的位置添加同步锁，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.private static int count &#x3D; 0;  </span><br><span class="line">2.  </span><br><span class="line">3.    public static void main(String[] args) &#123;  </span><br><span class="line">4.        for (int i &#x3D; 0; i &lt; 2; i++) &#123;  </span><br><span class="line">5.            new Thread(new Runnable() &#123;  </span><br><span class="line">6.                @Override  </span><br><span class="line">7.                public void run() &#123;  </span><br><span class="line">8.                    try &#123;  </span><br><span class="line">9.                        Thread.sleep(10);  </span><br><span class="line">10.                    &#125; catch (Exception e) &#123;  </span><br><span class="line">11.                        e.printStackTrace();  </span><br><span class="line">12.                    &#125;  </span><br><span class="line">13.                    &#x2F;&#x2F;每个线程让count自增100次  </span><br><span class="line">14.                    for (int i &#x3D; 0; i &lt; 100; i++) &#123;  </span><br><span class="line">15.                        synchronized (ThreadCas.class)&#123;  </span><br><span class="line">16.                            count++;  </span><br><span class="line">17.                        &#125;  </span><br><span class="line">18.                    &#125;  </span><br><span class="line">19.                &#125;  </span><br><span class="line">20.            &#125;).start();  </span><br><span class="line">21.        &#125;  </span><br><span class="line">22.  </span><br><span class="line">23.        try&#123;  </span><br><span class="line">24.            Thread.sleep(2000);  </span><br><span class="line">25.        &#125;catch (Exception e)&#123;  </span><br><span class="line">26.            e.printStackTrace();  </span><br><span class="line">27.        &#125;  </span><br><span class="line">28.        System.out.println(count);  </span><br><span class="line">29.    &#125;</span><br></pre></td></tr></table></figure><p>加了同步锁之后，count自增的操作变成了原子性操作，所以最终的输出一定是count=200，代码实现了线程安全。</p><p>但是Synchronized虽然确保了线程的安全，但是在性能上却不是最优的，Synchronized关键字会让没有得到锁资源的线程进入BLOCKED状态，而后在争夺到锁资源后恢复为RUNNABLE状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。</p><p>尽管Java1.6为Synchronized做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度，但是在最终转变为重量级锁之后，性能仍然较低。</p><p>所谓原子操作类，指的是java.util.concurrent.atomic包下，一系列以Atomic开头的包装类。例如AtomicBoolean，AtomicInteger，AtomicLong。它们分别用于Boolean，Integer，Long类型的原子性操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.private static AtomicInteger count &#x3D; new AtomicInteger(0);  </span><br><span class="line">2.  </span><br><span class="line">3.public static void main(String[] args) &#123;  </span><br><span class="line">4.    for (int i &#x3D; 0; i &lt; 2; i++) &#123;  </span><br><span class="line">5.        new Thread(new Runnable() &#123;  </span><br><span class="line">6.            @Override  </span><br><span class="line">7.            public void run() &#123;  </span><br><span class="line">8.                try &#123;  </span><br><span class="line">9.                    Thread.sleep(10);  </span><br><span class="line">10.                &#125; catch (Exception e) &#123;  </span><br><span class="line">11.                    e.printStackTrace();  </span><br><span class="line">12.                &#125;  </span><br><span class="line">13.                &#x2F;&#x2F;每个线程让count自增100次  </span><br><span class="line">14.                for (int i &#x3D; 0; i &lt; 100; i++) &#123;  </span><br><span class="line">15.                    count.incrementAndGet();  </span><br><span class="line">16.                &#125;  </span><br><span class="line">17.            &#125;  </span><br><span class="line">18.        &#125;).start();  </span><br><span class="line">19.    &#125;  </span><br><span class="line">20.  </span><br><span class="line">21.    try&#123;  </span><br><span class="line">22.        Thread.sleep(2000);  </span><br><span class="line">23.    &#125;catch (Exception e)&#123;  </span><br><span class="line">24.        e.printStackTrace();  </span><br><span class="line">25.    &#125;  </span><br><span class="line">26.    System.out.println(count);  </span><br><span class="line">27.&#125;</span><br></pre></td></tr></table></figure><p>使用AtomicInteger之后，最终的输出结果同样可以保证是200。并且在某些情况下，代码的性能会比Synchronized更好。</p><p>而Atomic操作的底层实现正是利用的CAS机制，好的，我们切入到这个博客的正点。</p><h1 id="1-什么是CAS机制"><a href="#1-什么是CAS机制" class="headerlink" title="1.什么是CAS机制"></a>1.什么是CAS机制</h1><p>CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。</p><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p><p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p><p>这样说或许有些抽象，我们来看一个例子：</p><p>1.在内存地址V当中，存储着值为10的变量。</p><p><img src="dxc-cas.assets/image-20200528232719629.png" alt="image-20200528232719629"></p><p>2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。</p><p><img src="dxc-cas.assets/image-20200528232743294.png" alt="image-20200528232743294"></p><p>3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</p><p><img src="dxc-cas.assets/image-20200528232801348.png" alt="image-20200528232801348"></p><p>4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。</p><p><img src="dxc-cas.assets/image-20200528232844170.png" alt="image-20200528232844170"></p><p>5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋</p><p><img src="dxc-cas.assets/image-20200528232902372.png" alt="image-20200528232902372"></p><p>6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。</p><p><img src="dxc-cas.assets/image-20200528232917312.png" alt="image-20200528232917312"></p><p>7.线程1进行SWAP，把地址V的值替换为B，也就是12</p><p><img src="dxc-cas.assets/image-20200528232933270.png" alt="image-20200528232933270"></p><p>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p><p>看到上面的解释是不是索然无味，查找了很多资料也没完全弄明白，通过几次验证后，终于明白，最终可以理解成一个无阻塞多线程争抢资源的模型。先上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicBoolean;    </span><br><span class="line">public class AtomicBooleanTest implements Runnable &#123;    </span><br><span class="line">    </span><br><span class="line">    private static AtomicBoolean flag &#x3D; new AtomicBoolean(true);    </span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;    </span><br><span class="line">        AtomicBooleanTest ast &#x3D; new AtomicBooleanTest();    </span><br><span class="line">        Thread thread1 &#x3D; new Thread(ast);    </span><br><span class="line">        Thread thread &#x3D; new Thread(ast);    </span><br><span class="line">        thread1.start();    </span><br><span class="line">        thread.start();    </span><br><span class="line">    &#125;    </span><br><span class="line">    @Override    </span><br><span class="line">    public void run() &#123;    </span><br><span class="line">        System.out.println(&quot;thread:&quot;+Thread.currentThread().getName()+&quot;;flag:&quot;+flag.get());    </span><br><span class="line">        if (flag.compareAndSet(true,false))&#123;    </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;&quot;+flag.get());    </span><br><span class="line">            try &#123;    </span><br><span class="line">                Thread.sleep(5000);    </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;    </span><br><span class="line">                e.printStackTrace();    </span><br><span class="line">            &#125;    </span><br><span class="line">            flag.set(true);    </span><br><span class="line">        &#125;else&#123;    </span><br><span class="line">System.out.println(&quot;重试机制thread:&quot;+Thread.currentThread().getName()+&quot;;flag:&quot;+flag.get());    </span><br><span class="line">            try &#123;    </span><br><span class="line">                Thread.sleep(500);    </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;    </span><br><span class="line">                e.printStackTrace();    </span><br><span class="line">            &#125;    </span><br><span class="line">            run();    </span><br><span class="line">        &#125;    </span><br><span class="line">    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.thread:Thread-1;flag:true  </span><br><span class="line">2.thread:Thread-0;flag:true  </span><br><span class="line">3.Thread-1false  </span><br><span class="line">4.重试机制thread:Thread-0;flag:false  </span><br><span class="line">5.thread:Thread-0;flag:false  </span><br><span class="line">6.重试机制thread:Thread-0;flag:false  </span><br><span class="line">7.thread:Thread-0;flag:false  </span><br><span class="line">8.重试机制thread:Thread-0;flag:false  </span><br><span class="line">9.thread:Thread-0;flag:false  </span><br><span class="line">10.重试机制thread:Thread-0;flag:false  </span><br><span class="line">11.thread:Thread-0;flag:false  </span><br><span class="line">12.重试机制thread:Thread-0;flag:false  </span><br><span class="line">13.thread:Thread-0;flag:false  </span><br><span class="line">14.重试机制thread:Thread-0;flag:false  </span><br><span class="line">15.thread:Thread-0;flag:false  </span><br><span class="line">16.重试机制thread:Thread-0;flag:false  </span><br><span class="line">17.thread:Thread-0;flag:false  </span><br><span class="line">18.重试机制thread:Thread-0;flag:false  </span><br><span class="line">19.thread:Thread-0;flag:false  </span><br><span class="line">20.重试机制thread:Thread-0;flag:false  </span><br><span class="line">21.thread:Thread-0;flag:false  </span><br><span class="line">22.重试机制thread:Thread-0;flag:false  </span><br><span class="line">23.thread:Thread-0;flag:true  </span><br><span class="line">24.Thread-0false</span><br></pre></td></tr></table></figure><p>这里无论怎么运行，Thread-1、Thread-0都会执行if=true条件，而且还不会产生线程脏读脏写，这是如何做到的了，这就用到了我们的compareAndSet(boolean expect,boolean update)方法<br>我们看到当Thread-1在进行操作的时候，Thread一直在进行重试机制，程序原理图:</p><p><img src="dxc-cas.assets/image-20200528233056168.png" alt="image-20200528233056168"></p><p>这个图中重最要的是compareAndSet(true,false)方法要拆开成compare(true)方法和Set(false)方法理解，是compare(true)是等于true后，就马上设置共享内存为false，这个时候，其它线程无论怎么走都无法走到只有得到共享内存为true时的程序隔离方法区。</p><p>看到这里，这种CAS机制就是完美的吗？这个程序其实存在一个问题，不知道大家注意到没有？</p><p>但是这种得不到状态为true时使用递归算法是很耗cpu资源的，所以一般情况下，都会有线程sleep。</p><h1 id="2-CAS的缺点"><a href="#2-CAS的缺点" class="headerlink" title="2.CAS的缺点"></a>2.CAS的缺点</h1><ul><li>ABA问题。当第一个线程执行CAS操作，尚未修改为新值之前，内存中的值已经被其他线程连续修改了两次，使得变量值经历 A -&gt; B -&gt; A的过程。</li></ul><p>l解决方案：添加版本号作为标识，每次修改变量值时，对应增加版本号； 做CAS操作前需要校验版本号。JDK1.5之后，新增AtomicStampedReference类来处理这种情况。</p><ul><li><p>循环时间长开销大。如果有很多个线程并发，CAS自旋可能会长时间不成功，会增大CPU的执行开销。</p></li><li><p>只能对一个变量进原子操作。JDK1.5之后，新增AtomicReference类来处理这种情况，可以将多个变量放到一个对象中。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是悲观锁、乐观锁？在java语言里，总有一些名词看语义跟本不明白是啥玩意儿，也就总有部分面试官拿着这样的词来忽悠面试者，以此来找优越感，其实理解清楚了，这些词也就唬不住人了。
    
    </summary>
    
    
    
      <category term="多线程" scheme="https://dcghx.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM——(1)</title>
    <link href="https://dcghx.github.io/2020/05/09/jvm-1/"/>
    <id>https://dcghx.github.io/2020/05/09/jvm-1/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-29T15:15:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 相比 C/C++ 最显著的特点便是引入了自动垃圾回收<a id="more"></a>(下文统一用 GC 指代自动垃圾回收)，它解决了 C/C++ 最令人头疼的内存管理问题，让程序员专注于程序本身，不用关心内存回收这些恼人的问题，这也是 Java 能大行其道的重要原因之一，GC 真正让程序员的生产力得到了释放，但是程序员很难感知到它的存在，这就好比，我们吃完饭后在桌上放下餐盘即走，服务员会替你收拾好这些餐盘，你不会关心服务员什么时候来收，怎么收。</p><p>有人说既然 GC 已经自动为我们完成了清理,不了解 GC 貌似也没啥问题。在大多数情况下确实没问题，不过如果涉及到一些性能调优，问题排查等，深入地了解 GC 还是必不可少的，曾经美团通过调整 JVM 相关 GC 参数让服务响应时间 TP90，TP99都下降了10ms+，服务可用性得到了很大的提升！所以深入了解 GC 是成为一名优秀 Java 程序员的必修课！</p><h1 id="1-JVM内存区域"><a href="#1-JVM内存区域" class="headerlink" title="1. JVM内存区域"></a>1. JVM内存区域</h1><p>要搞懂垃圾回收的机制，我们首先要知道垃圾回收主要回收的是哪些数据，这些数据主要在哪一块区域，所以我们一起来看下 JVM 的内存区域</p><p><img src="jvm-1.assets/image-20200529223132570.png" alt="image-20200529223132570"></p><ul><li>虚拟机栈：描述的是方法执行时的内存模型,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建栈桢（下文会看到），主要保存执行方法时的局部变量表、操作数栈、动态连接和方法返回地址等信息,方法执行时入栈，方法执行完出栈，出栈就相当于清空了数据，入栈出栈的时机很明确，所以这块区域不需要进行 GC。</li><li>本地方法栈：与虚拟机栈功能非常类似，主要区别在于虚拟机栈为虚拟机执行 Java 方法时服务，而本地方法栈为虚拟机执行本地方法时服务的。这块区域也不需要进行 GC</li><li>程序计数器：线程独有的， 可以把它看作是当前线程执行的字节码的行号指示器，比如如下字节码内容，在每个字节码`前面都有一个数字（行号），我们可以认为它就是程序计数器存储的内容</li></ul><p><img src="jvm-1.assets/image-20200529223245221.png" alt="image-20200529223245221"></p><p>记录这些数字（指令地址）有啥用呢，我们知道 Java 虚拟机的多线程是通过线程轮流切换并分配处理器的时间来完成的，在任何一个时刻，一个处理器只会执行一个线程，如果这个线程被分配的时间片执行完了（线程被挂起），处理器会切换到另外一个线程执行，当下次轮到执行被挂起的线程（唤醒线程）时，怎么知道上次执行到哪了呢，通过记录在程序计数器中的行号指示器即可知道，所以程序计数器的主要作用是记录线程运行时的状态，方便线程被唤醒时能从上一次被挂起时的状态继续执行，需要注意的是，程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域，所以这块区域也不需要进行 GC</p><ul><li><p>本地内存：线程共享区域，Java 8 中，本地内存，也是我们通常说的堆外内存，包含元空间和直接内存,注意到上图中 Java 8 和 Java 8 之前的 JVM 内存区域的区别了吗，在 Java 8 之前有个永久代的概念，实际上指的是 HotSpot 虚拟机上的永久代，它用永久代实现了 JVM 规范定义的方法区功能，主要存储类的信息，常量，静态变量，即时编译器编译后代码等，这部分由于是在堆中实现的，受 GC 的管理，不过由于永久代有 -XX:MaxPermSize 的上限，所以如果动态生成类（将类信息放入永久代）或大量地执行 String.intern （将字段串放入永久代中的常量区），很容易造成 OOM，有人说可以把永久代设置得足够大，但很难确定一个合适的大小，受类数量，常量数量的多少影响很大。所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了,也就不会进行 GC，也因此提升了性能（发生 GC 会发生 Stop The Word,造成性能受到一定影响，后文会提到），也就不存在由于永久代限制大小而导致的 OOM 异常了（假设总内存1G，JVM 被分配内存 100M， 理论上元空间可以分配 2G-100M = 1.9G，空间大小足够），也方便在元空间中统一管理。综上所述，在 Java 8 以后这一区域也不需要进行 GC</p></li><li><p>堆：前面几块数据区域都不进行 GC，那只剩下堆了，是的，这里是 GC 发生的区域！对象实例和数组都是在堆上分配的，GC 也主要对这两类数据进行回收，这块也是我们之后重点需要分析的区域</p></li></ul><h1 id="2-如何识别垃圾"><a href="#2-如何识别垃圾" class="headerlink" title="2. 如何识别垃圾"></a>2. 如何识别垃圾</h1><p>上一节我们详细讲述了 JVM 的内存区域，知道了 GC 主要发生在堆，那么 GC 该怎么判断堆中的对象实例或数据是不是垃圾呢，或者说判断某些数据是否是垃圾的方法有哪些。</p><h2 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h2><p>最容易想到的一种方式是引用计数法，啥叫引用计数法，简单地说，就是对象被引用一次，在它的对象头上加一次引用次数，如果没有被引用（引用次数为 0），则此对象可回收</p><p><img src="jvm-1.assets/image-20200529223531516.png" alt="image-20200529223531516"></p><p>以上代码 ref 引用了右侧定义的对象，所以引用次数是 1</p><p><img src="jvm-1.assets/image-20200529223543486.png" alt="image-20200529223543486"></p><p>如果在上述代码后面添加一个 ref = null，则由于对象没被引用，引用次数置为 0，由于不被任何变量引用，此时即被回收，动图如</p><p><img src="jvm-1.assets/1.gif" alt=""></p><p>看起来用引用计数确实没啥问题了，不过它无法解决一个主要的问题：循环引用！啥叫循环引用</p><p><img src="jvm-1.assets/image-20200529223801717.png" alt="image-20200529223801717"></p><p>按步骤一步步画图</p><p><img src="jvm-1.assets/image-20200529223818981.png" alt="image-20200529223818981"></p><p>到了第三步，虽然 a，b 都被置为 null 了，但是由于之前它们指向的对象互相指向了对方（引用计数都为 1），所以无法回收，也正是由于无法解决循环引用的问题，所以现代虚拟机都不用引用计数法来判断对象是否应该被回收。</p><h2 id="2-2-可达性算法"><a href="#2-2-可达性算法" class="headerlink" title="2.2 可达性算法"></a>2.2 可达性算法</h2><p>现代虚拟机基本都是采用这种算法来判断对象是否存活，可达性算法的原理是以一系列叫做 GC Root 的对象为起点出发，引出它们指向的下一个节点，再以下个节点为起点，引出此节点指向的下一个结点。。。（这样通过 GC Root 串成的一条线就叫引用链），直到所有的结点都遍历完毕,如果相关对象不在任意一个以 GC Root 为起点的引用链中，则这些对象会被判断为「垃圾」,会被 GC 回收。</p><p><img src="jvm-1.assets/image-20200529223913887.png" alt="image-20200529223913887"></p><p>如图示，用可达性算法即可解决上述循环引用的问题，因为从GC Root 出发没有到达 a,b,所以 a，b 可回收</p><p>a, b 对象可回收，就一定会被回收吗?并不是，对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收！</p><p>注意： finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记!</p><p>那么这些 GC Roots 到底是什么东西呢，哪些对象可以作为 GC Root 呢，有以下几类</p><ul><li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</p></li></ul><h3 id="2-2-1-虚拟机栈中的引用对象"><a href="#2-2-1-虚拟机栈中的引用对象" class="headerlink" title="2.2.1 虚拟机栈中的引用对象"></a>2.2.1 虚拟机栈中的引用对象</h3><p>如下代码所示，a 是栈帧中的本地变量，当 a = null 时，由于此时 a 充当了 GC Root 的作用，a 与原来指向的实例 new Test() 断开了连接，所以对象会被回收。</p><p><img src="jvm-1.assets/image-20200529224054484.png" alt="image-20200529224054484"></p><h3 id="2-2-2方法区中类静态属性引用的对象"><a href="#2-2-2方法区中类静态属性引用的对象" class="headerlink" title="2.2.2方法区中类静态属性引用的对象"></a>2.2.2方法区中类静态属性引用的对象</h3><p>如下代码所示，当栈帧中的本地变量 a = null 时，由于 a 原来指向的对象与 GC Root (变量 a) 断开了连接，所以 a 原来指向的对象会被回收，而由于我们给 s 赋值了变量的引用，s 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活!</p><p><img src="jvm-1.assets/image-20200529224153794.png" alt="image-20200529224153794"></p><h3 id="2-2-3-方法区中常量引用的对象"><a href="#2-2-3-方法区中常量引用的对象" class="headerlink" title="2.2.3 方法区中常量引用的对象"></a>2.2.3 方法区中常量引用的对象</h3><p>如下代码所示，常量 s 指向的对象并不会因为 a 指向的对象被回收而回收</p><p><img src="jvm-1.assets/image-20200529224252734.png" alt="image-20200529224252734"></p><h3 id="2-2-4-本地方法栈中-JNI-引用的对象"><a href="#2-2-4-本地方法栈中-JNI-引用的对象" class="headerlink" title="2.2.4 本地方法栈中 JNI 引用的对象"></a>2.2.4 本地方法栈中 JNI 引用的对象</h3><p>这是简单给不清楚本地方法为何物的童鞋简单解释一下：所谓本地方法就是一个 java 调用非 java 代码的接口，该方法并非 Java 实现的，可能由 C 或 Python等其他语言实现的， Java 通过 JNI 来调用本地方法， 而本地方法是以库文件的形式存放的（在 WINDOWS 平台上是 DLL 文件形式，在 UNIX 机器上是 SO 文件形式）。通过调用本地的库文件的内部方法，使 JAVA 可以实现和本地机器的紧密联系，调用系统级的各接口方法，还是不明白？见文末参考，对本地方法定义与使用有详细介绍。</p><p>当调用 Java 方法时，虚拟机会创建一个栈桢并压入 Java 栈，而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不会在 Java 栈祯中压入新的祯，虚拟机只是简单地动态连接并直接调用指定的本地方法。</p><p><img src="jvm-1.assets/image-20200529224353825.png" alt="image-20200529224353825"></p><p><img src="jvm-1.assets/image-20200529224405686.png" alt="image-20200529224405686"></p><p>如上代码所示，当 java 调用以上本地方法时，jc 会被本地方法栈压入栈中, jc 就是我们说的本地方法栈中 JNI 的对象引用，因此只会在此本地方法执行完成后才会被释放。</p><h1 id="3-垃圾回收主要方法"><a href="#3-垃圾回收主要方法" class="headerlink" title="3. 垃圾回收主要方法"></a>3. 垃圾回收主要方法</h1><p>上一节我们知道了可以通过可达性算法来识别哪些数据是垃圾，那该怎么对这些垃圾进行回收呢。主要有以下几种方式方式:标记清除算法、复制算法、标记整理法、分代收集算法</p><h2 id="3-1-标记清除法"><a href="#3-1-标记清除法" class="headerlink" title="3.1 标记清除法"></a>3.1 标记清除法</h2><p>步骤很简单</p><p>1) 先根据可达性算法标记出相应的可回收对象（图中黄色部分）</p><p>2) 对可回收的对象进行回收</p><p><img src="jvm-1.assets/image-20200529224620333.png" alt="image-20200529224620333"></p><p>操作起来确实很简单，也不用做移动数据的操作，那有啥问题呢？仔细看上图，没错，内存碎片！假如我们想在上图中的堆中分配一块需要连续内存占用 4M 或 5M 的区域，显然是会失败，怎么解决呢，如果能把上面未使用的 2M， 2M，1M 内存能连起来就能连成一片可用空间为 5M 的区域即可，怎么做呢?</p><h2 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h2><p>把堆等分成两块区域, A 和 B，区域 A 负责分配对象，区域 B 不分配, 对区域 A 使用以上所说的标记法把存活的对象标记出来（下图有误无需清除），然后把区域 A 中存活的对象都复制到区域 B（存活对象都依次紧邻排列）最后把 A 区对象全部清理掉释放出空间，这样就解决了内存碎片的问题了。</p><p><img src="jvm-1.assets/image-20200529224717578.png" alt="image-20200529224717578"></p><p>不过复制算法的缺点很明显，比如给堆分配了 500M 内存，结果只有 250M 可用，空间平白无故减少了一半！这肯定是不能接受的！另外每次回收也要把存活对象移动到另一半，效率低下（我们可以想想删除数组元素再把非删除的元素往一端移，效率显然堪忧）</p><h2 id="3-3-标记整理"><a href="#3-3-标记整理" class="headerlink" title="3.3 标记整理"></a>3.3 标记整理</h2><p>前面两步和标记清除法一样，不同的是它在标记清除法的基础上添加了一个整理的过程 ，即将所有的存活对象都往一端移动,紧邻排列（如图示），再清理掉另一端的所有区域，这样的话就解决了内存碎片的问题。</p><p><img src="jvm-1.assets/image-20200529224810281.png" alt="image-20200529224810281"></p><p>但是缺点也很明显：每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下。</p><h2 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h2><p>分代收集算法整合了以上算法，综合了这些算法的优点，最大程度避免了它们的缺点，所以是现代虚拟机采用的首选算法,与其说它是算法，倒不是说它是一种策略，因为它是把上述几种算法整合在了一起，为啥需要分代收集呢，来看一下对象的分配有啥规律</p><p><img src="jvm-1.assets/image-20200529225009030.png" alt="image-20200529225009030"></p><p>如图示：纵轴代表已分配的字节，而横轴代表程序运行时间</p><p>由图可知，大部分的对象都很短命，都在很短的时间内都被回收了（IBM 专业研究表明，一般来说，98% 的对象都是朝生夕死的，经过一次 Minor GC 后就会被回收），所以分代收集算法根据对象存活周期的不同将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),三者的比例为 8: 1 : 1，这样就可以根据新老生代的特点选择最合适的垃圾回收算法，我们把新生代发生的 GC 称为 Young GC（也叫 Minor GC）,老年代发生的 GC 称为 Old GC（也称为 Full GC）。</p><p><img src="jvm-1.assets/image-20200529225029114.png" alt="image-20200529225029114"></p><p>画外音：思考一下，新生代为啥要分这么多区？</p><p>那么分代垃圾收集是怎么工作的呢，我们一起来看看分代收集原理</p><h3 id="3-4-1-对象在新生代的分配与回收"><a href="#3-4-1-对象在新生代的分配与回收" class="headerlink" title="3.4.1 对象在新生代的分配与回收"></a>3.4.1 对象在新生代的分配与回收</h3><p>由以上的分析可知，大部分对象在很短的时间内都会被回收，对象一般分配在 Eden 区</p><p><img src="jvm-1.assets/image-20200529225506621.png" alt="image-20200529225506621"></p><p>当 Eden 区将满时，触发 Minor GC</p><p><img src="jvm-1.assets/image-20200529225523964.png" alt="image-20200529225523964"></p><p>我们之前怎么说来着，大部分对象在短时间内都会被回收, 所以经过 Minor GC 后只有少部分对象会存活，它们会被移到 S0 区（这就是为啥空间大小 Eden: S0: S1 = 8:1:1, Eden 区远大于 S0,S1 的原因，因为在 Eden 区触发的 Minor GC 把大部对象（接近98%）都回收了,只留下少量存活的对象，此时把它们移到 S0 或 S1 绰绰有余）同时对象年龄加一（对象的年龄即发生 Minor GC 的次数），最后把 Eden 区对象全部清理以释放出空间。</p><p><img src="jvm-1.assets/2.gif" alt=""></p><p>当触发下一次 Minor GC 时，会把 Eden 区的存活对象和 S0（或S1） 中的存活对象（S0 或 S1 中的存活对象经过每次 Minor GC 都可能被回收）一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。</p><p><img src="jvm-1.assets/3.gif" alt=""></p><p>若再触发下一次 Minor GC，则重复上一步，只不过此时变成了 从 Eden，S1 区将存活对象复制到 S0 区,每次垃圾回收, S0, S1 角色互换，都是从 Eden ,S0(或S1) 将存活对象移动到 S1(或S0)。也就是说在 Eden 区的垃圾回收我们采用的是复制算法，因为在 Eden 区分配的对象大部分在 Minor GC 后都消亡了，只剩下极少部分存活对象（这也是为啥 Eden:S0:S1 默认为 8:1:1 的原因），S0,S1 区域也比较小，所以最大限度地降低了复制算法造成的对象频繁拷贝带来的开销。</p><h3 id="3-4-2-对象何时晋升老年代"><a href="#3-4-2-对象何时晋升老年代" class="headerlink" title="3.4.2 对象何时晋升老年代"></a>3.4.2 对象何时晋升老年代</h3><ul><li>阈值：当对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代</li></ul><p><img src="jvm-1.assets/4.gif" alt=""></p><p>如图示：年龄阈值设置为 15， 当发生下一次 Minor GC 时，S0 中有个对象年龄达到 15，达到我们的设定阈值，晋升到老年代！</p><ul><li><p>大对象：当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代，因为如果把大对象分配在 Eden 区, Minor GC 后再移动到 S0,S1 会有很大的开销（对象比较大，复制会比较慢，也占空间），也很快会占满 S0,S1 区，所以干脆就直接移到老年代.</p></li><li><p>还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。</p></li></ul><h3 id="3-4-3-空间分配担保"><a href="#3-4-3-空间分配担保" class="headerlink" title="3.4.3 空间分配担保"></a>3.4.3 空间分配担保</h3><p>在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。</p><h3 id="3-4-4-Stop-The-World"><a href="#3-4-4-Stop-The-World" class="headerlink" title="3.4.4 Stop The World"></a>3.4.4 Stop The World</h3><p>如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。</p><p>什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。</p><p><img src="jvm-1.assets/image-20200529225922032.png" alt="image-20200529225922032"></p><p><strong>画外音：为啥在垃圾收集期间其他工作线程会被挂起？想象一下，你一边在收垃圾，另外一群人一边丢垃圾，垃圾能收拾干净吗。</strong></p><p>一般 Full GC 会导致工作线程停顿时间过长（因为Full GC 会清理整个堆中的不可用对象，一般要花较长的时间），如果在此 server 收到了很多请求，则会被拒绝服务！所以我们要尽量减少 Full GC（Minor GC 也会造成 STW,但只会触发轻微的 STW,因为 Eden 区的对象大部分都被回收了，只有极少数存活对象会通过复制算法转移到 S0 或 S1 区，所以相对还好）。</p><p>现在我们应该明白把新生代设置成 Eden, S0，S1区或者给对象设置年龄阈值或者默认把新生代与老年代的空间大小设置成 1:2 都是为了尽可能地避免对象过早地进入老年代，尽可能晚地触发 Full GC。想想新生代如果只设置 Eden 会发生什么，后果就是每经过一次 Minor GC，存活对象会过早地进入老年代，那么老年代很快就会装满，很快会触发 Full GC，而对象其实在经过两三次的 Minor GC 后大部分都会消亡，所以有了 S0,S1的缓冲，只有少数的对象会进入老年代，老年代大小也就不会这么快地增长，也就避免了过早地触发 Full GC。</p><p>由于 Full GC（或Minor GC） 会影响性能，所以我们要在一个合适的时间点发起 GC，这个时间点被称为 Safe Point，这个时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷。一般当线程在这个时间点上状态是可以确定的，如确定 GC Root 的信息等，可以使 JVM 开始安全地 GC。Safe Point 主要指的是以下特定位置：</p><ul><li><p>循环的末尾</p></li><li><p>方法返回前</p></li><li><p>调用方法的 call 之后</p></li><li><p>抛出异常的位置 另外需要注意的是由于新生代的特点（大部分对象经过 Minor GC后会消亡）， Minor GC 用的是复制算法，而在老生代由于对象比较多，占用的空间较大，使用复制算法会有较大开销（复制算法在对象存活率较高时要进行多次复制操作，同时浪费一半空间）所以根据老生代特点，在老年代进行的 GC 一般采用的是标记整理法来进行回收。</p></li></ul><h1 id="4-垃圾收集器种类"><a href="#4-垃圾收集器种类" class="headerlink" title="4. 垃圾收集器种类"></a>4. 垃圾收集器种类</h1><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范并没有规定垃圾收集器应该如何实现，因此一般来说不同厂商，不同版本的虚拟机提供的垃圾收集器实现可能会有差别，一般会给出参数来让用户根据应用的特点来组合各个年代使用的收集器，主要有以下垃圾收集器</p><p><img src="jvm-1.assets/image-20200529230043106.png" alt="image-20200529230043106"></p><ul><li><p>在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge</p></li><li><p>在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old</p></li><li><p>同时在新老生代工作的垃圾回收器：G1</p></li></ul><p>图片中的垃圾收集器如果存在连线，则代表它们之间可以配合使用，接下来我们来看看各个垃圾收集器的具体功能。</p><h2 id="4-1新生代收集器"><a href="#4-1新生代收集器" class="headerlink" title="4.1新生代收集器"></a>4.1新生代收集器</h2><h3 id="4-1-1-Serial-收集器"><a href="#4-1-1-Serial-收集器" class="headerlink" title="4.1.1 Serial 收集器"></a>4.1.1 Serial 收集器</h3><p>Serial 收集器是工作在新生代的，单线程的垃圾收集器，单线程意味着它只会使用一个 CPU 或一个收集线程来完成垃圾回收，不仅如此，还记得我们上文提到的 STW 了吗，它在进行垃圾收集时，其他用户线程会暂停，直到垃圾收集结束，也就是说在 GC 期间，此时的应用不可用。</p><p>看起来单线程垃圾收集器不太实用，不过我们需要知道的任何技术的使用都不能脱离场景，在Client 模式下，它简单有效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 单线程模式无需与其他线程交互，减少了开销，专心做 GC 能将其单线程的优势发挥到极致，另外在用户的桌面应用场景，分配给虚拟机的内存一般不会很大，收集几十甚至一两百兆（仅是新生代的内存，桌面应用基本不会再大了），STW 时间可以控制在一百多毫秒内，只要不是频繁发生，这点停顿是可以接受的，所以对于运行在 Client 模式下的虚拟机，Serial 收集器是新生代的默认收集器</p><h2 id="4-1-2-ParNew-收集器"><a href="#4-1-2-ParNew-收集器" class="headerlink" title="4.1.2  ParNew 收集器"></a>4.1.2  ParNew 收集器</h2><p>ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程，其他像收集算法,STW,对象分配规则，回收策略与 Serial 收集器完成一样，在底层上，这两种收集器也共用了相当多的代码，它的垃圾收集过程如下</p><p><img src="jvm-1.assets/image-20200529230244108.png" alt="image-20200529230244108"></p><p>ParNew 主要工作在 Server 模式，我们知道服务端如果接收的请求多了，响应时间就很重要了，多线程可以让垃圾回收得更快，也就是减少了 STW 时间，能提升响应时间，所以是许多运行在 Server 模式下的虚拟机的首选新生代收集器，另一个与性能无关的原因是因为除了 Serial  收集器，只有它能与 CMS 收集器配合工作，CMS 是一个划时代的垃圾收集器，是真正意义上的并发收集器，它第一次实现了垃圾收集线程与用户线程（基本上）同时工作，它采用的是传统的 GC 收集器代码框架，与 Serial,ParNew 共用一套代码框架，所以能与这两者一起配合工作，而后文提到的 Parallel Scavenge 与 G1 收集器没有使用传统的 GC 收集器代码框架，而是另起炉灶独立实现的，另外一些收集器则只是共用了部分的框架代码,所以无法与 CMS 收集器一起配合工作。</p><p>在多 CPU 的情况下，由于 ParNew 的多线程回收特性，毫无疑问垃圾收集会更快，也能有效地减少 STW 的时间，提升应用的响应速度。</p><h3 id="4-1-3-Parallel-Scavenge-收集器"><a href="#4-1-3-Parallel-Scavenge-收集器" class="headerlink" title="4.1.3 Parallel Scavenge 收集器"></a>4.1.3 Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是一个使用复制算法，多线程，工作于新生代的垃圾收集器，看起来功能和 ParNew 收集器一样，它有啥特别之处吗</p><p>关注点不同，CMS 等垃圾收集器关注的是尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 目标是达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）），也就是说 CMS 等垃圾收集器更适合用到与用户交互的程序，因为停顿时间越短，用户体验越好，而 Parallel Scavenge 收集器关注的是吞吐量，所以更适合做后台运算等不需要太多用户交互的任务。</p><p>Parallel Scavenge 收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集时间的 -XX:MaxGCPauseMillis 参数及直接设置吞吐量大小的 -XX:GCTimeRatio（默认99%）</p><p>除了以上两个参数，还可以用 Parallel Scavenge 收集器提供的第三个参数 -XX:UseAdaptiveSizePolicy，开启这个参数后，就不需要手工指定新生代大小,Eden 与 Survivor 比例（SurvivorRatio）等细节，只需要设置好基本的堆大小（-Xmx 设置最大堆）,以及最大垃圾收集时间与吞吐量大小，虚拟机就会根据当前系统运行情况收集监控信息，动态调整这些参数以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标。自适应策略也是 Parallel Scavenge  与 ParNew 的重要区别！</p><h2 id="4-2-老年代收集器"><a href="#4-2-老年代收集器" class="headerlink" title="4.2 老年代收集器"></a>4.2 老年代收集器</h2><h3 id="4-2-1-Serial-Old-收集器"><a href="#4-2-1-Serial-Old-收集器" class="headerlink" title="4.2.1 Serial Old 收集器"></a>4.2.1 Serial Old 收集器</h3><p>上文我们知道， Serial 收集器是工作于新生代的单线程收集器，与之相对地，Serial Old 是工作于老年代的单线程收集器，此收集器的主要意义在于给 Client 模式下的虚拟机使用，如果在 Server 模式下，则它还有两大用途：一种是在 JDK 1.5 及之前的版本中与 Parallel Scavenge 配合使用，另一种是作为 CMS 收集器的后备预案,在并发收集发生 Concurrent Mode Failure 时使用（后文讲述）,它与 Serial 收集器配合使用示意图如下</p><p><img src="jvm-1.assets/image-20200529230707616.png" alt="image-20200529230707616"></p><h3 id="4-2-2-Parallel-Old-收集器"><a href="#4-2-2-Parallel-Old-收集器" class="headerlink" title="4.2.2 Parallel Old 收集器"></a>4.2.2 Parallel Old 收集器</h3><p>Parallel Old 是相对于 Parallel Scavenge 收集器的老年代版本，使用多线程和标记整理法，两者组合示意图如下,这两者的组合由于都是多线程收集器，真正实现了「吞吐量优先」的目标</p><p><img src="jvm-1.assets/image-20200529230746994.png" alt="image-20200529230746994"></p><h3 id="4-2-3-CMS-收集器"><a href="#4-2-3-CMS-收集器" class="headerlink" title="4.2.3 CMS 收集器"></a>4.2.3 CMS 收集器</h3><p>CMS 收集器是以实现最短 STW 时间为目标的收集器，如果应用很重视服务的响应速度，希望给用户最好的体验，则 CMS 收集器是个很不错的选择！</p><p>我们之前说老年代主要用标记整理法，而 CMS 虽然工作于老年代，但采用的是标记清除法，主要有以下四个步骤</p><p>初始标记—&gt;并发标记—&gt;重新标记—&gt;并发清除</p><p><img src="jvm-1.assets/image-20200529230827055.png" alt="image-20200529230827055"></p><p>从图中可以的看到初始标记和重新标记两个阶段会发生 STW，造成用户线程挂起，不过初始标记仅标记 GC Roots 能关联的对象，速度很快，并发标记是进行 GC Roots  Tracing 的过程，重新标记是为了修正并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，这一阶段停顿时间一般比初始标记阶段稍长，但远比并发标记时间短。</p><p>整个过程中耗时最长的是并发标记和标记清理，不过这两个阶段用户线程都可工作，所以不影响应用的正常使用，所以总体上看，可以认为 CMS 收集器的内存回收过程是与用户线程一起并发执行的。</p><p>但 CMS 收集器远达不到完美的程度，主要有以下三个缺点</p><ul><li><p>CMS 收集器对 CPU 资源非常敏感  原因也可以理解，比如本来我本来可以有 10 个用户线程处理请求，现在却要分出 3 个作为回收线程，吞吐量下降了30%，CMS 默认启动的回收线程数是 （CPU数量+3）/ 4, 如果 CPU 数量只有一两个，那吞吐量就直接下降 50%,显然是不可接受的</p></li><li><p>CMS 无法处理浮动垃圾（Floating Garbage）,可能出现 「Concurrent Mode Failure」而导致另一次 Full GC 的产生，由于在并发清理阶段用户线程还在运行，所以清理的同时新的垃圾也在不断出现，这部分垃圾只能在下一次 GC 时再清理掉（即浮云垃圾），同时在垃圾收集阶段用户线程也要继续运行，就需要预留足够多的空间要确保用户线程正常执行，这就意味着 CMS 收集器不能像其他收集器一样等老年代满了再使用，JDK 1.5 默认当老年代使用了68%空间后就会被激活，当然这个比例可以通过 -XX:CMSInitiatingOccupancyFraction 来设置，但是如果设置地太高很容易导致在 CMS 运行期间预留的内存无法满足程序要求，会导致 Concurrent Mode Failure 失败，这时会启用 Serial Old 收集器来重新进行老年代的收集，而我们知道 Serial Old 收集器是单线程收集器，这样就会导致 STW 更长了。</p></li><li><p>CMS 采用的是标记清除法，上文我们已经提到这种方法会产生大量的内存碎片，这样会给大内存分配带来很大的麻烦，如果无法找到足够大的连续空间来分配对象，将会触发 Full GC，这会影响应用的性能。当然我们可以开启 -XX:+UseCMSCompactAtFullCollection（默认是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理会导致 STW，停顿时间会变长，还可以用另一个参数 -XX:CMSFullGCsBeforeCompation 用来设置执行多少次不压缩的 Full GC 后跟着带来一次带压缩的。</p></li></ul><h3 id="4-2-4-G1（Garbage-First）-收集器"><a href="#4-2-4-G1（Garbage-First）-收集器" class="headerlink" title="4.2.4  G1（Garbage First） 收集器"></a>4.2.4  G1（Garbage First） 收集器</h3><p>G1收集器是面向服务端的垃圾收集器，被称为驾驭一切的垃圾回收器，有以下几个特点</p><ul><li><p>像 CMS 收集器一样，能与应用程序线程并发执行。</p></li><li><p>整理空闲空间更快。</p></li><li><p>需要 GC 停顿时间更好预测。</p></li><li><p>不会像 CMS 那样牺牲大量的吞吐性能。</p></li><li><p>不需要更大的 Java Heap</p></li></ul><p>与 CMS 相比，它在以下两个方面表现更出色</p><ul><li><p>运作期间不会产生内存碎片，G1 从整体上看采用的是标记-整理法，局部（两个 Region）上看是基于复制算法实现的，两个算法都不会产生内存碎片，收集后提供规整的可用内存，这样有利于程序的长时间运行。</p></li><li><p>在 STW 上建立了可预测的停顿时间模型，用户可以指定期望停顿时间，G1 会将停顿时间控制在用户设定的停顿时间以内。</p></li></ul><p>为什么G1能建立可预测的停顿模型呢，主要原因在于 G1 对堆空间的分配与传统的垃圾收集器不一样，传统的内存分配就像我们前文所述，是连续的，分成新生代，老年代，新生代又分 Eden,S0,S1,如下</p><p><img src="jvm-1.assets/image-20200529231246462.png" alt="image-20200529231246462"></p><p>而 G1 各代的存储地址不是连续的，每一代都使用了 n 个不连续的大小相同的 Region，每个Region占有一块连续的虚拟内存地址，如图示</p><p><img src="jvm-1.assets/image-20200529231310467.png" alt="image-20200529231310467"></p><p>除了和传统的新老生代，幸存区的空间区别，Region还多了一个H，它代表Humongous，这表示这些Region存储的是巨大对象（humongous object，H-obj），即大小大于等于region一半的对象，这样超大对象就直接分配到了老年代，防止了反复拷贝移动。那么 G1 分配成这样有啥好处呢？</p><p>传统的收集器如果发生 Full GC 是对整个堆进行全区域的垃圾收集，而分配成各个 Region 的话，方便 G1 跟踪各个 Region 里垃圾堆积的价值大小（回收所获得的空间大小及回收所需经验值），这样根据价值大小维护一个优先列表，根据允许的收集时间，优先收集回收价值最大的 Region,也就避免了整个老年代的回收，也就减少了 STW 造成的停顿时间。同时由于只收集部分 Region,可就做到了 STW 时间的可控。</p><p>G1 收集器的工作步骤如下</p><ul><li><p>初始标记</p></li><li><p>并发标记</p></li><li><p>最终标记</p></li><li><p>筛选回收</p></li></ul><p><img src="jvm-1.assets/image-20200529231355861.png" alt="image-20200529231355861"></p><p>可以看到整体过程与 CMS 收集器非常类似，筛选阶段会根据各个 Region 的回收价值和成本进行排序，根据用户期望的 GC 停顿时间来制定回收计划。</p><h3 id="4-2-5-总结"><a href="#4-2-5-总结" class="headerlink" title="4.2.5 总结"></a>4.2.5 总结</h3><p>本文简述了垃圾回收的原理与垃圾收集器的种类，相信大家对开头提的一些问题应该有了更深刻的认识，在生产环境中我们要根据不同的场景来选择垃圾收集器组合，如果是运行在桌面环境处于 Client 模式的，则用 Serial + Serial Old 收集器绰绰有余，如果需要响应时间快，用户体验好的，则用 ParNew + CMS 的搭配模式，即使是号称是「驾驭一切」的 G1，也需要根据吞吐量等要求适当调整相应的 JVM 参数，没有最牛的技术，只有最合适的使用场景，切记！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java 相比 C/C++ 最显著的特点便是引入了自动垃圾回收
    
    </summary>
    
    
    
      <category term="JVM" scheme="https://dcghx.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>多线程————synchronized底层原理</title>
    <link href="https://dcghx.github.io/2020/05/09/dxc-synchronized/"/>
    <id>https://dcghx.github.io/2020/05/09/dxc-synchronized/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-28T14:25:47.881Z</updated>
    
    <content type="html"><![CDATA[<p>在java中如果使用了多线程对共享数据进行操作，那无可避免会遇到同步问题。为解决此问题可以使用synchronized对方法或者代码块进行修饰。java代码执行时先编译为.class文件再在JVM上运行，在讲述JVM如何实现synchronized前先了解一下相关准备知识。<a id="more"></a></p><p><img src="dxc-synchronized.assets/image-20200528221527507.png" alt="image-20200528221527507"></p><p>JVM内存结构主要分为三大块：堆、栈和方法区。每个线程都有自己的一个虚拟机栈，栈保存着局部变量以及所有调用的方法的参数和返回值。其他线程无法访问该线程的栈中数据。栈仅能保存基本类型和对象引用，对象是存放在堆中的。堆内存和方法区中的静态变量等数据可以被线程共享，而同步处理针对的正是共享数据。</p><p>上面采用JVM的内存结构来说明共享数据和synchronized的关系其实不太严谨，synchronized是java内存模型封装了底层后提供的一个关键字，针对的是主存和线程的工作内存而言，而JAVA的内存模型是一种抽象概念，并不能和JVM的内存结构相提并论。因为这里讲述的是JVM层面如何实现synchronized，所以就将栈的部分区域数据和线程的工作内存联系起来。</p><p>看下这段代码生成的.class文件，用以了解synchronized对方法和代码块所做的不同处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.class SynchronizedDemo &#123;  </span><br><span class="line">2.  </span><br><span class="line">3.    public synchronized void m() &#123;  </span><br><span class="line">4.        System.out.printf(&quot;WUST&quot;);  </span><br><span class="line">5.    &#125;  </span><br><span class="line">6.  </span><br><span class="line">7.    public void m2() &#123;  </span><br><span class="line">8.        synchronized(this) &#123;  </span><br><span class="line">9.            System.out.printf(&quot;WUST&quot;);  </span><br><span class="line">10.        &#125;  </span><br><span class="line">11.    &#125;  </span><br><span class="line">12.&#125;</span><br></pre></td></tr></table></figure><p>反编译后：</p><p><img src="dxc-synchronized.assets/image-20200528221647533.png" alt="image-20200528221647533"></p><p>synchronized修饰的方法在字节码中添加了一个ACC_SYNCHRONIZED的flags，同步代码块则是在同步代码块前插入monitorenter，在同步代码块结束后插入monitorexit。这两者的处理是分别是这样的：当线程执行到某个方法时，JVM会去检查该方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了那线程会去获取这个对象所对应的monitor对象（每一个对象都有且仅有一个与之对应的monitor对象）,获取成功后才执行方法体，方法执行完再释放monitor对象，在这一期间，任何其他线程都无法获得这个monitor对象。而线程执行同步代码块时遇到的monitorenter和monitorexit指令依赖monitor对象完成。这两者实现的方式本质上无区别，只是方法的同步是一种隐式的方式，不通过字节码实现。</p><p>同步和monitor有关，而monitor则和对象头有关。</p><p>这里讲一下java的对象模型。在java中，万物皆对象，而一个对象Object是一个类Class的实例。对象保存在堆中，而对象引用存放于栈中，JVM为了描述对象的结构设计了一套OOP-Klass Model（基于HotSpot虚拟机），OOP（ordinary object pointer）指的是普通的对象指针，Klass用于描述对象实例的具体类型。虽然JVM基于C++实现，但并不是将java对象直接转换为了C++的对象，这和多态的实现有一定的关系。</p><p>C++中通过虚函数表实现多态，每个包含虚函数的类都有一个虚函数表(virtual table)，虚函数表中排列着按顺序声明的所有虚函数，类对象的地址空间最靠前的位置保存着指向虚函数表的指针。C++在运行时并不维护类型信息，在编译时直接将子类的虚函数表中的虚函数替换为子类重写的方法。</p><p>java在运行时会维护类型信息以及类的继承体系，每一个类会对应方法区中的一个存放类信息的数据结构，可以通过class对象访问此数据结构。其中类型信息superclass属性指示了其超类，还有这个类所对应的方法表。在堆上创建的对象都有一个指向方法区类型信息数据结构的指针，通过这个指针可以确定对象的类型。</p><p>HotSpot设计者将对象模型拆为oop和klass，oop不含任何虚函数，而klass则含有虚函数表。klass是java类在c++中的对等体，一般在JVM加载.class文件时，在方法区中创建instanceKlass表示元数据，包括常量、字段和方法等。Klass主要有两个功能：</p><ul><li><p>实现语言层面的java类</p></li><li><p>实现java对象的分发功能</p></li></ul><p>oop是JVM在运行的过程中遇到new对象时创建的，对象包含对象头、实例数据和填充数据三部分，其中对象头包含两部分：</p><ul><li><p>Mark Word，存储对象运行时记录信息</p></li><li><p>Klass Pointer，即元数据指针，指向方法区的instanceKlass实例</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Model  &#123;  </span><br><span class="line">    public static int a &#x3D; 1;  </span><br><span class="line">    public int b;  </span><br><span class="line">  </span><br><span class="line">    public Model(int b) &#123;  </span><br><span class="line">        this.b &#x3D; b;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">    int c &#x3D; 10;  </span><br><span class="line">    Model modelA &#x3D; new Model(2);  </span><br><span class="line">    Model modelB &#x3D; new Model(3);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="dxc-synchronized.assets/image-20200528221812680.png" alt="image-20200528221812680"></p><p>感受过具体例子后再来看一下oop-klass结构图：</p><p><img src="dxc-synchronized.assets/image-20200528221829509.png" alt="image-20200528221829509"></p><p>在openJdk中的oopsHierarchy.hpp文件中定义了oop和klass体系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义了oops共同的基类  </span><br><span class="line">typedef class oopDesc*                            oop;  </span><br><span class="line">&#x2F;&#x2F; 表示一个java类型实例  </span><br><span class="line">typedef class   instanceOopDesc*            instanceOop;  </span><br><span class="line">&#x2F;&#x2F; 表示java的一个方法  </span><br><span class="line">typedef class   methodOopDesc*                    methodOop;  </span><br><span class="line">&#x2F;&#x2F; 表示java方法中不变的信息  </span><br><span class="line">typedef class   constMethodOopDesc*            constMethodOop;  </span><br><span class="line">&#x2F;&#x2F; 记录性能信息的数据结构  </span><br><span class="line">typedef class   methodDataOopDesc*            methodDataOop;  </span><br><span class="line">&#x2F;&#x2F; 定义了数组OOPS数组  </span><br><span class="line">typedef class   arrayOopDesc*                    arrayOop;  </span><br><span class="line">&#x2F;&#x2F; 表示持有一个OOP数组  </span><br><span class="line">typedef class   objArrayOopDesc*            objArrayOop;  </span><br><span class="line">&#x2F;&#x2F; 表示容纳基本类型的数组  </span><br><span class="line">typedef class   typeArrayOopDesc*            typeArrayOop;  </span><br><span class="line">&#x2F;&#x2F; 表示在Class文件中描述的常量池  </span><br><span class="line">typedef class   constantPoolOopDesc*            constantPoolOop;  </span><br><span class="line">&#x2F;&#x2F; 常量池高速缓存  </span><br><span class="line">typedef class   constantPoolCacheOopDesc*   constantPoolCacheOop;  </span><br><span class="line">&#x2F;&#x2F; 描述一个与JAVA类对等的C++类  </span><br><span class="line">typedef class   klassOopDesc*                    klassOop;  </span><br><span class="line">&#x2F;&#x2F; 表示对象头  </span><br><span class="line">typedef class   markOopDesc*                    markOop;</span><br></pre></td></tr></table></figure><p>程序每创建一个对象时便会在JVM中创建与之相对应的一个OOP对象，instanceOopDesc表示类实例，arrayOopDesc表示数组,它们的基类OopDesc定义在oop.hpp中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.private:  </span><br><span class="line">2.  volatile markOop  _mark;  </span><br><span class="line">3.  union _metadata &#123;  </span><br><span class="line">4.    wideKlassOop    _klass;  </span><br><span class="line">5.    narrowOop       _compressed_klass;  </span><br><span class="line">6.  &#125; _metadata;</span><br></pre></td></tr></table></figure><p>这一段代码表示对象头，_mark指的对象头中的Mark Word,联合体_metadata中的_klass表示未压缩的Klass指针，_compressed_klass表示压缩的Klass指针，这个Klass指针指向一个Klass对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;&#x2F;klassOop的一部分，用来描述语言层的类型  </span><br><span class="line">2.class  Klass;  </span><br><span class="line">3.&#x2F;&#x2F;在虚拟机层面描述一个Java类  </span><br><span class="line">4.class   instanceKlass;  </span><br><span class="line">5.&#x2F;&#x2F;专有instantKlass，表示java.lang.Class的Klass  </span><br><span class="line">6.class     instanceMirrorKlass;  </span><br><span class="line">7.&#x2F;&#x2F;专有instantKlass，表示java.lang.ref.Reference的子类的Klass  </span><br><span class="line">8.class     instanceRefKlass;  </span><br><span class="line">9.&#x2F;&#x2F;表示methodOop的Klass  </span><br><span class="line">10.class   methodKlass;  </span><br><span class="line">11.&#x2F;&#x2F;表示constMethodOop的Klass  </span><br><span class="line">12.class   constMethodKlass;  </span><br><span class="line">13.&#x2F;&#x2F;表示methodDataOop的Klass  </span><br><span class="line">14.class   methodDataKlass;  </span><br><span class="line">15.&#x2F;&#x2F;最为klass链的端点，klassKlass的Klass就是它自身  </span><br><span class="line">16.class   klassKlass;  </span><br><span class="line">17.&#x2F;&#x2F;表示instanceKlass的Klass  </span><br><span class="line">18.class     instanceKlassKlass;  </span><br><span class="line">19.&#x2F;&#x2F;表示arrayKlass的Klass  </span><br><span class="line">20.class     arrayKlassKlass;  </span><br><span class="line">21.&#x2F;&#x2F;表示objArrayKlass的Klass  </span><br><span class="line">22.class       objArrayKlassKlass;  </span><br><span class="line">23.&#x2F;&#x2F;表示typeArrayKlass的Klass  </span><br><span class="line">24.class       typeArrayKlassKlass;  </span><br><span class="line">25.&#x2F;&#x2F;表示array类型的抽象基类  </span><br><span class="line">26.class   arrayKlass;  </span><br><span class="line">27.&#x2F;&#x2F;表示objArrayOop的Klass  </span><br><span class="line">28.class     objArrayKlass;  </span><br><span class="line">29.&#x2F;&#x2F;表示typeArrayOop的Klass  </span><br><span class="line">30.class     typeArrayKlass;  </span><br><span class="line">31.&#x2F;&#x2F;表示constantPoolOop的Klass  </span><br><span class="line">32.class   constantPoolKlass;  </span><br><span class="line">33.&#x2F;&#x2F;表示constantPoolCacheOop的Klass  </span><br><span class="line">34.class   constantPoolCacheKlass;</span><br></pre></td></tr></table></figure><p>JVM会为每个已经加载了的类创建一个instanceKlass，也就是说当编译成.class文件并完成类加载后便会得到一个instanceKlass对象,instanceKlass表示为JVM层的java类。</p><p><img src="dxc-synchronized.assets/image-20200528222020631.png" alt="image-20200528222020631"></p><p>在JVM中，对象存在于内存中的基本形式为oop，对象对应的class也是一个对象，JVM使用klassOop来描述这个class，而klassOop又被klassklass所描述。关于对象和数组链大致如下</p><p><img src="dxc-synchronized.assets/image-20200528222041147.png" alt="image-20200528222041147"></p><p>结合JAVA内存模型，看一下new一个对象所经历的JVM操作：</p><ul><li>判断对象对应的类是否加载、链接和初始化</li></ul><p>JVM首先会根据所给的参数去常量池检查是否有这个类的符号引用，并检查这个符号引用所代表的的类是否被类加载器加载、链接和初始化过。如果没有则进行<a href="http://note.youdao.com/noteshare?id=2a53393ebcbf28d15388ab1ba14135aa&sub=AF6155EAFC3A40B28411C9F64AAF1BDB" target="_blank" rel="noopener">类加载</a>。此阶段JVM会生成instanceKlass对象表示这个类的运行时元数据。</p><ul><li>为对象分配内存</li></ul><p>类加载完成后会在堆中划分一块内存给对象。内存分配根据JAVA堆是否规整分两种方式：</p><ol><li><p>·指针碰撞：如果java堆是规整的，所有使用过的内存放一边，空闲的在另一边，此时会将指针的指示器向空闲的那端移动一段与对象头大小一致的空间。</p></li><li><p>·空闲列表：如果java堆不是规整的，JVM会维持一个列表记录空间的使用情况，分配内存时从列表中查询一个大小足够的内存分配出来，然后更新列表记录。</p></li></ol><ul><li>处理并发安全问题</li></ul><p>创建对象是频繁的动作，需要解决并发问题，有两种方式：</p><ol><li>对分配内存空间的动作进行同步处理，比如采用CAS算法并配上失败重试的方式保证更新操作的原子性。</li><li>每个线程在java堆中预先分配一小块内存，称之为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）当线程需要分配内存时在对应的TLAB上分配，当该TLAB用完再分配新的TLAB是才进行同步操作。是否使用TLAB可通过-XX:+/-UserTLAB参数进行设定。</li></ol><ul><li>初始化分配到的内存空间</li></ul><p>将分配的内存，除了对象头都初始化为0。在此阶段生成instanceOop表示java类的对象，JVM栈中会持有此对象的引用。</p><ul><li><p>设置对象的对象头</p></li><li><p>执行init方法进行初始化</p></li></ul><p>初始化对象的成员变量、调用类的构造方法</p><h1 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h1><p>前面说到monitor与对象头有关，现在分别介绍monitor和对象头（Mark Word）的结构（基于32位JVM）</p><p>monitor意为监视者，每个对象都有一个自己的监视锁。可以把monitor理解为一个特殊建筑物，这个建筑物有走廊(_EntryList)，有等候室（_WaitSet）以及一间只能容纳一个特殊访客的房间(_owner)。可以想象这样一个场景：教父在这间特殊的房子里倾听访客的要求，走廊上排着其他想寻求帮助的客人，还有一间房子是给暂时中断服务的客人等待的。示意图如下：</p><p><img src="dxc-synchronized.assets/image-20200528222326476.png" alt="image-20200528222326476"></p><p>monitor也是一个对象，在C++中由ObjectMonitor实现，其数据结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.ObjectMonitor() &#123;  </span><br><span class="line">2.  _header       &#x3D; NULL;  </span><br><span class="line">3.  _count        &#x3D; 0;  </span><br><span class="line">4.  _waiters      &#x3D; 0,  </span><br><span class="line">5.  _recursions   &#x3D; 0;  </span><br><span class="line">6.  _object       &#x3D; NULL;  </span><br><span class="line">7.  _owner        &#x3D; NULL;  </span><br><span class="line">8.  _WaitSet      &#x3D; NULL;  </span><br><span class="line">9.  _WaitSetLock  &#x3D; 0 ;  </span><br><span class="line">10.  _Responsible  &#x3D; NULL ;  </span><br><span class="line">11.  _succ         &#x3D; NULL ;  </span><br><span class="line">12.  _cxq          &#x3D; NULL ;  </span><br><span class="line">13.  FreeNext      &#x3D; NULL ;  </span><br><span class="line">14.  _EntryList    &#x3D; NULL ;  </span><br><span class="line">15.  _SpinFreq     &#x3D; 0 ;  </span><br><span class="line">16.  _SpinClock    &#x3D; 0 ;  </span><br><span class="line">17.  OwnerIsThread &#x3D; 0 ;  </span><br><span class="line">18.&#125;</span><br></pre></td></tr></table></figure><p>可以关注下几个比较关键的属性：</p><ul><li><p>owner 指向持有ObjectMonitor对象的线程</p></li><li><p>WaitSet 存放处于wait状态的线程</p></li><li><p>EntryList 存放处于等待锁block状态的线程队列</p></li><li><p>recursions 锁的重入次数</p></li><li><p>count 记录该线程获取锁的次数</p></li></ul><p>多个线程在竞争共享数据执行到同步代码块时，会在_EntryList中排队，获得对象monitor的线程在进入_Owner区域时会将monitor的_owner设为当前线程，同时计数器_count加1。若持有mnitor对象的线程调用了wait()方法会释放monitor，_owner为null，计数器_count减一，进入到_WaitSet集合中等待被唤醒。以下是获得锁和释放锁的流程图：</p><p><img src="dxc-synchronized.assets/image-20200528222424116.png" alt="image-20200528222424116"></p><p><img src="dxc-synchronized.assets/image-20200528222431370.png" alt="image-20200528222431370"></p><p>线程获取对象锁的过程并不是简单的设置，而是采用一定的策略，比如当前只有一个线程访问同步代码，则设置偏向锁，避免多次CAS操作，适应性自旋锁则可以减少阻塞导致的线程切换。在jdk1.6之前，调用objectMonitor的enter和exit是和操作系统的互斥量mutex直接映射的，同步操作时无可避免会导致核心态和用户态切换等问题，所以把这种锁称为重量锁。</p><p>在描述为锁优化和锁膨胀技术前，看下和monitor有关的对象头结构：</p><p><img src="dxc-synchronized.assets/image-20200528222447532.png" alt="image-20200528222447532"></p><p>对象头存放着对象的hashCode、锁标志位以及GC分代年龄等信息。由图中可知对象有五种状态四种锁，用1bit表示是否为偏向锁。</p><ul><li>偏向锁</li></ul><p>偏向锁的目标是减少在无竞争其只有一个线程使用锁的情况下使用轻量锁产生的性能消耗。轻量锁在申请和释放锁时都会做一次CAS，而偏向锁只在申请的时候做一次CAS。第一个访问同步代码块的线程申请锁时在mark word中CAS记录owner，如果记录成功则偏向锁获取成功，标志位偏向锁，否则说明有其他的线程在竞争，膨胀为轻量锁。</p><ul><li>轻量锁</li></ul><p>轻量锁的目标是减少无实际竞争情况下使用重量锁产生的性能消耗。使用轻量锁时无需使用metux互斥量，仅仅将Mrak Word中的部分字节CAS更新指向线程栈中的Lock Record（每个线程在JVM中都有一个自己的栈，可记录线程和方法调用的基本信息），如果成功则获取轻量锁成功，在对象头中标志位轻量锁，否则说明当前发生了竞争，膨胀为重量锁。</p><ul><li>自旋锁</li></ul><p>自旋锁可以优化因阻塞而引起的线程切换。当竞争不激烈且持有锁的时间不长时，并不让线程挂起等待锁的释放，而是让线程做一个空循环的自旋操作，如果在循环结束后获得锁则说明自旋锁成功，否则会阻塞自己。自适应自旋锁是自旋锁的基础上自己调整自己。比如针对同一个同步代码块做自旋锁操作时，如果经常没获取成功，则下一次就要增加时长（当然并不能无限增大，自旋锁针对的是持有锁时间短的情况，在其他场景下自旋锁就会白白浪费CPU时间）</p><ul><li>重量锁</li></ul><p>重量锁直接调用objectMonitor的enter和exit，它和操作系统的互斥量直接对应，系统调用会引起用户态和和心态的切换等问题，性能消耗大。</p><ul><li>锁消除</li></ul><p>有时候虽然对代码块进行了同步操作，但是是多数的的时候JIT编译器会在编译同步代码块时取消对这部分代码的同步。JIT(just in time)编译器会利用逃逸分析技术<br>判断同步代码所使用的锁对象是否只能怪被一个线程访问而不发布到其他线程。比如在一个方法中声明一个对象，在方法中利用这个对象进行同步操作，除此方法外其他地方都没用到这个对象，那这个同步操作将会被消除，因为当方法执行完后这个对象也会被回收，其他线程自然访问不到该对象，也就没必要做同步操作。</p><ul><li>锁粗化</li></ul><p>锁粗化和锁消除相反，是将同步范围扩大的操作。在一般开发中，提倡减少锁的粒度，但有时候对一段同步代码频繁地使用，比如在循环体内做同步操作，JIT发现一系列的操作都在对同一个对象进行反复加锁和解锁时，则会将锁同步的范围扩散至整个操作序列的外部。</p><p>介绍完锁的优化技术后，配合下图可以更好地理解synchronized的原理。</p><p><img src="dxc-synchronized.assets/image-20200528222546878.png" alt="image-20200528222546878"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在java中如果使用了多线程对共享数据进行操作，那无可避免会遇到同步问题。为解决此问题可以使用synchronized对方法或者代码块进行修饰。java代码执行时先编译为.class文件再在JVM上运行，在讲述JVM如何实现synchronized前先了解一下相关准备知识。
    
    </summary>
    
    
    
      <category term="多线程" scheme="https://dcghx.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程————lock</title>
    <link href="https://dcghx.github.io/2020/05/09/dxc-lock/"/>
    <id>https://dcghx.github.io/2020/05/09/dxc-lock/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-28T14:31:42.269Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="多线程" scheme="https://dcghx.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM——2-类加载机制</title>
    <link href="https://dcghx.github.io/2020/05/09/jvm-2-ljz/"/>
    <id>https://dcghx.github.io/2020/05/09/jvm-2-ljz/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-29T16:31:28.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>你是否真的理解java的类加载机制？点进文章的盆友不如先来做一道非常常见的面试题，如果你能做出来，可能你早已掌握并理解了java的类加载机制，若结果出乎你的意料，那就很有必要来了解了解java的类加载机制了。代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.package com.jvm.classloader;  </span><br><span class="line">2.  </span><br><span class="line">3.class Father2&#123;  </span><br><span class="line">4.    public static String strFather&#x3D;&quot;HelloJVM_Father&quot;;  </span><br><span class="line">5.  </span><br><span class="line">6.    static&#123;  </span><br><span class="line">7.        System.out.println(&quot;Father静态代码块&quot;);  </span><br><span class="line">8.    &#125;  </span><br><span class="line">9.&#125;  </span><br><span class="line">10.  </span><br><span class="line">11.class Son2 extends Father2&#123;  </span><br><span class="line">12.    public static String strSon&#x3D;&quot;HelloJVM_Son&quot;;  </span><br><span class="line">13.  </span><br><span class="line">14.    static&#123;  </span><br><span class="line">15.        System.out.println(&quot;Son静态代码块&quot;);  </span><br><span class="line">16.    &#125;  </span><br><span class="line">17.&#125;  </span><br><span class="line">18.  </span><br><span class="line">19.public class InitativeUseTest2 &#123;  </span><br><span class="line">20.    public static void main(String[] args) &#123;  </span><br><span class="line">21.  </span><br><span class="line">22.       System.out.println(Son2.strSon);  </span><br><span class="line">23.    &#125;  </span><br><span class="line">24.&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Father静态代码块  </span><br><span class="line">2. Son静态代码块  </span><br><span class="line">   HelloJVM_Son</span><br></pre></td></tr></table></figure><p>嗯哼？其实上面程序并不是关键，可能真的难不倒各位，不妨做下面一道面试题可好？如果下面这道面试题都做对了，那没错了，这篇文章你就不用看了，真的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.class YeYe&#123;  </span><br><span class="line">2.    static &#123;  </span><br><span class="line">3.        System.out.println(&quot;YeYe静态代码块&quot;);  </span><br><span class="line">4.    &#125;  </span><br><span class="line">5.&#125;  </span><br><span class="line">6.  </span><br><span class="line">7.class Father extends YeYe&#123;  </span><br><span class="line">8.    public static String strFather&#x3D;&quot;HelloJVM_Father&quot;;  </span><br><span class="line">9.  </span><br><span class="line">10.    static&#123;  </span><br><span class="line">11.        System.out.println(&quot;Father静态代码块&quot;);  </span><br><span class="line">12.    &#125;  </span><br><span class="line">13.&#125;  </span><br><span class="line">14.  </span><br><span class="line">15.class Son extends Father&#123;  </span><br><span class="line">16.    public static String strSon&#x3D;&quot;HelloJVM_Son&quot;;  </span><br><span class="line">17.  </span><br><span class="line">18.    static&#123;  </span><br><span class="line">19.        System.out.println(&quot;Son静态代码块&quot;);  </span><br><span class="line">20.    &#125;  </span><br><span class="line">21.&#125;  </span><br><span class="line">22.  </span><br><span class="line">23.public class InitiativeUse &#123;  </span><br><span class="line">24.    public static void main(String[] args) &#123;  </span><br><span class="line">25.        System.out.println(Son.strFather);   </span><br><span class="line">26.    &#125;  </span><br><span class="line">27.&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.YeYe静态代码块  </span><br><span class="line">2.Father静态代码块  </span><br><span class="line">3.HelloJVM_Father</span><br></pre></td></tr></table></figure><p>是对是错已经有个数了吧，我就不拆穿各位的小心思了…</p><p>以上的面试题其实就是典型的java类的加载问题，如果你对Java加载机制不理解，那么你可能就错了上面两道题目的。这篇文章将通过对Java类加载机制的讲解，让各位熟练理解java类的加载机制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.package com.jvm.classloader;  </span><br><span class="line">2.  </span><br><span class="line">3.class YeYe&#123;  </span><br><span class="line">4.    static &#123;  </span><br><span class="line">5.        System.out.println(&quot;YeYe静态代码块&quot;);  </span><br><span class="line">6.    &#125;  </span><br><span class="line">7.&#125;  </span><br><span class="line">8.  </span><br><span class="line">9.class Father extends YeYe&#123;  </span><br><span class="line">10.    public final static String strFather&#x3D;&quot;HelloJVM_Father&quot;;  </span><br><span class="line">11.  </span><br><span class="line">12.    static&#123;  </span><br><span class="line">13.        System.out.println(&quot;Father静态代码块&quot;);  </span><br><span class="line">14.    &#125;  </span><br><span class="line">15.&#125;  </span><br><span class="line">16.  </span><br><span class="line">17.class Son extends Father&#123;  </span><br><span class="line">18.    public static String strSon&#x3D;&quot;HelloJVM_Son&quot;;  </span><br><span class="line">19.  </span><br><span class="line">20.    static&#123;  </span><br><span class="line">21.        System.out.println(&quot;Son静态代码块&quot;);  </span><br><span class="line">22.    &#125;  </span><br><span class="line">23.&#125;  </span><br><span class="line">24.  </span><br><span class="line">25.public class InitiativeUse &#123;  </span><br><span class="line">26.    public static void main(String[] args) &#123;  </span><br><span class="line">27.        System.out.println(Son.strFather);  </span><br><span class="line">28.    &#125;  </span><br><span class="line">29.&#125;</span><br></pre></td></tr></table></figure><p>运行结果： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果：HelloJVM_Father</span><br></pre></td></tr></table></figure><h1 id="2-什么是类的加载（类初始化）"><a href="#2-什么是类的加载（类初始化）" class="headerlink" title="2.什么是类的加载（类初始化）"></a>2.什么是类的加载（类初始化）</h1><p>JVM重要的一个领域：类加载</p><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。而类加载必然涉及类加载器，下面我们先来了解一下类的加载。</p><p>类的加载（类初始化）：</p><ul><li><p>在java代码中，类型的加载、连接、与初始化过程都是在程序运行期间完成的（类从磁盘加载到内存中经历的三个阶段）【牢牢记在心里】</p></li><li><p>提供了更大的灵活性，增加了更多的可能性</p></li></ul><p>虽然上面的第一句话非常简短，但是蕴含的知识量却是巨大的！包含两个重要的概念：</p><p>1) 类型</p><p>定义的类、接口或者枚举称为类型而不涉及对象，在类加载的过程中，是一个创建对象之前的一些信息</p><p>2) 程序运行期间</p><p>程序运行期间完成典型例子就是动态代理，其实很多语言都是在编译期就完成了加载，也正因为这个特性给Java程序提供了更大的灵活性，增加了更多的可能性</p><h2 id="2-1-类加载注意事项"><a href="#2-1-类加载注意事项" class="headerlink" title="2.1 类加载注意事项"></a>2.1 类加载注意事项</h2><p>1) 类加载器并不需要等到某个类被 “首次主动使用” 时再加载它（关于首次主动使用这个重要概念下文将讲解）</p><p>2) JVM规范允许类加载器在预料某个类将要被使用时就预先加载它</p><p>3) 如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><h1 id="3-类的生命周期"><a href="#3-类的生命周期" class="headerlink" title="3.类的生命周期"></a>3.类的生命周期</h1><p><img src="jvm-2-ljz.assets/image-20200529234307180.png" alt="image-20200529234307180"></p><p>从上图可知，类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括 7 个阶段，而验证、准备、解析 3 个阶段统称为连接。</p><p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是固定确定的，类的加载过程必须按照这种顺序开始（注意是“开始”，而不是“进行”），而解析阶段则不一定：它在某些情况下可以在初始化后再开始，这是为了支持 Java 语言的运行时绑定【也就是java的动态绑定/晚期绑定】。</p><h2 id="3-1加载"><a href="#3-1加载" class="headerlink" title="3.1加载"></a>3.1加载</h2><p>在上面已经提到过，加载阶段是类加载的第一个阶段！类的加载过程就是从加载阶段开始~</p><p>加载阶段指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象（JVM规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在方法区中），用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 Class对象， Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p>Class对象是存放在堆区的，不是方法区，这点很多人容易犯错。类的元数据才是存在方法区的。【元数据并不是类的Class对象。Class对象是加载的最终产品，类的方法代码，变量名，方法名，访问权限，返回值等等都是在方法区的】</p><p>JDK7创建Class实例存在堆中；因为JDK7中JavaObjectsInPerm参数值固定为false。<br>JDK8移除了永久代，转而使用元空间来实现方法区，创建的Class实例依旧在java heap（堆）中</p><p><img src="jvm-2-ljz.assets/image-20200529234402176.png" alt="image-20200529234402176"></p><p>编写一个新的java类时,JVM就会帮我们编译成class对象,存放在同名的.class文件中。在运行时，当需要生成这个类的对象，JVM就会检查此类是否已经装载内存中。若是没有装载，则把.class文件装入到内存中。若是装载，则根据class文件生成实例对象。</p><p>怎么理解Class对象与new出来的对象之间的关系呢？</p><p>new出来的对象以car为例。可以把car的Class类看成具体的一个人，而new car则是人物映像，具体的一个人（Class）是唯一的，人物映像（new car）是多个的。镜子中的每个人物映像都是根据具体的人映造出来的，也就是说每个new出来的对象都是以Class类为模板参照出来的！为啥可以参照捏？因为Class对象提供了访问方法区内的数据结构的接口哇，上面提及过了喔！</p><p><img src="jvm-2-ljz.assets/image-20200529235200676.png" alt="image-20200529235200676"></p><p>总结：</p><p>加载阶段简单来说就是：</p><p>.class文件（二进制数据）——&gt;读取到内存——&gt;元数据放进方法区——&gt;堆中创建对应Class对象——&gt;并提供访问方法区的接口</p><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p>加载.calss文件的方式:</p><p>类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。通过使用不同的类加载器，可以从不同来源加载类的二进制数据，二进制数据通常有如下几种来源：</p><p>（1）从本地系统中直接加载</p><p>（2）通过网络下载.class文件</p><p>（3）从zip，jar等归档文件中加载.class文件</p><p>（4）从专用数据库中提取.class文件</p><p>（5）将java源文件动态编译为.class文件</p><h2 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a>3.2 验证</h2><p>验证：确保被加载的类的正确性。</p><p>关于验证大可不必深入但是了解类加载机制必须要知道有这么个过程以及知道验证就是为了验证确保Class文件的字节流中包含的信息符合当前虚拟机的要求即可。<br>所以下面关于验证的内容作为了解即可</p><p>验证是连接阶段的第一阶段，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：确保解析动作能正确执行。</li></ul><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h2 id="3-3-准备"><a href="#3-3-准备" class="headerlink" title="3.3 准备"></a>3.3 准备</h2><p>当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</p><p>这里需要注意两个关键点，即<strong><em>\</em>内存分配的对象**</strong>以及<strong><em>\</em>初始化的类型**</strong>。</p><p>内存分配的对象：要明白首先要知道Java 中的变量有类变量以及类成员变量两种类型，类变量指的是被 static 修饰的变量，而其他所有类型的变量都属于类成员变量。在准备阶段，JVM 只会为类变量分配内存，而不会为类成员变量分配内存。类成员变量的内存分配需要等到初始化阶段才开始（初始化阶段下面会讲到）。</p><p>举个例子：例如下面的代码在准备阶段，只会为 LeiBianLiang属性分配内存，而不会为 ChenYuanBL属性分配内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.public static int LeiBianLiang &#x3D; 666;  </span><br><span class="line">2.public String ChenYuanBL &#x3D; &quot;jvm&quot;;</span><br></pre></td></tr></table></figure><p>初始化的类型：在准备阶段，JVM 会为类变量分配内存，并为其初始化（JVM 只会为类变量分配内存，而不会为类成员变量分配内存，类成员变量自然这个时候也不能被初始化）。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的默认值，而不是用户代码里初始化的值。</p><p>例如下面的代码在准备阶段之后，LeiBianLiang 的值将是 0，而不是 666。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.public static int LeiBianLiang &#x3D; 666;</span><br></pre></td></tr></table></figure><p>但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。例如下面的代码在准备阶段之后，ChangLiang的值将是 666，而不再会是 0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.public static final int ChangLiang &#x3D; 666;</span><br></pre></td></tr></table></figure><p>之所以 static final 会直接被复制，而 static 变量会被赋予java语言类型的默认值。其实我们稍微思考一下就能想明白了。</p><p>两个语句的区别是一个有 final 关键字修饰，另外一个没有。而 final 关键字在 Java 中代表不可改变的意思，意思就是说 ChangLiang的值一旦赋值就不会在改变了。既然一旦赋值就不会再改变，那么就必须一开始就给其赋予用户想要的值，因此被 final 修饰的类变量在准备阶段就会被赋予想要的值。而没有被 final 修饰的类变量，其可能在初始化阶段或者运行阶段发生变化，所以就没有必要在准备阶段对它赋予用户想要的值。</p><h2 id="3-4-解析"><a href="#3-4-解析" class="headerlink" title="3.4 解析"></a>3.4 解析</h2><p>当通过准备阶段之后，进入解析阶段。解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p><p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p>其实这个阶段对于我们来说也是几乎透明的，了解一下就好。</p><h2 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a>3.5 初始化</h2><p>到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。</p><p>Java程序对类的使用方式可分为两种:主动使用与被动使用。一般来说只有当对类的首次主动使用的时候才会导致类的初始化，所以主动使用又叫做类加载过程中“初始化”开始的时机。那啥是主动使用呢？类的主动使用包括以下六种【超级重点】：</p><p>1) 创建类的实例，也就是new的方式</p><p>2) 访问某个类或接口的静态变量，或者对该静态变量赋值（凡是被final修饰不不不其实更准确的说是在编译器把结果放入常量池的静态字段除外） </p><p>3) 调用类的静态方法</p><p>4) 反射（如 Class.forName(“com.gx.yichun”)）</p><p>5) 初始化某个类的子类，则其父类也会被初始化</p><p>6) Java虚拟机启动时被标明为启动类的类（ JavaTest ），还有就是Main方法的类会首先被初始化</p><p>最后注意一点对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块），这句话在继承、多态中最为明显！为了方便理解下文会陆续通过例子讲解</p><h2 id="3-6-使用"><a href="#3-6-使用" class="headerlink" title="3.6 使用"></a>3.6 使用</h2><p>当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。这个使用阶段也只是了解一下就可以了。</p><h2 id="3-7-卸载"><a href="#3-7-卸载" class="headerlink" title="3.7 卸载"></a>3.7 卸载</h2><p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。这个卸载阶段也只是了解一下就可以了。</p><h2 id="3-8-结束生命周期"><a href="#3-8-结束生命周期" class="headerlink" title="3.8 结束生命周期"></a>3.8 结束生命周期</h2><p>在如下几种情况下，Java虚拟机将结束生命周期</p><p>1) 执行了 System.exit()方法</p><p>2) 程序正常执行结束</p><p>3) 程序在执行过程中遇到了异常或错误而异常终止</p><p>4) 由于操作系统出现错误而导致Java虚拟机进程终止</p><h1 id="4-接口的加载过程"><a href="#4-接口的加载过程" class="headerlink" title="4 接口的加载过程"></a>4 接口的加载过程</h1><p>接口加载过程与类加载过程稍有不同。</p><p>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。</p><h1 id="5-解开开篇面试题"><a href="#5-解开开篇面试题" class="headerlink" title="5 解开开篇面试题"></a>5 解开开篇面试题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.class Father2&#123;  </span><br><span class="line">2.    public static String strFather&#x3D;&quot;HelloJVM_Father&quot;;  </span><br><span class="line">3.  </span><br><span class="line">4.    static&#123;  </span><br><span class="line">5.        System.out.println(&quot;Father静态代码块&quot;);  </span><br><span class="line">6.    &#125;  </span><br><span class="line">7.&#125;  </span><br><span class="line">8.  </span><br><span class="line">9.class Son2 extends Father2&#123;  </span><br><span class="line">10.    public static String strSon&#x3D;&quot;HelloJVM_Son&quot;;  </span><br><span class="line">11.  </span><br><span class="line">12.    static&#123;  </span><br><span class="line">13.        System.out.println(&quot;Son静态代码块&quot;);  </span><br><span class="line">14.    &#125;  </span><br><span class="line">15.&#125;  </span><br><span class="line">16.  </span><br><span class="line">17.public class InitativeUseTest2 &#123;  </span><br><span class="line">18.    public static void main(String[] args) &#123;  </span><br><span class="line">19.  </span><br><span class="line">20.       System.out.println(Son2.strSon);  </span><br><span class="line">21.    &#125;  </span><br><span class="line">22.&#125;  </span><br><span class="line">23.  </span><br><span class="line">24.运行结果：  </span><br><span class="line">25.        Father静态代码块  </span><br><span class="line">26.        Son静态代码块  </span><br><span class="line">27.        HelloJVM_Son</span><br></pre></td></tr></table></figure><p>再回头看这个题，这也太简单了吧，由于Son2.strSon是调用了Son类自己的静态方法属于主动使用，所以会初始化Son类，又由于继承关系，类继承原则是初始化一个子类，会先去初始化其父类，所以会先去初始化父类！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1.class YeYe&#123;  </span><br><span class="line">2.    static &#123;  </span><br><span class="line">3.        System.out.println(&quot;YeYe静态代码块&quot;);  </span><br><span class="line">4.    &#125;  </span><br><span class="line">5.&#125;  </span><br><span class="line">6.  </span><br><span class="line">7.class Father extends YeYe&#123;  </span><br><span class="line">8.    public static String strFather&#x3D;&quot;HelloJVM_Father&quot;;  </span><br><span class="line">9.  </span><br><span class="line">10.    static&#123;  </span><br><span class="line">11.        System.out.println(&quot;Father静态代码块&quot;);  </span><br><span class="line">12.    &#125;  </span><br><span class="line">13.&#125;  </span><br><span class="line">14.  </span><br><span class="line">15.class Son extends Father&#123;  </span><br><span class="line">16.    public static String strSon&#x3D;&quot;HelloJVM_Son&quot;;  </span><br><span class="line">17.  </span><br><span class="line">18.    static&#123;  </span><br><span class="line">19.        System.out.println(&quot;Son静态代码块&quot;);  </span><br><span class="line">20.    &#125;  </span><br><span class="line">21.&#125;  </span><br><span class="line">22.  </span><br><span class="line">23.public class InitiativeUse &#123;  </span><br><span class="line">24.    public static void main(String[] args) &#123;  </span><br><span class="line">25.        System.out.println(Son.strFather);   </span><br><span class="line">26.    &#125;  </span><br><span class="line">27.&#125;  </span><br><span class="line">28.  </span><br><span class="line">29.运行结果：  </span><br><span class="line">30.    YeYe静态代码块  </span><br><span class="line">31.    Father静态代码块  </span><br><span class="line">32.    HelloJVM_Father</span><br></pre></td></tr></table></figure><p>注意子类Son类没有被初始化</p><p>首先看到Son.strFather，你会发现是子类Son访问父类Father的静态变量strFather，这个时候就千万要记住我在归纳主动使用概念时特别提到过的一个注意点了：对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块），这句话在继承、多态中最为明显！</p><p>嗯哼，对吧，Son.strFather中的静态字段是属于父类Father的对吧，也就是说直接定义这个字段的类是父类Father，所以在执行 System.out.println(Son.strFather); 这句代码的时候会去初始化Father类而不是子类Son！是不是一下子明白了？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.class YeYe&#123;  </span><br><span class="line">2.    static &#123;  </span><br><span class="line">3.        System.out.println(&quot;YeYe静态代码块&quot;);  </span><br><span class="line">4.    &#125;  </span><br><span class="line">5.&#125;  </span><br><span class="line">6.  </span><br><span class="line">7.class Father extends YeYe&#123;  </span><br><span class="line">8.    public final static String strFather&#x3D;&quot;HelloJVM_Father&quot;;  </span><br><span class="line">9.  </span><br><span class="line">10.    static&#123;  </span><br><span class="line">11.        System.out.println(&quot;Father静态代码块&quot;);  </span><br><span class="line">12.    &#125;  </span><br><span class="line">13.&#125;  </span><br><span class="line">14.  </span><br><span class="line">15.class Son extends Father&#123;  </span><br><span class="line">16.    public static String strSon&#x3D;&quot;HelloJVM_Son&quot;;  </span><br><span class="line">17.  </span><br><span class="line">18.    static&#123;  </span><br><span class="line">19.        System.out.println(&quot;Son静态代码块&quot;);  </span><br><span class="line">20.    &#125;  </span><br><span class="line">21.&#125;  </span><br><span class="line">22.  </span><br><span class="line">23.public class InitiativeUse &#123;  </span><br><span class="line">24.    public static void main(String[] args) &#123;  </span><br><span class="line">25.        System.out.println(Son.strFather);  </span><br><span class="line">26.    &#125;  </span><br><span class="line">27.&#125;  </span><br><span class="line">28.  </span><br><span class="line">29.运行结果：HelloJVM_Father</span><br></pre></td></tr></table></figure><p>这个题唯一的特点就在于final static ！是的Son.strFather所对应的变量便是final static修饰的，依旧是在本篇文章中归纳的类的主动使用范畴第二点当中：访问某个类或接口的静态变量，或者对该静态变量赋值（凡是被final修饰不不不其实更准确的说是在编译器把结果放入常量池的静态字段除外）</p><p>所以，这个题并不会初始化任何类，当然除了Main方法所在的类！于是仅仅执行了System.out.println(Son.strFather);所以仅仅打印了Son.strFather的字段结果HelloJVM_Father，嗯哼，是不是又突然明白了？</p><p>实际上上面的题目并不能完全说明本篇文章中归纳的类的主动使用范畴第二点！这话怎么说呢？怎么理解呢？再来一个程序各位就更加明了了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.class Test&#123;  </span><br><span class="line">2.    static &#123;  </span><br><span class="line">3.        System.out.println(&quot;static 静态代码块&quot;);  </span><br><span class="line">4.    &#125;  </span><br><span class="line">5.  </span><br><span class="line">6.&#x2F;&#x2F;    public static final String str&#x3D; UUID.randomUUID().toString();  </span><br><span class="line">7.    public static final double str&#x3D;Math.random();  &#x2F;&#x2F;编译期不确定  </span><br><span class="line">8.&#125;  </span><br><span class="line">9.  </span><br><span class="line">10.  </span><br><span class="line">11.public class FinalUUidTest &#123;  </span><br><span class="line">12.    public static void main(String[] args) &#123;  </span><br><span class="line">13.        System.out.println(Test.str);  </span><br><span class="line">14.    &#125;  </span><br><span class="line">15.&#125;  </span><br><span class="line">16.  </span><br><span class="line">17.输出  </span><br><span class="line">18.static 静态代码块  </span><br><span class="line">0.7338688977344875</span><br></pre></td></tr></table></figure><p>上面这个程序完全说明本篇文章中归纳的类的主动使用范畴第二点当中的这句话：凡是被final修饰不不不其实更准确的说是在编译器把结果放入常量池的静态字段除外！</p><p>分析：其实final不是重点，重点是编译器把结果放入常量池！当一个常量的值并非编译期可以确定的，那么这个值就不会被放到调用类的常量池中，这时在程序运行时，会导致主动使用这个常量所在的类，所以这个类会被初始化</p><p>单纯的想巅覆各位对java代码的认知，当然还望大佬轻拍哈哈哈，直接上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.public class ClassAndObjectLnitialize &#123;  </span><br><span class="line">2.         int ZhiShang &#x3D; 250;  </span><br><span class="line">3.        static int QingShang &#x3D; 666;  </span><br><span class="line">4.</span><br><span class="line">5.        &#123;  </span><br><span class="line">6.            System.out.println(&quot;普通代码块&quot;);  </span><br><span class="line">7.        &#125;  </span><br><span class="line">8.  </span><br><span class="line">9.        static&#123;  </span><br><span class="line">10.            System.out.println(&quot;静态代码块&quot;);  </span><br><span class="line">11.        &#125;  </span><br><span class="line">12.  </span><br><span class="line">13.      public ClassAndObjectLnitialize()&#123;  </span><br><span class="line">14.            System.out.println(&quot;构造方法&quot;);  </span><br><span class="line">15.System.out.println(&quot;我是熊孩子我的智商&#x3D;&quot; + ZhiShang +&quot;,情商&#x3D;&quot; + QingShang);  </span><br><span class="line">16.        &#125;          </span><br><span class="line">17.  </span><br><span class="line">18.      public static void main(String[] args) &#123;  </span><br><span class="line">19.            System.out.println(&quot;输出的打印语句&quot;);  </span><br><span class="line">20.        &#125;  </span><br><span class="line">21.&#125;</span><br></pre></td></tr></table></figure><p>建议这个题不要花太多时间思考，否则看了结果你会发现自己想太多了，导致最后可能你看到结果想砸电脑哈哈哈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.运行结果  </span><br><span class="line">2.        静态代码块  </span><br><span class="line">3.        输出的打印语句</span><br></pre></td></tr></table></figure><p>下面我们来简单分析一下，首先根据上面说到的触发初始化的（主动使用）的第六点：Java虚拟机启动时被标明为启动类的类（ JavaTest ），还有就是Main方法的类会首先被初始化</p><p>嗯哼？小白童鞋就有疑问了：不是说好有Main方法的类会被初始化的么？那怎么好多东西都没有执行捏？</p><p>那么类的初始化顺序到底是怎么样的呢？在我们代码中，我们只知道有一个构造方法，但实际上Java代码编译成字节码之后，最开始是没有构造方法的概念的，只有类初始化方法 和 对象初始化方法 。</p><p>这个时候我们就不得不深入理解了！那么这两个方法是怎么来的呢？</p><ul><li>类初始化方法：编译器会按照其出现顺序，收集：类变量（static变量）的赋值语句、静态代码块，最终组成类初始化方法。类初始化方法一般在类初始化的时候执行。</li></ul><p>所以，上面的这个例子，类初始化方法就会执行下面这段代码了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.static int QingShang &#x3D; 666;  &#x2F;&#x2F;类变量（static变量）的赋值语句  </span><br><span class="line">2.  </span><br><span class="line">3. static   &#x2F;&#x2F;静态代码块  </span><br><span class="line">4.  &#123;  </span><br><span class="line">5.      System.out.println(&quot;静态代码块&quot;);  </span><br><span class="line">6.  &#125;</span><br></pre></td></tr></table></figure><ul><li>对象初始化方法：编译器会按照其出现顺序，收集：成员变量的赋值语句、普通代码块，最后收集构造函数的代码，最终组成对象初始化方法，值得特别注意的是，如果没有监测或者收集到构造函数的代码，则将不会执行对象初始化方法。对象初始化方法一般在实例化类对象的时候执行。</li></ul><p>以上面这个例子，其对象初始化方法就是下面这段代码了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.&#123;                          </span><br><span class="line">2.   System.out.println(&quot;普通代码块&quot;);    &#x2F;&#x2F;普通代码块  </span><br><span class="line">3.&#125;  </span><br><span class="line">4.  </span><br><span class="line">5.int ZhiShang &#x3D; 250;   &#x2F;&#x2F;成员变量的赋值语句  </span><br><span class="line">6.  </span><br><span class="line">7.System.out.println(&quot;构造方法&quot;);  &#x2F;&#x2F;最后收集构造函数的代码  </span><br><span class="line">System.out.println(&quot;我是熊孩子我的智商&#x3D;&quot; + ZhiShang +&quot;,情商&#x3D;&quot; + QingShang);</span><br></pre></td></tr></table></figure><p>明白了类初始化方法 和 对象初始化方法 之后，我们再来看这个上面例子！是的！正如上面提到的：如果没有监测或者收集到构造函数的代码，则将不会执行对象初始化方法。上面的这个例子确实没有执行对象初始化方法。忘了吗？我们根本就没有对类ClassAndObjectLnitialize 进行实例化！只是单纯的写了一个输出语句。如果我们给其实例化，验证一下，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1.public class ClassAndObjectLnitialize &#123;  </span><br><span class="line">2.  </span><br><span class="line">3.        public static void main(String[] args) &#123;  </span><br><span class="line">4.            new ClassAndObjectLnitialize();  </span><br><span class="line">5.            System.out.println(&quot;输出的打印语句&quot;);  </span><br><span class="line">6.        &#125;  </span><br><span class="line">7.  </span><br><span class="line">8.      public ClassAndObjectLnitialize()&#123;  </span><br><span class="line">9.  </span><br><span class="line">10.            System.out.println(&quot;构造方法&quot;);  </span><br><span class="line">11.System.out.println(&quot;我是熊孩子我的智商&#x3D;&quot; + ZhiShang +&quot;,情商&#x3D;&quot; + QingShang);  </span><br><span class="line">12.        &#125;  </span><br><span class="line">13.  </span><br><span class="line">14.        &#123;  </span><br><span class="line">15.            System.out.println(&quot;普通代码块&quot;);  </span><br><span class="line">16.        &#125;  </span><br><span class="line">17.  </span><br><span class="line">18.        int ZhiShang &#x3D; 250;  </span><br><span class="line">19.        static int QingShang &#x3D; 666;  </span><br><span class="line">20.          </span><br><span class="line">21.        static  </span><br><span class="line">22.        &#123;  </span><br><span class="line">23.            System.out.println(&quot;静态代码块&quot;);  </span><br><span class="line">24.        &#125;        </span><br><span class="line">25.&#125;  </span><br><span class="line">26.  </span><br><span class="line">27.运行结果：  </span><br><span class="line">28.        静态代码块  </span><br><span class="line">29.        普通代码块  </span><br><span class="line">30.        构造方法  </span><br><span class="line">31.        我是熊孩子我的智商&#x3D;250,情商&#x3D;666  </span><br><span class="line">32.        输出的打印语句</span><br></pre></td></tr></table></figure><h1 id="5-理解首次主动使用"><a href="#5-理解首次主动使用" class="headerlink" title="5. 理解首次主动使用"></a>5. 理解首次主动使用</h1><p>我在上面提到过Java程序对类的使用方式可分为两种:主动使用与被动使用。一般来说只有当对类的首次主动使用的时候才会导致类的初始化，其中首次关键字很重要，因此特地用一小结将其讲解！怎么理解呢？老规矩看个题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.class Father6&#123;  </span><br><span class="line">2.    public static int a &#x3D; 1;  </span><br><span class="line">3.    static &#123;  </span><br><span class="line">4.        System.out.println(&quot;父类粑粑静态代码块&quot;);  </span><br><span class="line">5.    &#125;  </span><br><span class="line">6.&#125;  </span><br><span class="line">7.class Son6&#123;  </span><br><span class="line">8.    public static int b &#x3D; 2;  </span><br><span class="line">9.    static &#123;System.out.println(&quot;子类熊孩子静态代码块&quot;);&#125;  </span><br><span class="line">10.&#125;  </span><br><span class="line">11.  </span><br><span class="line">12.public class OverallTest &#123;  </span><br><span class="line">13.    static &#123; System.out.println(&quot;Main方法静态代码块&quot;); &#125;  </span><br><span class="line">14.  </span><br><span class="line">15.    public static void main(String[] args) &#123;  </span><br><span class="line">16.        Father6 father6;  </span><br><span class="line">17.        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);  </span><br><span class="line">18.  </span><br><span class="line">19.         father6&#x3D;new Father6();  </span><br><span class="line">20.        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);  </span><br><span class="line">21.  </span><br><span class="line">22.        System.out.println(Father6.a);  </span><br><span class="line">23.        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);  </span><br><span class="line">24.  </span><br><span class="line">25.        System.out.println(Son6.b);  </span><br><span class="line">26.  </span><br><span class="line">27.    &#125;  </span><br><span class="line">1.&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2.        Main方法静态代码块  </span><br><span class="line">3.        &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  </span><br><span class="line">4.        父类粑粑静态代码块  </span><br><span class="line">5.        &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  </span><br><span class="line">6.        1  </span><br><span class="line">7.        &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  </span><br><span class="line">8.        子类熊孩子静态代码块  </span><br><span class="line">9.        2</span><br></pre></td></tr></table></figure><p>分析：</p><p>首先根据主动使用概括的第六点：Main方法的类会首先被初始化。 所以最先执行Main方法静态代码块，而 Father6 father6;只是声明了一个引用不会执行什么，当运行到father6=new Father6();的时候，看到关键字new并且将引用father6指向了Father6对象，说明主动使用了，所以父类Father6将被初始化，因此打印了：父类粑粑静态代码块 ，之后执行 System.out.println(Father6.a);属于访问静态变量所以也是主动使用，这个时候注意了，因为在上面执行father6=new Father6();的时候父类已经主动使用并且初始化过一次了，这次不再是首次主动使用了，所以Father6不会在被初始化，自然它的静态代码块就不再执行了，所以直接打印静态变量值1，而后面的System.out.println(Son6.b);同样，也是只初始化自己，不会去初始化父类，只因为父类Father6以及不再是首次主动使用了！</p><h1 id="6-类加载器"><a href="#6-类加载器" class="headerlink" title="6. 类加载器"></a>6. 类加载器</h1><p>类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载入JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。</p><p>关于唯一标识符：</p><p>在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。</p><p>类加载器的任务是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例，在虚拟机提供了3种类加载器，启动（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器），如下：</p><p><img src="jvm-2-ljz.assets/image-20200530000304780.png" alt="image-20200530000304780"></p><p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p><ul><li>启动类加载器： BootstrapClassLoader，启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，负责加载存放在 JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 BootstrapClassLoader加载）。启动类加载器是无法被Java程序直接引用的。总结一句话：启动类加载器加载java运行过程中的核心类库JRE\lib\rt.jar, sunrsasign.jar, charsets.jar, jce.jar, jsse.jar, plugin.jar 以及存放在JRE\classes里的类，也就是JDK提供的类等常见的比如：Object、Stirng、List…</li></ul><ul><li>扩展类加载器： ExtensionClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader实现，它负责加载 JDK\jre\lib\ext目录中，或者由 java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。</li></ul><ul><li>应用程序类加载器： ApplicationClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。总结一句话：应用程序类加载器加载CLASSPATH变量指定路径下的类 即指你自已在项目工程中编写的类</li></ul><ul><li>线程上下文类加载器：除了以上列举的三种类加载器，其实还有一种比较特殊的类型就是线程上下文类加载器。类似Thread.currentThread().getContextClassLoader()获取线程上下文类加载器，线程上下文加载器其实很重要，它违背（破坏）双亲委派模型，很好地打破了双亲委派模型的局限性，尽管我们在开发中很少用到，但是框架组件开发绝对要频繁使用到线程上下文类加载器，如Tomcat等等…</li></ul><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，因为JVM自带的类加载器（ClassLoader）只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><p>1、在执行非置信代码之前，自动验证数字签名。</p><p>2、动态地创建符合用户特定需要的定制化构建类。</p><p>3、从特定的场所取得java class，例如数据库中和网络中。</p><p>需要注意的是，Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，Java虚拟机默认采用的是双亲委派模式即把请求交由父类处理，它一种任务委派模式，下面将会详细讲到！</p><p>下面我们看一个程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ClassloaderTest &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        &#x2F;&#x2F;获取ClassloaderTest类的加载器  </span><br><span class="line">        ClassLoader classLoader&#x3D; ClassloaderTest.class.getClassLoader();   </span><br><span class="line">       </span><br><span class="line">       System.out.println(classLoader);  </span><br><span class="line">       System.out.println(classLoader.getParent()); &#x2F;&#x2F;获取ClassloaderTest类的父类加载器  </span><br><span class="line">       System.out.println(classLoader.getParent().getParent());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2  </span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1b6d3586  </span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>从上面的结果可以看出，并没有获取到ExtClassLoader的父加载器（Loader），原因是Bootstrap Loader（启动类加载器）是用C++语言实现的（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），找不到一个确定的返回父Loader的方式，于是就返回null。至于$符号就是内部类的含义。</p><h1 id="7-java虚拟机入口应用：sun-misc-Launcher"><a href="#7-java虚拟机入口应用：sun-misc-Launcher" class="headerlink" title="7.java虚拟机入口应用：sun.misc.Launcher"></a>7.java虚拟机入口应用：sun.misc.Launcher</h1><p>到这里，我为什么要讲Launcher呢？如果你没有接触过这个Launcher类可能你会特别陌生，但是它却特别重要！为啥说它重要呢，不知道你有没有想过为啥类加载器首先会去到应用程序类加载器 ApplicationClassLoader，是的！我在介绍应用程序类加载器 ApplicationClassLoader和扩展类加载器 ExtensionClassLoader的时候就已经提到过这两个类加载器是由sun.misc.Launcher实现的！为了更好的理解，我们可以查看Launcher源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1.public class Launcher &#123;  </span><br><span class="line">2.    private static Launcher launcher &#x3D; new Launcher();  </span><br><span class="line">3.    private static String bootClassPath &#x3D;  </span><br><span class="line">4.        System.getProperty(&quot;sun.boot.class.path&quot;);  </span><br><span class="line">5.  </span><br><span class="line">6.    public static Launcher getLauncher() &#123;  </span><br><span class="line">7.        return launcher;  </span><br><span class="line">8.    &#125;  </span><br><span class="line">9.  </span><br><span class="line">10.    private ClassLoader loader;  </span><br><span class="line">11.  </span><br><span class="line">12.    public Launcher() &#123;  </span><br><span class="line">13.        &#x2F;&#x2F; Create the extension class loader  </span><br><span class="line">14.        ClassLoader extcl;  </span><br><span class="line">15.        try &#123;  </span><br><span class="line">16.            extcl &#x3D; ExtClassLoader.getExtClassLoader();  </span><br><span class="line">17.        &#125; catch (IOException e) &#123;  </span><br><span class="line">18.            throw new InternalError(  </span><br><span class="line">19.                &quot;Could not create extension class loader&quot;, e);  </span><br><span class="line">20.        &#125;  </span><br><span class="line">21.  </span><br><span class="line">22.        &#x2F;&#x2F; Now create the class loader to use to launch the application  </span><br><span class="line">23.        try &#123;  </span><br><span class="line">24.            loader &#x3D; AppClassLoader.getAppClassLoader(extcl);  </span><br><span class="line">25.        &#125; catch (IOException e) &#123;  </span><br><span class="line">26.            throw new InternalError(  </span><br><span class="line">27.                &quot;Could not create application class loader&quot;, e);  </span><br><span class="line">28.        &#125;  </span><br><span class="line">29.  </span><br><span class="line">30.        &#x2F;&#x2F;设置AppClassLoader为线程上下文类加载器，这个文章后面部分讲解  </span><br><span class="line">31.        Thread.currentThread().setContextClassLoader(loader);  </span><br><span class="line">32.    &#125;  </span><br><span class="line">33.  </span><br><span class="line">34.    &#x2F;* </span><br><span class="line">35.     * Returns the class loader used to launch the main application. </span><br><span class="line">36.     *&#x2F;  </span><br><span class="line">37.    public ClassLoader getClassLoader() &#123;  </span><br><span class="line">38.        return loader;  </span><br><span class="line">39.    &#125;  </span><br><span class="line">40.    &#x2F;* </span><br><span class="line">41.     * The class loader used for loading installed extensions. </span><br><span class="line">42.     *&#x2F;  </span><br><span class="line">43.    static class ExtClassLoader extends URLClassLoader &#123;&#125;  </span><br><span class="line">44.  </span><br><span class="line">45.&#x2F;** </span><br><span class="line">46.     * The class loader used for loading from java.class.path. </span><br><span class="line">47.     * runs in a restricted security context. </span><br><span class="line">48.     *&#x2F;  </span><br><span class="line">49.    static class AppClassLoader extends URLClassLoader &#123;&#125;</span><br></pre></td></tr></table></figure><p>通过以上源码我们可以得到相关的信息：</p><ol><li>Launcher初始化了ExtClassLoader和AppClassLoader，首先是创建了Extcl扩展类加载器</li><li>之后的App应用类【系统类】加载器作为Launcher中的一个成员变量，至于为啥不把Extcl扩展类加载器也做为成员变量的原因，大家可以仔细想一想，是为啥呢？其实很简单，因为没必要，因为直接把App系统加载器.parent()方法即可得到Extcl扩展类加载器！</li><li>Launcher中并没有看见BootstrapClassLoader，但通过System.getProperty(“sun.boot.class.path”)得到了字符串bootClassPath,这个应该就是BootstrapClassLoader加载的jar包路径。我们可以用输出语句代码测试一下sun.boot.class.path是什么内容，其实就是JRE目录下的jar包或者是class文件。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));</span><br></pre></td></tr></table></figure><p>得到的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.C:\Program Files\Java\jre1.8.0_91\lib\resources.jar;  </span><br><span class="line">2.C:\Program Files\Java\jre1.8.0_91\lib\rt.jar;  </span><br><span class="line">3.C:\Program Files\Java\jre1.8.0_91\lib\sunrsasign.jar;  </span><br><span class="line">4.C:\Program Files\Java\jre1.8.0_91\lib\jsse.jar;  </span><br><span class="line">5.C:\Program Files\Java\jre1.8.0_91\lib\jce.jar;  </span><br><span class="line">6.C:\Program Files\Java\jre1.8.0_91\lib\charsets.jar;  </span><br><span class="line">7.C:\Program Files\Java\jre1.8.0_91\lib\jfr.jar;  </span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\classes</span><br></pre></td></tr></table></figure><h1 id="8-ExtClassLoader、AppClassLoader源码"><a href="#8-ExtClassLoader、AppClassLoader源码" class="headerlink" title="8. ExtClassLoader、AppClassLoader源码"></a>8. ExtClassLoader、AppClassLoader源码</h1><h2 id="8-1ExtClassLoader源码"><a href="#8-1ExtClassLoader源码" class="headerlink" title="8.1ExtClassLoader源码"></a>8.1ExtClassLoader源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;* </span><br><span class="line">2.     * The class loader used for loading installed extensions. </span><br><span class="line">3.     *&#x2F;  </span><br><span class="line">4.    static class ExtClassLoader extends URLClassLoader &#123;  </span><br><span class="line">5.  </span><br><span class="line">6.        static &#123;  </span><br><span class="line">7.            ClassLoader.registerAsParallelCapable();  </span><br><span class="line">8.        &#125;  </span><br><span class="line">9.  </span><br><span class="line">10.        &#x2F;** </span><br><span class="line">11.         * create an ExtClassLoader. The ExtClassLoader is created </span><br><span class="line">12.         * within a context that limits which files it can read </span><br><span class="line">13.         *&#x2F;  </span><br><span class="line">14.        public static ExtClassLoader getExtClassLoader() throws IOException  </span><br><span class="line">15.        &#123;  </span><br><span class="line">16.            final File[] dirs &#x3D; getExtDirs();  </span><br><span class="line">17.  </span><br><span class="line">18.            try &#123;  </span><br><span class="line">19.                &#x2F;&#x2F; Prior implementations of this doPrivileged() block supplied  </span><br><span class="line">20.                &#x2F;&#x2F; aa synthesized ACC via a call to the private method  </span><br><span class="line">21.                &#x2F;&#x2F; ExtClassLoader.getContext().  </span><br><span class="line">22.  </span><br><span class="line">23.                return AccessController.doPrivileged(  </span><br><span class="line">24.                    new PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123;  </span><br><span class="line">25.                        public ExtClassLoader run() throws IOException &#123;  </span><br><span class="line">26.                            int len &#x3D; dirs.length;  </span><br><span class="line">27.                            for (int i &#x3D; 0; i &lt; len; i++) &#123;  </span><br><span class="line">28.                                MetaIndex.registerDirectory(dirs[i]);  </span><br><span class="line">29.                            &#125;  </span><br><span class="line">30.                            return new ExtClassLoader(dirs);  </span><br><span class="line">31.                        &#125;  </span><br><span class="line">32.                    &#125;);  </span><br><span class="line">33.            &#125; catch (java.security.PrivilegedActionException e) &#123;  </span><br><span class="line">34.                throw (IOException) e.getException();  </span><br><span class="line">35.            &#125;  </span><br><span class="line">36.        &#125;  </span><br><span class="line">37.  </span><br><span class="line">38.        private static File[] getExtDirs() &#123;  </span><br><span class="line">39.            String s &#x3D; System.getProperty(&quot;java.ext.dirs&quot;);  </span><br><span class="line">40.            File[] dirs;  </span><br><span class="line">41.            if (s !&#x3D; null) &#123;  </span><br><span class="line">42.                StringTokenizer st &#x3D;  </span><br><span class="line">43.                    new StringTokenizer(s, File.pathSeparator);  </span><br><span class="line">44.                int count &#x3D; st.countTokens();  </span><br><span class="line">45.                dirs &#x3D; new File[count];  </span><br><span class="line">46.                for (int i &#x3D; 0; i &lt; count; i++) &#123;  </span><br><span class="line">47.                    dirs[i] &#x3D; new File(st.nextToken());  </span><br><span class="line">48.                &#125;  </span><br><span class="line">49.            &#125; else &#123;  </span><br><span class="line">50.                dirs &#x3D; new File[0];  </span><br><span class="line">51.            &#125;  </span><br><span class="line">52.            return dirs;  </span><br><span class="line">53.        &#125;  </span><br><span class="line">54.  </span><br><span class="line">55.    &#125;</span><br></pre></td></tr></table></figure><p>当然我们可以指定-D java.ext.dirs参数来添加和改变ExtClassLoader的加载路径</p><h2 id="8-2AppClassLoader源码"><a href="#8-2AppClassLoader源码" class="headerlink" title="8.2AppClassLoader源码"></a>8.2AppClassLoader源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.static class AppClassLoader extends URLClassLoader &#123;  </span><br><span class="line">2.  </span><br><span class="line">3.  </span><br><span class="line">4.     public static ClassLoader getAppClassLoader(final ClassLoader extcl)  </span><br><span class="line">5.         throws IOException  </span><br><span class="line">6.     &#123;  </span><br><span class="line">7.         final String s &#x3D; System.getProperty(&quot;java.class.path&quot;);  </span><br><span class="line">8.         final File[] path &#x3D; (s &#x3D;&#x3D; null) ? new File[0] : getClassPath(s);  </span><br><span class="line">9.  </span><br><span class="line">10.    </span><br><span class="line">11.         return AccessController.doPrivileged(  </span><br><span class="line">12.             new PrivilegedAction&lt;AppClassLoader&gt;() &#123;  </span><br><span class="line">13.                 public AppClassLoader run() &#123;  </span><br><span class="line">14.                 URL[] urls &#x3D;  </span><br><span class="line">15.                     (s &#x3D;&#x3D; null) ? new URL[0] : pathToURLs(path);  </span><br><span class="line">16.                 return new AppClassLoader(urls, extcl);  </span><br><span class="line">17.             &#125;  </span><br><span class="line">18.         &#125;);  </span><br><span class="line">19.     &#125;         </span><br><span class="line">20. &#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看到AppClassLoader加载的就是java.class.path下的路径</p><h2 id="8-3-小结"><a href="#8-3-小结" class="headerlink" title="8.3 小结"></a>8.3 小结</h2><p>从上面源码也可以看出，父加载器并不是指其父类，ExtClassLoader和AppClassLoader同样继承自URLClassLoader，这个时候小白童鞋就不耐烦了：那为啥调用AppClassLoader.getParent()方法会得到ExtClassLoader的实例呢？实际上URLClassLoader的源码中也并没有getParent()方法。这个方法在ClassLoader中，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">1.public abstract class ClassLoader &#123;  </span><br><span class="line">2.  </span><br><span class="line">3.&#x2F;&#x2F; The parent class loader for delegation  </span><br><span class="line">4.&#x2F;&#x2F; Note: VM hardcoded the offset of this field, thus all new fields  </span><br><span class="line">5.&#x2F;&#x2F; must be added *after* it.  </span><br><span class="line">6.private final ClassLoader parent;  </span><br><span class="line">7.&#x2F;&#x2F; The class loader for the system  </span><br><span class="line">8.    &#x2F;&#x2F; @GuardedBy(&quot;ClassLoader.class&quot;)  </span><br><span class="line">9.private static ClassLoader scl;  </span><br><span class="line">10.  </span><br><span class="line">11.private ClassLoader(Void unused, ClassLoader parent) &#123;  </span><br><span class="line">12.    this.parent &#x3D; parent;  </span><br><span class="line">13.    ...  </span><br><span class="line">14.&#125;  </span><br><span class="line">15.protected ClassLoader(ClassLoader parent) &#123;  </span><br><span class="line">16.    this(checkCreateClassLoader(), parent);  </span><br><span class="line">17.&#125;  </span><br><span class="line">18.protected ClassLoader() &#123;  </span><br><span class="line">19.    this(checkCreateClassLoader(), getSystemClassLoader());  </span><br><span class="line">20.&#125;  </span><br><span class="line">21.public final ClassLoader getParent() &#123;  </span><br><span class="line">22.    if (parent &#x3D;&#x3D; null)  </span><br><span class="line">23.        return null;  </span><br><span class="line">24.    return parent;  </span><br><span class="line">25.&#125;  </span><br><span class="line">26.public static ClassLoader getSystemClassLoader() &#123;  </span><br><span class="line">27.    initSystemClassLoader();  </span><br><span class="line">28.    if (scl &#x3D;&#x3D; null) &#123;  </span><br><span class="line">29.        return null;  </span><br><span class="line">30.    &#125;  </span><br><span class="line">31.    return scl;  </span><br><span class="line">32.&#125;  </span><br><span class="line">33.  </span><br><span class="line">34.private static synchronized void initSystemClassLoader() &#123;  </span><br><span class="line">35.    if (!sclSet) &#123;  </span><br><span class="line">36.        if (scl !&#x3D; null)  </span><br><span class="line">37.            throw new IllegalStateException(&quot;recursive invocation&quot;);  </span><br><span class="line">38.        sun.misc.Launcher l &#x3D; sun.misc.Launcher.getLauncher();  </span><br><span class="line">39.        if (l !&#x3D; null) &#123;  </span><br><span class="line">40.            Throwable oops &#x3D; null;  </span><br><span class="line">41.            &#x2F;&#x2F;通过Launcher获取ClassLoader  </span><br><span class="line">42.            scl &#x3D; l.getClassLoader();  </span><br><span class="line">43.            try &#123;  </span><br><span class="line">44.                scl &#x3D; AccessController.doPrivileged(  </span><br><span class="line">45.                    new SystemClassLoaderAction(scl));  </span><br><span class="line">46.            &#125; catch (PrivilegedActionException pae) &#123;  </span><br><span class="line">47.                oops &#x3D; pae.getCause();  </span><br><span class="line">48.                if (oops instanceof InvocationTargetException) &#123;  </span><br><span class="line">49.                    oops &#x3D; oops.getCause();  </span><br><span class="line">50.                &#125;  </span><br><span class="line">51.            &#125;  </span><br><span class="line">52.            if (oops !&#x3D; null) &#123;  </span><br><span class="line">53.                if (oops instanceof Error) &#123;  </span><br><span class="line">54.                    throw (Error) oops;  </span><br><span class="line">55.                &#125; else &#123;  </span><br><span class="line">56.                    &#x2F;&#x2F; wrap the exception  </span><br><span class="line">57.                    throw new Error(oops);  </span><br><span class="line">58.                &#125;  </span><br><span class="line">59.            &#125;  </span><br><span class="line">60.        &#125;  </span><br><span class="line">61.        sclSet &#x3D; true;  </span><br><span class="line">62.    &#125;  </span><br><span class="line">63.&#125;  </span><br><span class="line">64.&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码可以看到getParent()实际上返回的就是一个ClassLoader对象parent，parent的赋值是在ClassLoader对象的构造方法中，它有两个情况：</p><p>1、由外部类创建ClassLoader时直接指定一个ClassLoader为parent。</p><p>2、由getSystemClassLoader()方法生成，也就是在sun.misc.Laucher通过getClassLoader()获取，也就是AppClassLoader。简单的说，就是一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。</p><h1 id="9-关于命名空间"><a href="#9-关于命名空间" class="headerlink" title="9. 关于命名空间"></a>9. 关于命名空间</h1><p>命名空间概念：每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成。</p><p>特别注意：</p><ul><li><p>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。</p></li><li><p>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。</p></li><li><p>由子加载器加载的类能看见父加载器的类，由父亲加载器加载的类不能看见子加载器加载的类</p></li></ul><p>我们已经知道每个类只能被加载一次，其实这样说是不够准确的，怎样才算是准确的呢？那就涉及到命名空间的概念了！只有在相同的命名空间中，每个类才只能被加载一次，反过来说就是一个类在不同的命名空间中是可以被加载多次的，而被加载多次的Class对象是互相独立的！</p><h2 id="9-1-如何理解"><a href="#9-1-如何理解" class="headerlink" title="9.1 如何理解"></a>9.1 如何理解</h2><p>出写例子让各位深刻体会一下！当然这些例子涉及自定义加载器的一些知识，建议先对自定义加载器有一定了解在看！</p><p>例子必知前提：</p><p>1、 自己在idea或者eclipse中创建的工程项目中只要编译之后都会有对应的class文件成在classPath目录中</p><p>2、而这些目录是由ApplicationClassLoader应用加载器加载</p><p>3、 我之后会将class文件放到系统桌面地址上，而这些系统地址由自定义加载器指定，所以由自定义加载器加载</p><h2 id="9-2-准备"><a href="#9-2-准备" class="headerlink" title="9.2 准备"></a>9.2 准备</h2><p>事先编译好，然后将项目工程中的两个字节码class文件【File1和File2】拷贝到系统桌面路径上，编译main方法就会出现在项目工程（ClassPath）下，注意以下例子情况中系统桌面路径的class文件一直都存在！</p><ul><li>Main方法情况：</li></ul><ol><li>创建一个自定义加载器classloader2，并声明桌面class文件路径，接着加载File1</li><li>打印File1的加载器</li><li>newInstance出File1的实例</li></ol><ul><li>File1类的方法情况：</li></ul><ol><li>File1的构造方法中存在一行代码：new File2 的new实例代码</li></ol><ul><li>File2类的方法情况：</li></ul><ol><li>打印File2的加载器</li></ol><h2 id="9-3测试代码情景一"><a href="#9-3测试代码情景一" class="headerlink" title="9.3测试代码情景一"></a>9.3测试代码情景一</h2><ul><li><p>删除File1、File2项目工程中的class文件，工程项目的两个class文件都删除（只存在系统桌面路径下的class文件）</p></li><li><p>结果：File1和File2的加载器都是自定义加载器</p></li></ul><h2 id="9-4-测试代码情景二"><a href="#9-4-测试代码情景二" class="headerlink" title="9.4 测试代码情景二"></a>9.4 测试代码情景二</h2><ul><li><p>只删除File1项目工程中的class文件</p></li><li><p>结果：File1的加载器是自定义加载器，而执行到File2实例的加载器是App应用加载器</p></li></ul><h2 id="9-5-测试代码情景三"><a href="#9-5-测试代码情景三" class="headerlink" title="9.5 测试代码情景三"></a>9.5 测试代码情景三</h2><ul><li><p>只删除File2项目工程中的class文件</p></li><li><p>结果：File1的加载器都是APP应用加载器，而执行到File2实例的时候报NoClassDefFoundError异常</p></li></ul><p><strong><em>\</em>得出结论：**</strong>加载一个类（File1）的时候，这个类里面调用了其他的类（File2）或者其他类方法的初始化代码，那么这里面的类也会试着从这个类的加载器开始向上委托加载，如果全都加载不了加载不了就报NoClassDefFoundError异常。</p><p>当然这样理解命名空间和类加载机制还是远远不够的！</p><h2 id="修改条件：File2类中发生改变情况如下："><a href="#修改条件：File2类中发生改变情况如下：" class="headerlink" title="^^修改条件：File2类中发生改变情况如下："></a>^^修改条件：File2类中发生改变情况如下：</h2><ol><li>File1的构造方法中存在一行new File2的实例这没变</li><li>在File2的构造方法中，打印（访问）File1的class文件</li></ol><h2 id="9-6-测试代码情景四"><a href="#9-6-测试代码情景四" class="headerlink" title="9.6 测试代码情景四"></a>9.6 测试代码情景四</h2><p>只删除项目工程中File1的class文件</p><p>结果：File1的加载器都是自定义加载器，而执行到File2实例的加载器是App应用加载器，当运行到File2构造方法中的打印（访问）File1的class文件的时候报NoClassDefFoundError异常</p><p><strong><em>\</em>得出结论：*****</strong>*父亲加载器加载的类（File2）不能看见子加载器加载的类（*<strong>**</strong>*File1*<strong>**</strong>*）****</p><h2 id="修改条件：File1方法发生改变情况如下："><a href="#修改条件：File1方法发生改变情况如下：" class="headerlink" title="^^修改条件：File1方法发生改变情况如下："></a>^^修改条件：File1方法发生改变情况如下：</h2><p>1、Main方法中newInstance出File1的实例，File1的构造方法中存在一行new File2的实例这都没变<br>2、在File1的构造方法中，打印File2的class文件</p><h2 id="9-7测试代码情景五"><a href="#9-7测试代码情景五" class="headerlink" title="9.7测试代码情景五"></a>9.7测试代码情景五</h2><p>只删除File1项目工程中的class文件</p><p>结果：File1的加载器都是自定义加载器，而执行到File2实例的加载器是App应用加载器，当运行到File1构造方法中的打印File2的class文件的时候没问题</p><p><strong><em>\</em>得出结论：由子加载器加载的类（File1）能看见父加载器的类（File2）**</strong></p><p><strong><em>\</em>当然还要注意知道的一点的是：*****</strong>*如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载类相互不可见。****</p><h1 id="10-JVM类加载机制"><a href="#10-JVM类加载机制" class="headerlink" title="10. JVM类加载机制"></a>10. JVM类加载机制</h1><p>JVM的类加载机制主要有如下3种。</p><ul><li>全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li></ul><ul><li>父类委托：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类，通俗讲就是儿子们都他么是懒猪，自己不管能不能做，就算能加载也先不干，先给自己的父亲做，一个一个往上抛，直到抛到启动类加载器也就是最顶级父类，只有父亲做不了的时候再没办法由下一个子类做，直到能某一个子类能做才做，之后的子类就直接返回，实力坑爹！</li></ul><ul><li>缓存机制：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li></ul><h1 id="11-双亲委派模型"><a href="#11-双亲委派模型" class="headerlink" title="11. 双亲委派模型"></a>11. 双亲委派模型</h1><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。也就是实力坑爹！</p><p>双亲委派机制:</p><ol><li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li><li>当 ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li><li>如果 BootStrapClassLoader加载失败（例如在 $JAVA_HOME/jre/lib里未查找到该class），会使用 ExtClassLoader来尝试加载；</li><li>若ExtClassLoader也加载失败，则会使用 AppClassLoader来加载，如果 AppClassLoader也加载失败，则会报出异常 ClassNotFoundException。</li></ol><p><img src="jvm-2-ljz.assets/image-20200530001844284.png" alt="image-20200530001844284"></p><p>从代码层面了解几个Java中定义的类加载器及其双亲委派模式的实现，它们类图关系如下：</p><p><img src="jvm-2-ljz.assets/image-20200530001857810.png" alt="image-20200530001857810"></p><p>从图可以看出顶层的类加载器是抽象类ClassLoader类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器），为了更好理解双亲委派模型，ClassLoader源码中的loadClass(String)方法该方法加载指定名称（包括包名）的二进制类型，该方法在JDK1.2之后不再建议用户重写但用户可以直接调用该方法，loadClass()方法是ClassLoader类自己实现的，该方法中的逻辑就是双亲委派模式的实现，loadClass(String name, boolean resolve)是一个重载方法，resolve参数代表是否生成class对象的同时进行解析相关操作。源码分析如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1.public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line">2.       return loadClass(name, false);  </span><br><span class="line">3.   &#125;  </span><br><span class="line">4.  </span><br><span class="line">5.rotected Class&lt;?&gt; loadClass(String name, boolean resolve)  </span><br><span class="line">6.     throws ClassNotFoundException  </span><br><span class="line">7. &#123;  </span><br><span class="line">8.     synchronized (getClassLoadingLock(name)) &#123;  </span><br><span class="line">9.         &#x2F;&#x2F; 先从缓存查找该class对象，找到就不用重新加载  </span><br><span class="line">10.         Class&lt;?&gt; c &#x3D; findLoadedClass(name);  </span><br><span class="line">11.         if (c &#x3D;&#x3D; null) &#123;  </span><br><span class="line">12.             long t0 &#x3D; System.nanoTime();  </span><br><span class="line">13.             try &#123;  </span><br><span class="line">14.                 if (parent !&#x3D; null) &#123;  </span><br><span class="line">15.                     &#x2F;&#x2F;如果找不到，则委托给父类加载器去加载  </span><br><span class="line">16.                     c &#x3D; parent.loadClass(name, false);  </span><br><span class="line">17.                 &#125; else &#123;  </span><br><span class="line">18.                 &#x2F;&#x2F;如果没有父类，则委托给启动加载器去加载  </span><br><span class="line">19.                     c &#x3D; findBootstrapClassOrNull(name);  </span><br><span class="line">20.                 &#125;  </span><br><span class="line">21.             &#125; catch (ClassNotFoundException e) &#123;  </span><br><span class="line">22.                 &#x2F;&#x2F; ClassNotFoundException thrown if class not found  </span><br><span class="line">23.                 &#x2F;&#x2F; from the non-null parent class loader  </span><br><span class="line">24.             &#125;  </span><br><span class="line">25.  </span><br><span class="line">26.             if (c &#x3D;&#x3D; null) &#123;  </span><br><span class="line">27.                 &#x2F;&#x2F; If still not found, then invoke findClass in order  </span><br><span class="line">28.                 &#x2F;&#x2F; 如果都没有找到，则通过自定义实现的findClass去查找并加载  </span><br><span class="line">29.                 c &#x3D; findClass(name);  </span><br><span class="line">30.  </span><br><span class="line">31.                 &#x2F;&#x2F; this is the defining class loader; record the stats  </span><br><span class="line">32.                 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);  </span><br><span class="line">33.                 sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);  </span><br><span class="line">34.                 sun.misc.PerfCounter.getFindClasses().increment();  </span><br><span class="line">35.             &#125;  </span><br><span class="line">36.         &#125;  </span><br><span class="line">37.         if (resolve) &#123;&#x2F;&#x2F;是否需要在加载时进行解析  </span><br><span class="line">38.             resolveClass(c);  </span><br><span class="line">39.         &#125;  </span><br><span class="line">40.         return c;  </span><br><span class="line">41.     &#125;  </span><br><span class="line">42. &#125;</span><br></pre></td></tr></table></figure><p>双亲委派模型的意义主要是：Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p><p>双亲委派模型意义总结来讲就是：<br>1、系统类防止内存中出现多份同样的字节码<br>2、保证Java程序安全稳定运行</p><h1 id="12-ClassLoader源码分析"><a href="#12-ClassLoader源码分析" class="headerlink" title="12.ClassLoader源码分析"></a>12.ClassLoader源码分析</h1><p>ClassLoader类是一个抽象类，所有的类加载器都继承自ClassLoader（不包括启动类加载器），因此它显得格外重要，分析ClassLoader抽象类也是非常重要的！</p><p>简单小结一下ClassLoader抽象类中一些概念：</p><p>二进制概念（Binary name）：格式如下</p><p><img src="jvm-2-ljz.assets/image-20200530001954466.png" alt="image-20200530001954466"></p><p>把二进制名字转换成文件名字，然后在文件系统中磁盘上读取其二进制文件（class文件），每一个class对象都包含了定义了这个类的classload对象，class类都是由类加载器加载的只有数组类型是由JVM根据需要动态生成。</p><p>特别注意数组类型：</p><ul><li><p>数组类的类对象不是由类加载器创建的，而是根据Java运行时的需要自动创建的。</p></li><li><p>数组类的类加载器getClassLoader()与它的元素类型的类加载器相同;如果元素类型是基本类型，则数组类没有类加载器也就是null，而这个null不同于根类加载器返回的null，它是单纯的null。</p></li></ul><p>到这里，下面就主要分析ClassLoader抽象类中几个比较重要的方法。</p><h2 id="12-1-loadClass"><a href="#12-1-loadClass" class="headerlink" title="12.1 loadClass"></a>12.1 loadClass</h2><p>该方法加载指定名称（包括包名）的二进制类型，该方法在JDK1.2之后不再建议用户重写但用户可以直接调用该方法，loadClass()方法是ClassLoader类自己实现的，该方法中的逻辑就是双亲委派模式的实现，其源码如下，loadClass(String name, boolean resolve)是一个重载方法，resolve参数代表是否生成class对象的同时进行解析相关操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line">       return loadClass(name, false);  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">rotected Class&lt;?&gt; loadClass(String name, boolean resolve)  </span><br><span class="line">     throws ClassNotFoundException  </span><br><span class="line"> &#123;  </span><br><span class="line">     synchronized (getClassLoadingLock(name)) &#123;  </span><br><span class="line">         &#x2F;&#x2F; 先从缓存查找该class对象，找到就不用重新加载  </span><br><span class="line">         Class&lt;?&gt; c &#x3D; findLoadedClass(name);  </span><br><span class="line">         if (c &#x3D;&#x3D; null) &#123;  </span><br><span class="line">             long t0 &#x3D; System.nanoTime();  </span><br><span class="line">             try &#123;  </span><br><span class="line">                 if (parent !&#x3D; null) &#123;  </span><br><span class="line">                     &#x2F;&#x2F;如果找不到，则委托给父类加载器去加载  </span><br><span class="line">                     c &#x3D; parent.loadClass(name, false);  </span><br><span class="line">                 &#125; else &#123;  </span><br><span class="line">                 &#x2F;&#x2F;如果没有父类，则委托给启动加载器去加载  </span><br><span class="line">                     c &#x3D; findBootstrapClassOrNull(name);  </span><br><span class="line">                 &#125;  </span><br><span class="line">             &#125; catch (ClassNotFoundException e) &#123;  </span><br><span class="line">                 &#x2F;&#x2F; ClassNotFoundException thrown if class not found  </span><br><span class="line">                 &#x2F;&#x2F; from the non-null parent class loader  </span><br><span class="line">             &#125;  </span><br><span class="line">  </span><br><span class="line">             if (c &#x3D;&#x3D; null) &#123;  </span><br><span class="line">                 &#x2F;&#x2F; If still not found, then invoke findClass in order  </span><br><span class="line">                 &#x2F;&#x2F; 如果都没有找到，则通过自定义实现的findClass去查找并加载  </span><br><span class="line">                 c &#x3D; findClass(name);  </span><br><span class="line">  </span><br><span class="line">                 &#x2F;&#x2F; this is the defining class loader; record the stats  </span><br><span class="line">                 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);  </span><br><span class="line">                 sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);  </span><br><span class="line">                 sun.misc.PerfCounter.getFindClasses().increment();  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">         if (resolve) &#123;&#x2F;&#x2F;是否需要在加载时进行解析  </span><br><span class="line">             resolveClass(c);  </span><br><span class="line">         &#125;  </span><br><span class="line">         return c;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>正如loadClass方法所展示的，当类加载请求到来时，先从缓存中查找该类对象，如果存在直接返回，如果不存在则交给该类加载去的父加载器去加载，倘若没有父加载则交给顶级启动类加载器去加载，最后倘若仍没有找到，则使用findClass()方法去加载（关于findClass()稍后会进一步介绍）。从loadClass实现也可以知道如果不想重新定义加载类的规则，也没有复杂的逻辑，只想在运行时加载自己指定的类，那么我们可以直接使用this.getClass().getClassLoder.loadClass(“className”)，这样就可以直接调用ClassLoader的loadClass方法获取到class对象。</p><h2 id="12-2-findClass"><a href="#12-2-findClass" class="headerlink" title="12.2 findClass"></a>12.2 findClass</h2><p>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛出ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的(稍后会分析)，ClassLoader类中findClass()方法源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;&#x2F;直接抛出异常  </span><br><span class="line">2.protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line">3.        throw new ClassNotFoundException(name);  </span><br><span class="line">4.&#125;</span><br></pre></td></tr></table></figure><h2 id="12-3-defineClass-byte-b-int-off-int-len"><a href="#12-3-defineClass-byte-b-int-off-int-len" class="headerlink" title="12.3 defineClass(byte[] b, int off, int len)"></a>12.3 defineClass(byte[] b, int off, int len)</h2><p>defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象(ClassLoader中已实现该方法逻辑)，通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象，defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象，简单例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line">2.      &#x2F;&#x2F; 获取类的字节数组  </span><br><span class="line">3.      byte[] classData &#x3D; getClassData(name);    </span><br><span class="line">4.      if (classData &#x3D;&#x3D; null) &#123;  </span><br><span class="line">5.          throw new ClassNotFoundException();  </span><br><span class="line">6.      &#125; else &#123;  </span><br><span class="line">7.          &#x2F;&#x2F;使用defineClass生成class对象  </span><br><span class="line">8.          return defineClass(name, classData, 0, classData.length);  </span><br><span class="line">9.      &#125;  </span><br><span class="line">10.  &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果直接调用defineClass()方法生成类的Class对象，这个类的Class对象并没有解析(也可以理解为链接阶段，毕竟解析是链接的最后一步)，其解析操作需要等待初始化阶段进行。</p><h2 id="12-4resolveClass-Class-lt-gt-c"><a href="#12-4resolveClass-Class-lt-gt-c" class="headerlink" title="12.4resolveClass (Class&lt;?&gt;c)"></a>12.4resolveClass (Class&lt;?&gt;c)</h2><p>使用该方法可以使用类的Class对象创建完成也同时被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p><h2 id="12-5-ClassLoader小结"><a href="#12-5-ClassLoader小结" class="headerlink" title="12.5 ClassLoader小结"></a>12.5 ClassLoader小结</h2><p>以上上述4个方法是ClassLoader类中的比较重要的方法，也是我们可能会经常用到的方法。接看SercureClassLoader扩展了 ClassLoader，新增了几个与使用相关的代码源(对代码源的位置及其证书的验证)和权限定义类验证(主要指对class源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联，前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如 findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现，并新增了URLClassPath类协助取得Class字节码流等功能，在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p><p>检查完父类加载器之后loadClass会去默认调用findClass方法，父类（ClassLoader）中的findClass方法主要是抛出一个异常。</p><p>findClass根据二进制名字找到对应的class文件，返回值为Class对象Class&lt;?&gt;</p><p>defineClass这个方法主要是将一个字节数组转换成Class实例，会抛三个异常，但只是threws一个，因为其他两个是运行时异常。</p><p>loadClass方法是一个加载一个指定名字的class文件，调用findLoadedClass (String)检查类是否已经加载…如果已经加装就不再加载而是直接返回第一次加载结果 所以一个类只会加载一次</p><h1 id="13-自定义类加载器"><a href="#13-自定义类加载器" class="headerlink" title="13 自定义类加载器"></a>13 自定义类加载器</h1><p>自定义核心目的是扩展java虚拟机的动态加载类的机制，JVM默认情况是使用双亲委托机制，虽然双亲委托机制很安全极高但是有些情况我们需要自己的一种方式加载，比如应用是通过网络来传输 Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。因此自定义类加载器也是很有必要的。</p><p>自定义类加载器一般都是继承自 ClassLoader类，从上面对 loadClass方法来分析来看，我们只需要重写 findClass 方法即可。自定义加载器中点：重写findClass，下面直接看自定义类加载器代码的流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class MyClassLoader extends ClassLoader &#123;  </span><br><span class="line">    private String root;  </span><br><span class="line">  </span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line">        byte[] classData &#x3D; loadClassData(name);  </span><br><span class="line">        if (classData &#x3D;&#x3D; null) &#123;  </span><br><span class="line">            throw new ClassNotFoundException();  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            return defineClass(name, classData, 0, classData.length);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F;自定义解析流方法</span><br><span class="line">    private byte[] loadClassData(String className) &#123;  </span><br><span class="line">        String fileName &#x3D; root + File.separatorChar  </span><br><span class="line">                + className.replace(&#39;.&#39;, File.separatorChar) + &quot;.class&quot;;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            InputStream ins &#x3D; new FileInputStream(fileName);  </span><br><span class="line">            ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();  </span><br><span class="line">            int bufferSize &#x3D; 1024;  </span><br><span class="line">            byte[] buffer &#x3D; new byte[bufferSize];  </span><br><span class="line">            int length &#x3D; 0;  </span><br><span class="line">            while ((length &#x3D; ins.read(buffer)) !&#x3D; -1) &#123;  </span><br><span class="line">                baos.write(buffer, 0, length);  </span><br><span class="line">            &#125;  </span><br><span class="line">            return baos.toByteArray();  </span><br><span class="line">        &#125; catch (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return null;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public String getRoot() &#123;  </span><br><span class="line">        return root;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void setRoot(String root) &#123;  </span><br><span class="line">        this.root &#x3D; root;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args)  &#123;  </span><br><span class="line">  </span><br><span class="line">        MyClassLoader classLoader &#x3D; new MyClassLoader();  </span><br><span class="line">        classLoader.setRoot(&quot;D:\\dirtemp&quot;);  </span><br><span class="line">  </span><br><span class="line">        Class&lt;?&gt; testClass &#x3D; null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">&#x2F;&#x2F;loadClass方法中会调用  重写的findClass方法</span><br><span class="line">            testClass &#x3D; classLoader.loadClass(&quot;com.yichun.classloader.Demo1&quot;);  </span><br><span class="line">            Object object &#x3D; testClass.newInstance();  </span><br><span class="line">            System.out.println(object.getClass().getClassLoader());  </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; catch (InstantiationException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。上面代码程序只是简单Demo，并未对class文件进行加密，因此省略了解密的过程。这里有几点需要注意：</p><ol><li>这里传递的文件名需要是类的全限定性名称，即com.yichun.test.classloading.Test格式的，因为defineClass 方法是按这种格式进行处理的。</li><li>最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</li><li>这类Test 类本身可以被 AppClassLoader类加载，因此我们不能把com/yichun/test/classloading/Test.class放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由AppClassLoader加载，而不会通过我们自定义类加载器来加载。</li></ol><h1 id="14-加载类的三种方式"><a href="#14-加载类的三种方式" class="headerlink" title="14. 加载类的三种方式"></a>14. 加载类的三种方式</h1><p>到这里，相信大家已经对类的加载以及加载器有一定的了解了，那么你知道吗，其实加载类常见的有三种方式，如下：</p><ol><li>静态加载，也就是通过new关键字来创建实例对象。</li><li>动态加载，也就是通过Class.forName()方法动态加载（反射加载类型），然后调用类的newInstance()方法实例化对象。</li><li>动态加载，通过类加载器的loadClass()方法来加载类，然后调用类的newInstance()方法实例化对象</li></ol><h2 id="14-1-三种方式的区别"><a href="#14-1-三种方式的区别" class="headerlink" title="14.1 三种方式的区别"></a>14.1 三种方式的区别</h2><ol><li>第一种和第二种方式使用的类加载器是相同的，都是当前类加载器。（this.getClass.getClassLoader）。而3由用户指定类加载器。</li><li>如果需要在当前类路径以外寻找类，则只能采用第3种方式。第3种方式加载的类与当前类分属不同的命名空间。</li><li>第一种是静态加载，而第二、三种是动态加载。</li></ol><h2 id="14-2-两种异常"><a href="#14-2-两种异常" class="headerlink" title="14.2 两种异常"></a>14.2 两种异常</h2><ol><li>1静态加载的时候如果在运行环境中找不到要初始化的类,抛出的是NoClassDefFoundError,它在JAVA的异常体系中是一个Error</li><li>动态态加载的时候如果在运行环境中找不到要初始化的类,抛出的是ClassNotFoundException,它在JAVA的异常体系中是一个checked异常</li></ol><h2 id="14-3理解Class-forName"><a href="#14-3理解Class-forName" class="headerlink" title="14.3理解Class.forName"></a>14.3理解Class.forName</h2><p>Class.forName()是一种获取Class对象的方法，而且是静态方法。</p><p>Class.forName()是一个静态方法，同样可以用来加载类，Class.forName()返回与给定的字符串名称相关联类或接口的Class对象。注意这是一种获取Class对象的方法</p><p>官方给出的API文档如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">publicstatic Class&lt;?&gt; forName(String className)  </span><br><span class="line">  </span><br><span class="line">Returns the Class object associated withthe class or interface with the given string name. Invokingthis method is equivalent to:  </span><br><span class="line">  </span><br><span class="line">Class.forName(className,true, currentLoader)  </span><br><span class="line">  </span><br><span class="line">where currentLoader denotes the definingclass loader of the current class.  </span><br><span class="line">  </span><br><span class="line">For example, thefollowing code fragment returns the runtime Class descriptor for theclass named java.lang.Thread:  </span><br><span class="line">  </span><br><span class="line">Class t &#x3D;Class.forName(&quot;java.lang.Thread&quot;)  </span><br><span class="line">  </span><br><span class="line">A call to forName(&quot;X&quot;) causes theclass named X to beinitialized.  </span><br><span class="line">  </span><br><span class="line">Parameters:  </span><br><span class="line">  </span><br><span class="line">className - the fully qualifiedname of the desired class.  </span><br><span class="line">  </span><br><span class="line">Returns:  </span><br><span class="line">  </span><br><span class="line">the Class object for the classwith the specified name.</span><br></pre></td></tr></table></figure><p>可以看出，Class.forName(className)实际上是调用Class.forName(className,true, this.getClass().getClassLoader())。第二个参数，是指Class被loading后是不是必须被初始化。可以看出，使用Class.forName（className）加载类时则已初始化。所以Class.forName()方法可以简单的理解为：获得字符串参数中指定的类，并初始化该类。</p><p>这个时候，我们再来看一个程序：‘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.jvm.classloader;  </span><br><span class="line">  </span><br><span class="line">class Demo&#123;  </span><br><span class="line">    static &#123;  </span><br><span class="line">        System.out.println(&quot;static 静态代码块&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public class ClassLoaderDemo &#123;  </span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;  </span><br><span class="line">        ClassLoader classLoader&#x3D;ClassLoaderDemo.class.getClassLoader();  </span><br><span class="line">        &#x2F;&#x2F;1、使用ClassLoader.loadClass()来加载类，不会执行初始化块  </span><br><span class="line">        classLoader.loadClass(&quot;com.jvm.classloader.Demo&quot;);  </span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;2、使用Class.forName()来加载类，默认会执行初始化块  </span><br><span class="line">        Class.forName(&quot;com.jvm.classloader.Demo&quot;);  </span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;3、使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块   </span><br><span class="line">        Class.forName(&quot;com.jvm.classloader.Demo&quot;,false,classLoader);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-总结"><a href="#15-总结" class="headerlink" title="15. 总结"></a>15. 总结</h1><h2 id="15-1-类的加载、连接与初始化"><a href="#15-1-类的加载、连接与初始化" class="headerlink" title="15.1 类的加载、连接与初始化"></a>15.1 类的加载、连接与初始化</h2><p>1、加载：查找并加载类的二进制数据到java虚拟机中<br>2、 连接：</p><ul><li>(1) 验证： 确保被加载的类的正确性</li><li>(2) 准备：为类的静态变量分配内存，并将其初始化为默认值，但是到达初始化之前类变量都没有初始化为真正的初始值（如果是被 final 修饰的类变量，则直接会被初始成用户想要的值。）</li><li>(3) 解析：把类中的符号引用转换为直接引用，就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程</li></ul><p>3、 初始化：为类的静态变量赋予正确的初始值<br>类从磁盘上加载到内存中要经历五个阶段：加载、连接、初始化、使用、卸载</p><h2 id="15-2-Java程序对类的使用方式可分为两种"><a href="#15-2-Java程序对类的使用方式可分为两种" class="headerlink" title="15.2 Java程序对类的使用方式可分为两种"></a>15.2 Java程序对类的使用方式可分为两种</h2><p>主动使用、被动使用</p><p>所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才能初始化他们</p><p><strong><em>\</em>主动使用**</strong></p><p>(1) 创建类的实例</p><p>(2) 访问某个类或接口的静态变量 getstatic（助记符），或者对该静态变量赋值 putstatic</p><p>(3) 调用类的静态方法 invokestatic</p><p>(4) 反射（Class.forName(“com.test.Test”)）</p><p>(5) 初始化一个类的子类</p><p>(6) Java虚拟机启动时被标明启动类的类以及包含Main方法的类</p><p>(7) JDK1.7开始提供的动态语言支持（了解）</p><p><strong><em>\</em>被动使用**</strong><br>除了上面七种情况外，其他使用java类的方式都被看做是对类的被动使用，都不会导致类的初始化</p><h1 id="16-特别注意"><a href="#16-特别注意" class="headerlink" title="16. 特别注意"></a>16. 特别注意</h1><p>初始化入口方法。当进入类加载的初始化阶段后，JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。当需要对一个类进行初始化时，会首先初始化类构造器（），之后初始化对象构造器（）。</p><ul><li><p>初始化类构造器：JVM 会按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器由 JVM 执行。</p></li><li><p>初始化对象构造器：JVM 会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终由 JVM 执行。值得特别注意的是，如果没有监测或者收集到构造函数的代码，则将不会执行对象初始化方法。对象初始化方法一般在实例化类对象的时候执行。</p></li></ul><p>如果在初始化 main 方法所在类的时候遇到了其他类的初始化，那么就先加载对应的类，加载完成之后返回。如此反复循环，最终返回 main 方法所在类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h1&gt;&lt;p&gt;你是否真的理解java的类加载机制？点进文章的盆友不如先来做一道非常常见的面试题，如果你能做出来，可能你早已掌握并理解了
      
    
    </summary>
    
    
    
      <category term="JVM" scheme="https://dcghx.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>IO————1</title>
    <link href="https://dcghx.github.io/2020/05/09/IO-1/"/>
    <id>https://dcghx.github.io/2020/05/09/IO-1/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-30T15:41:34.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-IO流的概念"><a href="#1-IO流的概念" class="headerlink" title="1. IO流的概念"></a>1. IO流的概念</h1><p>流存在的意义：</p><ol><li><p>数据的传输量很大</p></li><li><p>内存有限</p></li><li><p>带宽有限<a id="more"></a></p></li></ol><p>而Stream可以1点1点地逐步传输所有数据, 这就是Stream存在的根本意义。想想我们是怎样下载1个大文件的, 下载软件(例如x雷)并不会占用你内存很大的空间, 而只是在内存划分1个缓冲区, 一点一点地下载到自己的内存(缓冲区满了再写到硬盘), 这也是流的1个例子。</p><p>java的io是实现输入和输出的基础，可以方便的实现数据的输入和输出操作。在java中把不同的输入/输出源（键盘，文件，网络连接等）抽象表述为“流”(stream)。通过流的形式允许java程序使用相同的方式来访问不同的输入/输出源。stram是从起源（source）到接收的（sink）的有序数据。</p><p>Stream是java的1个类, 这个类专门用于程序和外部设备的输入输出(IO). 基本上所有流都在 java.io这个包中.实际上Stream就是数据在程序和外部设备的单向管道, 流的各种方法相当于管道上的各种按钮. 所谓的外部设备可以包括硬盘文件, 网络设备, 另个程序等. 也就是当前程序之外的数据设备</p><p>Java将所有传统的流类型都放在Java.io包下，用于实现输入和输出功能。</p><h1 id="2-Io-流的分类（详解）"><a href="#2-Io-流的分类（详解）" class="headerlink" title="2. Io 流的分类（详解）"></a>2. Io 流的分类（详解）</h1><p>按照流的不同的分类方式，可以把流分为不同的类型，流常见的分类有3种：按照流的流向分、按照操作单元划分、按照流的角色划分</p><p>java的输入流主要是InputStream和Reader作为基类，而输出流则是主要由outputStream和Writer作为基类</p><h2 id="2-1按照流的流向分：输入流和输出流"><a href="#2-1按照流的流向分：输入流和输出流" class="headerlink" title="2.1按照流的流向分：输入流和输出流"></a>2.1按照流的流向分：输入流和输出流</h2><ul><li><p>输入流： 只能从中读取数据，而不能向其写入数据。</p></li><li><p>输出流：只能向其写入数据，而不能向其读取数据。</p></li></ul><p>此处的输入,输出涉及一个方向的问题，也就是说，这里的输入，输出都是以程序运行所在的内存为参照点的。</p><h2 id="2-2按照操作单元划分：字节流和字符流"><a href="#2-2按照操作单元划分：字节流和字符流" class="headerlink" title="2.2按照操作单元划分：字节流和字符流"></a>2.2按照操作单元划分：字节流和字符流</h2><p>字节流主要用于读写二进制文件；字符流主要用于读写文本性文件</p><p>字节流和字符流的用法几乎完成全一样，区别在于字节流和字符流所操作的数据单元不同，字节流操作的单元是数据单元是8位的字节，字符流操作的是数据单元为16位的字符。</p><p>字节流读取单个字节，字符流读取单个字符（一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码是 3 个字节，中文编码是 2 个字节。）字节流用来处理二进制文件（图片、MP3、视频文件），字符流用来处理文本文件（可以看做是特殊的二进制文件，使用了某种编码，人可以阅读）。简而言之，字节是个计算机看的，字符才是给人看的。<br> 字节流主要是由InputStream和outPutStream作为基类，而字符流则主要有Reader和Writer作为基类。</p><p>字节流和字符流的划分可以看下面这张图。</p><p><img src="IO-1.assets/image-20200530233315099.png" alt="image-20200530233315099"></p><h2 id="2-3-按照流的角色：节点流和处理流"><a href="#2-3-按照流的角色：节点流和处理流" class="headerlink" title="2.3 按照流的角色：节点流和处理流"></a>2.3 按照流的角色：节点流和处理流</h2><p><img src="IO-1.assets/image-20200530233427685.png" alt="image-20200530233427685"></p><p>可以从/向一个特定的IO设备（如磁盘，网络）读/写数据的流，称为节点流。节点流也被称为低级流。图15.3显示了节点流的示意图。 当使用节点流进行输入和输出时，程序直接连接到实际的数据源，和实际的输入/输出节点连接。 </p><p>处理流则用于对一个已存在的流进行连接和封装，通过封装后的流来实现数据的读/写功能。处理流也被称为高级流。</p><h3 id="2-3-1节点流"><a href="#2-3-1节点流" class="headerlink" title="2.3.1节点流"></a>2.3.1节点流</h3><p><img src="IO-1.assets/image-20200530233455644.png" alt="image-20200530233455644"></p><ul><li><p>File文件流(对文件进行读/写操作)：FileReader、FileWriter、FileInputStream、FileOutputStream</p></li><li><p>Memory (数组)：从/向内存数组读写数据: CharArrayReader与 CharArrayWriter、ByteArrayInputStream与ByteArrayOutputStream。 </p></li><li><p>Pipe管道流(实现管道的输入和输出(进程间通信)): PipedReader与PipedWriter、PipedInputStream与PipedOutputStream</p></li></ul><p>节点流执行图示：</p><p><img src="IO-1.assets/image-20200530233537958.png" alt="image-20200530233537958"></p><h3 id="2-3-2-处理流"><a href="#2-3-2-处理流" class="headerlink" title="2.3.2  处理流"></a>2.3.2  处理流</h3><p><img src="IO-1.assets/image-20200530233556630.png" alt="image-20200530233556630"></p><ul><li><p>Buffering缓冲流：在读入或写出时，对数据进行缓存，以减少I/O的次数：BufferedReader与BufferedWriter、BufferedInputStream与BufferedOutputStream。 </p></li><li><p>Filtering 滤流：在数据进行读或写时进行过滤：FilterReader与FilterWriter、FilterInputStream与FilterOutputStream。 </p></li><li><p>Converting between Bytes and Characters 转换流：按照一定的编码/解码标准将字节流转换为字符流，或进行反向转换（Stream到Reader）：InputStreamReader、OutputStreamWriter。 </p></li><li><p>Object Serialization对象流 (序列化)：ObjectInputStream、ObjectOutputStream。 </p></li><li><p>DataConversion数据流： 按基本数据类型读、写（处理的数据是Java的基本类型（如布尔型，字节，整数和浮点数））：DataInputStream、DataOutputStream 。 </p></li><li><p>Counting计数流：在读入数据时对行记数 ：LineNumberReader、LineNumberInputStream。 </p></li><li><p>Peeking Ahead预读流,(通过缓存机制进行预读)：PushbackReader、PushbackInputStream。 </p></li><li><p>Printing打印流(包含方便的打印方法)：PrintWriter、PrintStream。</p></li></ul><p>处理流的执行图示</p><p><img src="IO-1.assets/image-20200530233646985.png" alt="image-20200530233646985"></p><h4 id="2-3-2-1-缓冲流"><a href="#2-3-2-1-缓冲流" class="headerlink" title="2.3.2.1 缓冲流"></a>2.3.2.1 缓冲流</h4><p>缓冲流（buffering）是处理流的一种，对I/O进行缓冲是一种常见的性能优化，缓冲流为I/O流增加了内存缓冲区，增加缓冲区的两个目的： </p><ul><li><p>允许Java的I/O一次不只操作一个字符，这样提高整个系统的性能</p></li><li><p>由于有缓冲区，使得在流上执行skip、mark和reset方法都成为可能</p></li></ul><p><strong><em>\</em>JAVA中mark()和reset()用法的通俗理解**</strong></p><p><strong><em>\</em>mark就像书签一样，在这个BufferedReader对应的buffer里作个标记，以后再调用reset时就可以再回到这个mark过的地方。mark方法有个参数，通过这个整型参数，你告诉系统，希望在读出这么多个字符之前，这个mark保持有效。读过这么多字符之后，系统可以使mark不再有效，而你不能觉得奇怪或怪罪它。这跟buffer有关，如果你需要很长的距离，那么系统就必须分配很大的buffer来保持你的mark。**</strong>  </p><p><strong><em>\</em>skip()方法用于跳过前面n个元素，然后再返回新的流**</strong></p><p>缓冲流：它是要“套接”在相应的节点流之上，对读写的数据提供了缓冲的功能，<br>提高了读写的效率，同时增加了一些新的方法。例如：BufferedReader中的readLine方法，<br>BufferedWriter中的newLine方法。</p><p>j2sdk提供了4种缓冲流，重用的构造方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;&#x2F;字符输入流  </span><br><span class="line">2.BufferedReader(Reader in)&#x2F;&#x2F;创建一个32字节的缓冲区  </span><br><span class="line">3.BufferedReader(Reader in, int size)&#x2F;&#x2F;size为自定义缓存区的大小  </span><br><span class="line">4.   </span><br><span class="line">5.&#x2F;&#x2F;字符输出流  </span><br><span class="line">6.BufferedWriter(Writer out)  </span><br><span class="line">7.BufferedWriter(Writer out, int size)  </span><br><span class="line">8.   </span><br><span class="line">9.&#x2F;&#x2F;字节输入流  </span><br><span class="line">10.BufferedInputStream(InputStream in)  </span><br><span class="line">11.BufferedInputStream(InputStream in, int size)  </span><br><span class="line">12.   </span><br><span class="line">13.&#x2F;&#x2F;字节输出流  </span><br><span class="line">14.BufferedOutputStream(OutputStream in)  </span><br><span class="line">15.BufferedOutputStream(OutputStream in, int size)</span><br></pre></td></tr></table></figure><p>备注：</p><ul><li><p>缓冲输入流BufferedInputSTream除了支持read和skip方法意外，还支持其父类的mark和reset方法; </p></li><li><p>BufferedReader提供了一种新的ReadLine方法用于读取一行字符串（以\r或\n分隔）; </p></li><li><p>BufferedWriter提供了一种新的newLine方法用于写入一个行分隔符; </p></li><li><p>对于输出的缓冲流，BufferedWriter和BufferedOutputStream，写出的数据会先在内存中缓存， </p></li></ul><p>使用flush方法将会使内存的数据立刻写出。</p><h1 id="3-Io-流的分类（图示）"><a href="#3-Io-流的分类（图示）" class="headerlink" title="3.Io 流的分类（图示）"></a>3.Io 流的分类（图示）</h1><p>java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java Io流的40多个类都是从如下4个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><img src="IO-1.assets/image-20200530233908792.png" alt="image-20200530233908792" style="zoom:200%;" /><p>java输入/输出流体系中常用的流的分类表</p><p><img src="IO-1.assets/image-20200530234106977.png" alt="image-20200530234106977"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-IO流的概念&quot;&gt;&lt;a href=&quot;#1-IO流的概念&quot; class=&quot;headerlink&quot; title=&quot;1. IO流的概念&quot;&gt;&lt;/a&gt;1. IO流的概念&lt;/h1&gt;&lt;p&gt;流存在的意义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;数据的传输量很大&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存有限&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;带宽有限
    
    </summary>
    
    
    
      <category term="IO" scheme="https://dcghx.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>spring-1</title>
    <link href="https://dcghx.github.io/2020/05/09/spring-1/"/>
    <id>https://dcghx.github.io/2020/05/09/spring-1/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-30T16:18:32.281Z</updated>
    
    <content type="html"><![CDATA[<p>简单认识一下spring<a id="more"></a></p><h1 id="1-Spring-Framework-模块"><a href="#1-Spring-Framework-模块" class="headerlink" title="1.Spring Framework 模块"></a>1.Spring Framework 模块</h1><p><img src="spring-1.assets/image-20200530234642332.png" alt="image-20200530234642332"></p><h2 id="1-1-spring核心容器"><a href="#1-1-spring核心容器" class="headerlink" title="1.1 spring核心容器"></a>1.1 spring核心容器</h2><p>该层基本上是 Spring Framework 的核心。它包含以下模块：</p><ul><li>Spring Core</li><li>Spring Bean</li><li>SpEl (Spring Expression language)</li><li>Spring Context</li></ul><h2 id="1-2数据访问-集成"><a href="#1-2数据访问-集成" class="headerlink" title="1.2数据访问/集成"></a>1.2数据访问/集成</h2><p>该层提供与数据库交互的支持。它包含以下模块：</p><ul><li><p>JDBC (Java DataBase Connectivity)</p></li><li><p>ORM (Object Re<em>ationa</em> Mapping)</p></li><li><p>OXM (Object XMl Mappers)</p></li><li><p>JMS (Java Messaging Service)</p></li><li><p>Transaction</p></li></ul><h2 id="1-3-web"><a href="#1-3-web" class="headerlink" title="1.3 web"></a>1.3 web</h2><p>该层提供了创建 Web 应用程序的支持。它包含以下模块：</p><ul><li><p>Web</p></li><li><p>Web – Servlet</p></li><li><p>Web – Socket</p></li><li><p>Web – Portlet</p></li></ul><h2 id="1-4AOP"><a href="#1-4AOP" class="headerlink" title="1.4AOP"></a>1.4AOP</h2><p>该层支持面向切面编程</p><h2 id="1-5Instrumentation"><a href="#1-5Instrumentation" class="headerlink" title="1.5Instrumentation"></a>1.5Instrumentation</h2><p>该层为类检测和类加载器实现提供支持。</p><h2 id="1-6Test"><a href="#1-6Test" class="headerlink" title="1.6Test"></a>1.6Test</h2><p>该层为使用 JUnit 和 TestNG 进行测试提供支持。</p><h2 id="1-7-Messaging"><a href="#1-7-Messaging" class="headerlink" title="1.7 Messaging"></a>1.7 Messaging</h2><p>该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</p><h2 id="1-8-Aspect"><a href="#1-8-Aspect" class="headerlink" title="1.8 Aspect"></a>1.8 Aspect</h2><p>该模块为与 AspectJ 的集成提供支持。</p><h1 id="2-IOC"><a href="#2-IOC" class="headerlink" title="2. IOC"></a>2. IOC</h1><p>Spring拥有两大特性：IoC和AOP。</p><p>Spring核心容器的主要组件是Bean工厂（BeanFactory），Bean工厂使用控制反转（IoC）模式来降低程序代码之间的耦合度，并提供了面向切面编程（AOP）的实现。</p><h2 id="2-1什么是IOC-DI"><a href="#2-1什么是IOC-DI" class="headerlink" title="2.1什么是IOC/DI"></a>2.1什么是IOC/DI</h2><ul><li><p>IOC(Inversion of Control)控制反转：所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们可配置的文件。</p></li><li><p>DI(Dependency Injection)依赖注入：就是指对象是被动接受依赖类而不是自己主动去找，换句话说就是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。Spring依赖注入的方式主要有四个，基于注解注入方式、set注入方式、构造器注入方式、静态工厂注入方式。推荐使用基于注解注入方式，配置较少，比较方便。</p></li></ul><ul><li>IoC容器：具有依赖注入功能的容器，可以创建对象的容器。IoC容器负责实例化、定位、配置应用程序中的对象并建立这些对象之间的依赖。IoC的主要实现方式有两种：依赖查找、依赖注入。依赖注入是一种更可取的方式,以来查找已经配抛弃</li></ul><p>那么依赖查找和依赖注入有什么区别呢？</p><ul><li><p>依赖查找，主要是容器为组件提供一个回调接口和上下文环境。这样一来，组件就必须自己使用容器提供的API来查找资源和协作对象，控制反转仅体现在那些回调方法上，容器调用这些回调方法，从而应用代码获取到资源。</p></li><li><p>依赖注入，组件不做定位查询，只提供标准的Java方法让容器去决定依赖关系。容器全权负责组件的装配，把符合依赖关系的对象通过Java Bean属性或构造方法传递给需要的对象。</p></li></ul><h2 id="2-2-spring-IOC"><a href="#2-2-spring-IOC" class="headerlink" title="2.2 spring IOC"></a>2.2 spring IOC</h2><p>控制反转，简单点说，就是创建对象的控制权，由原本自己代码new被反转到了Spring框架上</p><p>Spring 的 IoC 设计支持以下功能：·</p><ul><li><p>依赖注入·</p></li><li><p>依赖检查·</p></li><li><p>自动装配</p></li><li><p>支持集合</p></li><li><p>指定初始化方法和销毁方法</p></li><li><p>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）</p></li></ul><p>其中，最重要的就是依赖注入，从 XML 的配置上说， 即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p><p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</p><p>那么， Spring 如何设计容器的呢？</p><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器：BeanFactory、ApplicationContext</p><p>l BeanFactory 粗暴简单，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p><p>l ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口的一个实现类ConfigurableApplicationContext定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p><p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，我这里通过常用的 ClassPathXmlApplicationContext 类（我们常用的还有ClassPathweblApplicationContext ），来展示整个容器的层级 UML 关系。</p><p><img src="spring-1.assets/image-20200530235332029.png" alt="image-20200530235332029"></p><p>最上面的 BeanFactory 知道吧？我就不讲了。</p><p>下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p><p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p><p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p><p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置。生命周期事件回调等。</p><p>好，解释了低级容器和高级容器，我们可以看看一个 IoC 启动过程是什么样子的。说白了，就是 ClassPathXmlApplicationContext 这个类，在启动时，都做了啥。（由于我这是 interface21 的代码，肯定和你的 Spring 4.x 系列不同）。</p><p>下图是 ClassPathXmlApplicationContext 的构造过程，实际就是 Spring IoC 的初始化过程。</p><p><img src="spring-1.assets/image-20200530235345604.png" alt="image-20200530235345604"></p><p>这里再用文字来描述这个过程：</p><ol><li>用户构造 ClassPathXmlApplicationContext（简称 CPAC）</li><li>CPAC 首先访问了 “抽象高级容器” 的 final 的 refresh 方法，这个方法是模板方法。所以要回调子类（低级容器）的 refreshBeanFactory 方法，这个方法的作用是使用低级容器加载所有 BeanDefinition 和 Properties 到容器中。</li><li>低级容器加载成功后，高级容器开始处理一些回调，例如 Bean 后置处理器。回调 setBeanFactory 方法。或者注册监听器等，发布事件，实例化单例 Bean 等等功能，这些功能，随着 Spring 的不断升级，功能越来越多，很多人在这里迷失了方向 ：）。</li></ol><p>简单说就是：</p><ol><li>低级容器 加载配置文件（从 XML，数据库，Applet），并解析成 BeanDefinition 到低级容器中。</li><li>加载成功后，高级容器启动高级功能，例如接口回调，监听器，自动实例化单例，发布事件等等功能。</li></ol><p>所以，一定要把 “低级容器” 和“高级容器” 的区别弄清楚。不能一叶障目不见泰山。</p><p>好，当我们创建好容器，就会使用 getBean 方法，获取 Bean，而 getBean 的流程如下：</p><p><img src="spring-1.assets/image-20200530235428020.png" alt="image-20200530235428020"></p><p>从图中可以看出，getBean 的操作都是在低级容器里操作的。其中有个递归操作，这个是什么意思呢？</p><p>假设 ： 当 Bean_A 依赖着 Bean_B，而这个 Bean_A 在加载的时候，其配置的 ref = “Bean_B” 在解析的时候只是一个占位符，被放入了 Bean_A 的属性集合中，当调用 getBean 时，需要真正 Bean_B 注入到 Bean_A 内部时，就需要从容器中获取这个 Bean_B，因此产生了递归。</p><p>为什么不是在加载的时候，就直接注入呢？因为加载的顺序不同，很可能 Bean_A 依赖的 Bean_B 还没有加载好，也就无法从容器中获取，你不能要求用户把 Bean 的加载顺序排列好，这是不人道的。</p><p>所以，Spring 将getBean分为了 2 个步骤：</p><ol><li>加载所有的 Bean 配置成 BeanDefinition 到容器中，如果 Bean 有依赖关系，则使用占位符暂时代替。</li><li>然后，在调用 getBean 的时候，进行真正的依赖注入，即如果碰到了属性是 ref 的（占位符），那么就从容器里获取这个 Bean，然后注入到实例中 —— 称之为依赖注入。</li></ol><p>可以看到，依赖注入实际上，只需要 “低级容器” 就可以实现。</p><p>这就是 IoC。</p><p>所以 ApplicationContext refresh 方法里面的操作不只是 IoC，是高级容器的所有功能（包括 IoC），IoC 的功能在低级容器里就可以实现。</p><h2 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h2><p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p><p>1) 加载配置文件，解析成 BeanDefinition 放在 Map 里。</p><p>2) 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</p><p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p><p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p><h1 id="3-面向切面编程AOP"><a href="#3-面向切面编程AOP" class="headerlink" title="3. 面向切面编程AOP"></a>3. 面向切面编程AOP</h1><p>AOP的定义：面向切面编程，核心原理是使用动态代理模式在方法执行前后或出现异常时加入相关逻辑。</p><ol><li>AOP是基于动态代理模式。</li><li>AOP是方法级别的（要测试的方法不能为static修饰，因为接口中不能存在静态方法，编译就会报错）。</li><li>AOP可以分离业务代码和关注点代码（重复代码），在执行业务代码时，动态的注入关注点代码。切面就是关注点代码形成的类</li></ol><p>我们知道java是一个面向对象(OOP)的语言，但它有一些弊端,比如当我们需要为多个不具有继承关系的对象引入一个公共行为，只能在在每个对象里引用公共行为，这样做不便于维护，而且有大量重复代码。AOP的出现弥补了OOP的这点不足。</p><p>面向切面编程（AOP）就是纵向的编程。比如业务A和业务B现在需要一个相同的操作，传统方法我们可能需要在A、B中都加入相关操作代码，而应用AOP就可以只写一遍代码，A、B共用这段代码。并且，当A、B需要增加新的操作时，可以在不改动原代码的情况下，灵活添加新的业务逻辑实现。</p><p>在实际开发中，比如商品查询、促销查询等业务，都需要记录日志、异常处理等操作，AOP把所有共用代码都剥离出来，单独放置到某个类中进行集中管理，在具体运行时，由容器进行动态织入这些公共代码。</p><p>AOP主要一般应用于签名验签、参数校验、日志记录、事务控制、权限控制、性能统计、异常处理等。</p><h2 id="3-1-AOP名词"><a href="#3-1-AOP名词" class="headerlink" title="3.1 AOP名词"></a>3.1 AOP名词</h2><ul><li><p>切面（Aspect）：共有功能的实现。如日志切面、权限切面、验签切面等。在实际开发中通常是一个存放共有功能实现的标准Java类。当Java类使用了@Aspect注解修饰时，就能被AOP容器识别为切面。</p></li><li><p>通知（Advice）：切面的具体实现。就是要给目标对象织入的事情。以目标方法为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际开发中通常是切面类中的一个方法，具体属于哪类通知，通过方法上的注解区分。</p></li><li><p>连接点（JoinPoint）：程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出等。Spring只支持方法级的连接点。一个类的所有方法前、后、抛出异常时等都是连接点。</p></li></ul><ul><li>切入点（Pointcut）：用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。</li></ul><p>比如，在上面所说的连接点的基础上，来定义切入点。我们有一个类，类里有10个方法，那就产生了几十个连接点。但是我们并不想在所有方法上都织入通知，我们只想让其中的几个方法，在调用之前检验下入参是否合法，那么就用切点来定义这几个方法，让切点来筛选连接点，选中我们想要的方法。切入点就是来定义哪些类里面的哪些方法会得到通知。</p><ul><li><p>目标对象（Target）：那些即将切入切面的对象，也就是那些被通知的对象。这些对象专注业务本身的逻辑，所有的共有功能等待AOP容器的切入。</p></li><li><p>代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象本身业务逻辑加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。目标对象被织入共有功能后产生的对象。</p></li><li><p>织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译时、类加载时、运行时。Spring是在运行时完成织入，运行时织入通过Java语言的反射机制与动态代理机制来动态实现。</p></li></ul><h2 id="3-2-pointcut用法"><a href="#3-2-pointcut用法" class="headerlink" title="3.2 pointcut用法"></a>3.2 pointcut用法</h2><p><img src="spring-1.assets/image-20200530235925884.png" alt="image-20200530235925884"></p><ul><li><p>修饰符匹配 modifier-pattern? 例：public private</p></li><li><p>返回值匹配 ret-type-pattern 可以用 * 表示任意返回值</p></li><li><p>类路径匹配 declaring-type-pattern? 全路径的类名</p></li><li><p>方法名匹配 name-pattern 可以指定方法名或者用 * 表示所有方法；set* 表示所有以set开头的方法</p></li><li><p>参数匹配 (param-pattern) 可以指定具体的参数类型，多个参数用“,”分隔；可以用 * 表示匹配任意类型的参数；可以用 (..) 表示零个或多个任意参数</p></li><li><p>异常类型匹配throws-pattern? 例：throws Exception</p></li></ul><p>其中后面跟着 ? 表示可选项</p><p><img src="spring-1.assets/image-20200530235955265.png" alt="image-20200530235955265"></p><h2 id="3-3-一个例子"><a href="#3-3-一个例子" class="headerlink" title="3.3 一个例子"></a>3.3 一个例子</h2><p>以 <a href="https://blog.csdn.net/dkbnull/article/details/82847647" target="_blank" rel="noopener">Spring Boot入门：使用AOP实现拦截器</a> 中的AOP为例</p><p><img src="spring-1.assets/image-20200531000026341.png" alt="image-20200531000026341"></p><p>SignAop类使用了@Aspect注解，则该类可以被AOP容器识别为切面</p><img src="spring-1.assets/image-20200531000038057.png" alt="image-20200531000038057" style="zoom:150%;" /><p>@Pointcut声明一个切入点，范围为controller包下所有的类的所有方法。注：作为切入点签名的方法必须返回void类型</p><img src="spring-1.assets/image-20200531000104386.png" alt="image-20200531000104386" style="zoom:150%;" /><p>doBefore()方法使用@Before(“signAop()”)注解，表示前置通知（在某连接点之前执行的通知），但这个通知不能阻止连接点之前的执行流程，除非它抛出一个异常。</p><p>doAfterReturning()方法使用@AfterReturning(value = “signAop()”, returning = “params”)注解，表示后置通知（在某连接点正常完成后执行的通知），通常在一个匹配的方法返回的时候执行。</p><p>实际运行时，在进入controller包下所有方法前，都会进入doBefore()方法，在controller包下方法执行完成后，都会进入doAfterReturning()方法。</p><h2 id="3-4-动态代理-静待代理"><a href="#3-4-动态代理-静待代理" class="headerlink" title="3.4 动态代理/静待代理"></a>3.4 动态代理/静待代理</h2><p>AOP有两种实现方式：静态代理、动态代理</p><p>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</p><ul><li><p>编译时编织（特殊编译器实现）</p></li><li><p>类加载时编织（特殊的类加载器实现）。</p></li></ul><p>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</p><ul><li><p>JDK 动态代理</p></li><li><p>CGLIB</p></li></ul><h3 id="3-4-1-静态代理"><a href="#3-4-1-静态代理" class="headerlink" title="3.4.1 静态代理"></a>3.4.1 静态代理</h3><p>静态代理模式：静态代理说白了就是在程序运行前就已经存在代理类的字节码文件，代理类和原始类的关系在运行前就已经确定。</p><p><img src="spring-1.assets/image-20200531000307922.png" alt="image-20200531000307922"></p><p>测试结果</p><img src="spring-1.assets/image-20200531000332393.png" alt="image-20200531000332393" style="zoom:150%;" /><p>静态代理虽然保证了业务类只需关注逻辑本身，代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理。再者，如果增加一个方法，除了实现类需要实现这个方法外，所有的代理类也要实现此方法。增加了代码的维护成本。那么要如何解决呢?答案是使用动态代理。</p><h3 id="3-4-2-动态代理"><a href="#3-4-2-动态代理" class="headerlink" title="3.4.2 动态代理"></a>3.4.2 动态代理</h3><p>动态代理模式：动态代理类的源码是在程序运行期间通过JVM反射等机制动态生成，代理类和委托类的关系是运行时才确定的。实例如下:</p><h4 id="3-4-2-1-JDK动态代理"><a href="#3-4-2-1-JDK动态代理" class="headerlink" title="3.4.2.1 JDK动态代理"></a>3.4.2.1 JDK动态代理</h4><p><img src="spring-1.assets/image-20200531000437033.png" alt="image-20200531000437033"></p><p>测试结果如下：</p><p><img src="spring-1.assets/image-20200531000450599.png" alt="image-20200531000450599"></p><p>在运行测试类中创建测试类对象代码中</p><p><img src="spring-1.assets/wps1.jpg" alt="img"> </p><p>其实是jdk动态生成了一个类去实现接口,隐藏了这个过程:</p><p><img src="spring-1.assets/wps2.jpg" alt="img"> </p><p>使用jdk生成的动态代理的前提是目标类必须有实现的接口。</p><h4 id="3-4-2-2-CGLB动态代理"><a href="#3-4-2-2-CGLB动态代理" class="headerlink" title="3.4.2.2 CGLB动态代理"></a>3.4.2.2 CGLB动态代理</h4><p>使用jdk生成的动态代理的前提是目标类必须有实现的接口。但这里又引入一个问题,如果某个类没有实现接口,就不能使用jdk动态代理,所以Cglib代理就是解决这个问题的。</p><p>Cglib是以动态生成的子类继承目标的方式实现，在运行期动态的在内存中构建一个子类，如下:</p><p><img src="spring-1.assets/image-20200531000540009.png" alt="image-20200531000540009"></p><p>Cglib使用的前提是目标类不能为final修饰。因为final修饰的类不能被继承。</p><p>首先，导入 CGLIB 的 Maven 依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">  &lt;groupId&gt;cglib&lt;&#x2F;groupId&gt;  </span><br><span class="line">  &lt;artifactId&gt;cglib&lt;&#x2F;artifactId&gt;  </span><br><span class="line">  &lt;version&gt;3.2.11&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;  </span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>Spring AOP 的 org.springframework.cglib 包中包含了 CGLIB 的相关代码(和 CGLIB Maven 依赖中代码的一样，版本可能不同)，所以也可以选择导入 Spring AOP 的 Maven 依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;  </span><br><span class="line">  &lt;artifactId&gt;spring-aop&lt;&#x2F;artifactId&gt;  </span><br><span class="line">  &lt;version&gt;5.1.6.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;  </span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>然后，定义一个 Service 类，其有两个方法并且其中一个方法用 final 来修饰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.public class Service &#123;  </span><br><span class="line">2.    &#x2F;** </span><br><span class="line">3.     *  final 方法不能被子类覆盖 </span><br><span class="line">4.     *&#x2F;  </span><br><span class="line">5.    public final void finalMethod() &#123;  </span><br><span class="line">6.        System.out.println(&quot;Service.finalMethod 执行了&quot;);  </span><br><span class="line">7.    &#125;  </span><br><span class="line">8.  </span><br><span class="line">9.    public void publicMethod() &#123;  </span><br><span class="line">10.        System.out.println(&quot;Service.publicMethod 执行了&quot;);  </span><br><span class="line">11.    &#125;  </span><br><span class="line">12.&#125;</span><br></pre></td></tr></table></figure><p>接下来，定义一个 MethodInterceptor 的实现类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class CglibDynamicProxy implements MethodInterceptor &#123;  </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;目标对象（也被称为被代理对象）  </span><br><span class="line">    private Object target;  </span><br><span class="line">  </span><br><span class="line">    public CglibDynamicProxy(Object target) &#123;  </span><br><span class="line">        this.target &#x3D; target;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;** </span><br><span class="line">     * @param obj       CGLIB 生成的代理对象 </span><br><span class="line">     * @param method    被代理对象方法 </span><br><span class="line">     * @param args      方法入参 </span><br><span class="line">     * @param proxy     方法代理 </span><br><span class="line">     * @return </span><br><span class="line">     * @throws Throwable </span><br><span class="line">     *&#x2F;  </span><br><span class="line">    @Override  </span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;  </span><br><span class="line">        System.out.println(&quot;CglibDynamicProxy intercept 方法执行前--&quot;);  </span><br><span class="line">  </span><br><span class="line">        System.out.println(&quot;obj &#x3D; &quot; + obj.getClass());  </span><br><span class="line">        System.out.println(&quot;method &#x3D; &quot; + method);  </span><br><span class="line">        System.out.println(&quot;proxy &#x3D; &quot; + proxy);  </span><br><span class="line">  </span><br><span class="line">        Object object &#x3D; proxy.invoke(target, args);  </span><br><span class="line">        System.out.println(&quot;CglibDynamicProxy intercept 方法执行后--&quot;);  </span><br><span class="line">        return object;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    &#x2F;** </span><br><span class="line">     * 获取被代理接口实例对象 </span><br><span class="line">     * 通过 enhancer.create 可以获得一个代理对象，它继承了 target.getClass() 类 </span><br><span class="line">     * @param &lt;T&gt; </span><br><span class="line">     * @return </span><br><span class="line">     *&#x2F;  </span><br><span class="line">    public &lt;T&gt; T getProxy() &#123;  </span><br><span class="line">        Enhancer enhancer &#x3D; new Enhancer();  </span><br><span class="line">        enhancer.setSuperclass(target.getClass());  </span><br><span class="line">        enhancer.setCallback(this);  </span><br><span class="line">        return (T) enhancer.create();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        &#x2F;&#x2F; 1. 构造目标对象  </span><br><span class="line">        Service target &#x3D; new Service();  </span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 2. 根据目标对象生成代理对象  </span><br><span class="line">        CglibDynamicProxy proxy &#x3D; new CglibDynamicProxy(target);  </span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 获取 CGLIB 代理类  </span><br><span class="line">        Service proxyObject &#x3D; proxy.getProxy();  </span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 调用代理对象的方法  </span><br><span class="line">        proxyObject.finalMethod();  </span><br><span class="line">        proxyObject.publicMethod();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下所示：</p><p><img src="spring-1.assets/image-20200531000715166.png" alt="image-20200531000715166"></p><p>原理</p><p><a href="https://www.jianshu.com/p/7700a48811e0" target="_blank" rel="noopener">https://www.jianshu.com/p/7700a48811e0</a></p><h1 id="4-spring原理概述"><a href="#4-spring原理概述" class="headerlink" title="4. spring原理概述"></a>4. spring原理概述</h1><p><img src="spring-1.assets/image-20200531000823596.png" alt="image-20200531000823596"></p><ol><li>用户发送请求至前端控制器DispatcherServlet(也叫中央处理器).</li><li>DispatcherServlet调用HandlerMappering处理器映射器，处理器映射器找到具体的处理器（可以根据xml配置、注解进行查找），生成处理器对象及处理器拦截器（如果有则生成）一并返回给DispatcherServlet.</li><li>DispatcherServlet调用HandlerAdapter处理器适配器。</li><li>HandlerAdapter经过适配调用具体的处理器（Controller,也叫后端控制器）。</li><li>Controller执行完成返回ModelAndView.</li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet.</li><li>DisPatcherServlet将ModelAndView传给ViewReslover视图解析器。</li><li>ViewReslover解析后返回具体View.</li><li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet响应用户。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单认识一下spring
    
    </summary>
    
    
    
      <category term="spring" scheme="https://dcghx.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>多线程—-—ThreadLocal</title>
    <link href="https://dcghx.github.io/2020/05/09/dxc-threadlocal/"/>
    <id>https://dcghx.github.io/2020/05/09/dxc-threadlocal/</id>
    <published>2020-05-09T03:15:26.000Z</published>
    <updated>2020-05-27T14:19:12.636Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p><p>用ThreadLocal声明的变量可以在线程内部提供变量副本，线程修改ThreadLocal声明的变量互不影响，这就不存在并发的情况了。<a id="more"></a></p><h1 id="1-ThreadLocal的基本使用"><a href="#1-ThreadLocal的基本使用" class="headerlink" title="1.ThreadLocal的基本使用"></a>1.ThreadLocal的基本使用</h1><p><img src="dxc-threadlocal.assets/image-20200509163209050.png" alt="image-20200509163209050"></p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public  class  ThreadLocalDemo  &#123;     </span><br><span class="line">  &#x2F;&#x2F; 初始化ThreadLocal的值————第一种方法：实现抽象方法  </span><br><span class="line">  &#x2F;&#x2F;   private static ThreadLocal threadLocal &#x3D; ThreadLocal.withInitial(new Supplier&lt;String&gt;() &#123;</span><br><span class="line">  &#x2F;&#x2F;        @Override  </span><br><span class="line">  &#x2F;&#x2F;        public String get() &#123;  </span><br><span class="line">  &#x2F;&#x2F;            return &quot;Initial value&quot;;  </span><br><span class="line">  &#x2F;&#x2F;        &#125;  </span><br><span class="line">  &#x2F;&#x2F;    &#125;);  </span><br><span class="line">    </span><br><span class="line">  &#x2F;&#x2F; 初始化ThreadLocal的值————第二种方法：使用Lambda表达式  </span><br><span class="line">  private  static  ThreadLocal  threadLocal  &#x3D; ThreadLocal.withInitial(() - &gt; &#123;</span><br><span class="line">    return  &quot;Initial value&quot;;</span><br><span class="line">  &#125;);       &#x2F;&#x2F; 初始化ThreadLocal的值————第三种方式重写initialValue()方法  </span><br><span class="line">  &#x2F;&#x2F;    private static ThreadLocal threadLocal &#x3D; new ThreadLocal()&#123;  </span><br><span class="line">  &#x2F;&#x2F;        @Override  </span><br><span class="line">  &#x2F;&#x2F;        protected Object initialValue() &#123;  </span><br><span class="line">  &#x2F;&#x2F;            return &quot;Initial value&quot;;  </span><br><span class="line">  &#x2F;&#x2F;        &#125;  </span><br><span class="line">  &#x2F;&#x2F;    &#125;;  </span><br><span class="line">        </span><br><span class="line">  public  static  void  main(String[]  args)  &#123;          </span><br><span class="line">    System.out.println(&quot;ThreadLocal的初始值：&quot;  +  threadLocal.get());          </span><br><span class="line">    threadLocal.set(&quot;Main方法&quot;);          </span><br><span class="line">    new  Thread(()  - &gt;  &#123;              </span><br><span class="line">      System.out.println(&quot;子线程获取ThreadLocal的值：&quot;  +  threadLocal.get());              </span><br><span class="line">      threadLocal.set(&quot;Thread线程&quot;);       </span><br><span class="line">      System.out.println(&quot;子线程执行set方法后，子线程获取ThreadLocal的值：&quot;  +  threadLocal.get());              </span><br><span class="line">      threadLocal.remove();    </span><br><span class="line">      System.out.println(&quot;子线程执行remove方法后，子线程获取ThreadLocal的值：&quot;  +  threadLocal.get());          </span><br><span class="line">    &#125;).start();     </span><br><span class="line">    System.out.println(&quot;主线程执行set方法后，主线程获取ThreadLocal的值：&quot;  +  threadLocal.get());          </span><br><span class="line">    threadLocal.remove();    </span><br><span class="line">    System.out.println(&quot;主线程执行remove方法后，主线程获取ThreadLocal的值：&quot;  +  threadLocal.get());      </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.ThreadLocal的初始值：Initial value  </span><br><span class="line">2.主线程执行set方法后，主线程获取ThreadLocal的值：Main方法  </span><br><span class="line">3.主线程执行remove方法后，主线程获取ThreadLocal的值：Initial value  </span><br><span class="line">4.子线程获取ThreadLocal的值：Initial value  </span><br><span class="line">5.子线程执行set方法后，子线程获取ThreadLocal的值：Thread线程  </span><br><span class="line">6.子线程执行remove方法后，子线程获取ThreadLocal的值：Initial value</span><br></pre></td></tr></table></figure><h1 id="2-ThreadLocal源码剖析"><a href="#2-ThreadLocal源码剖析" class="headerlink" title="2.ThreadLocal源码剖析"></a>2.ThreadLocal源码剖析</h1><p>先看下ThreadLocal类的类图：</p><p><img src="dxc-threadlocal.assets/image-20200509171236546.png" alt="image-20200509171236546"></p><p>可以看出ThreadLocal有两个静态内部类，分别是SuppliedThreadLocal和ThreadLocalMap。实际上，ThreadLocal 类的核心就是 ThreadLocalMap 这个内部类。当创建线程的时候，线程对象都会有 ThreadLocalMap 类型的成员变量。</p><p>*ThreadLocalMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line">2.static class ThreadLocalMap &#123;  </span><br><span class="line">3.  </span><br><span class="line">4.    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;  </span><br><span class="line">5.        Object value;  </span><br><span class="line">6.        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;  </span><br><span class="line">7.            super(k);  </span><br><span class="line">8.            value &#x3D; v;  </span><br><span class="line">9.        &#125;  </span><br><span class="line">10.    &#125;  </span><br><span class="line">11.  </span><br><span class="line">12.    &#x2F;&#x2F; Entry数组的初始容量  </span><br><span class="line">13.    private static final int INITIAL_CAPACITY &#x3D; 16;  </span><br><span class="line">14.  </span><br><span class="line">15.    &#x2F;&#x2F; ThreadLocalMap对象实际上由Entry数组记录ThreadLocal变量  </span><br><span class="line">16.    private Entry[] table;  </span><br><span class="line">17.  </span><br><span class="line">18.    &#x2F;&#x2F; Entry数组元素的个数  </span><br><span class="line">19.    private int size &#x3D; 0;  </span><br><span class="line">20.  </span><br><span class="line">21.    &#x2F;&#x2F; Entry扩容的阀值  </span><br><span class="line">22.    private int threshold;  </span><br><span class="line">23.  </span><br><span class="line">24.    &#x2F;&#x2F; 设置Entry数组的阀值，长度为 len 的 2&#x2F;3 倍  </span><br><span class="line">25.    private void setThreshold(int len) &#123;  </span><br><span class="line">26.        threshold &#x3D; len * 2 &#x2F; 3;  </span><br><span class="line">27.    &#125;  </span><br><span class="line">28.  </span><br><span class="line">29.    &#x2F;&#x2F; Entry数组的下一个索引  </span><br><span class="line">30.    private static int nextIndex(int i, int len) &#123;  </span><br><span class="line">31.        return ((i + 1 &lt; len) ? i + 1 : 0);  </span><br><span class="line">32.    &#125;  </span><br><span class="line">33.  </span><br><span class="line">34.    &#x2F;&#x2F; Entry数组的上一个索引  </span><br><span class="line">35.    private static int prevIndex(int i, int len) &#123;  </span><br><span class="line">36.        return ((i - 1 &gt;&#x3D; 0) ? i - 1 : len - 1);  </span><br><span class="line">37.    &#125;  </span><br><span class="line">38.  </span><br><span class="line">39.    &#x2F;&#x2F; 初始化ThreadLocalMap对象  </span><br><span class="line">40.    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;  </span><br><span class="line">41.        table &#x3D; new Entry[INITIAL_CAPACITY];  </span><br><span class="line">42.        int i &#x3D; firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);  </span><br><span class="line">43.        table[i] &#x3D; new Entry(firstKey, firstValue);&#x2F;&#x2F; 初始化Entry  </span><br><span class="line">44.        size &#x3D; 1;  </span><br><span class="line">45.        setThreshold(INITIAL_CAPACITY);  </span><br><span class="line">46.    &#125;  </span><br><span class="line">47.  </span><br><span class="line">48.    &#x2F;&#x2F; ThreadLocal.set()主要核心方法  </span><br><span class="line">49.    private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;  </span><br><span class="line">50.        Entry[] tab &#x3D; table;  </span><br><span class="line">51.        int len &#x3D; tab.length;  </span><br><span class="line">52.        int i &#x3D; key.threadLocalHashCode &amp; (len - 1);&#x2F;&#x2F; ThreadLocal对象经过哈希算法确定元素索引 i  </span><br><span class="line">53.  </span><br><span class="line">54.        &#x2F;&#x2F; 如果数组索引对应的Entry对象不是null，则进入for循环  </span><br><span class="line">55.        for (Entry e &#x3D; tab[i];  </span><br><span class="line">56.             e !&#x3D; null;  </span><br><span class="line">57.             e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;  </span><br><span class="line">58.            ThreadLocal&lt;?&gt; k &#x3D; e.get();  </span><br><span class="line">59.  </span><br><span class="line">60.            if (k &#x3D;&#x3D; key) &#123;  </span><br><span class="line">61.                e.value &#x3D; value;  </span><br><span class="line">62.                return;  </span><br><span class="line">63.            &#125;  </span><br><span class="line">64.  </span><br><span class="line">65.            &#x2F;&#x2F; 如果key为null则说明该entry已经失效，执行replaceStaleEntry替换掉  </span><br><span class="line">66.            if (k &#x3D;&#x3D; null) &#123;  </span><br><span class="line">67.                replaceStaleEntry(key, value, i);  </span><br><span class="line">68.                return;  </span><br><span class="line">69.            &#125;  </span><br><span class="line">70.        &#125;  </span><br><span class="line">71.        &#x2F;&#x2F; 向数组新增Entry对象元素  </span><br><span class="line">72.        tab[i] &#x3D; new Entry(key, value);  </span><br><span class="line">73.        int sz &#x3D; ++size;  </span><br><span class="line">74.        if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;&#x3D; threshold)&#x2F;&#x2F; 清除一些过期的值并且判断是否需要扩容  </span><br><span class="line">75.            rehash();  </span><br><span class="line">76.    &#125;  </span><br><span class="line">77.  </span><br><span class="line">78.&#x2F;&#x2F; 将新元素放进陈旧的元素  </span><br><span class="line">79.    private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,  </span><br><span class="line">80.                                   int staleSlot) &#123;  </span><br><span class="line">81.        Entry[] tab &#x3D; table;  </span><br><span class="line">82.        int len &#x3D; tab.length;  </span><br><span class="line">83.        Entry e;  </span><br><span class="line">84.  </span><br><span class="line">85.        int slotToExpunge &#x3D; staleSlot;  </span><br><span class="line">86.        &#x2F;&#x2F; 向前查找被弃用的索引  </span><br><span class="line">87.        for (int i &#x3D; prevIndex(staleSlot, len);  </span><br><span class="line">88.             (e &#x3D; tab[i]) !&#x3D; null;  </span><br><span class="line">89.             i &#x3D; prevIndex(i, len))  </span><br><span class="line">90.            if (e.get() &#x3D;&#x3D; null)  </span><br><span class="line">91.                slotToExpunge &#x3D; i;  </span><br><span class="line">92.  </span><br><span class="line">93.        &#x2F;&#x2F; 向后查找key或者value为null的元素  </span><br><span class="line">94.        for (int i &#x3D; nextIndex(staleSlot, len);  </span><br><span class="line">95.             (e &#x3D; tab[i]) !&#x3D; null;  </span><br><span class="line">96.             i &#x3D; nextIndex(i, len)) &#123;  </span><br><span class="line">97.            ThreadLocal&lt;?&gt; k &#x3D; e.get();  </span><br><span class="line">98.  </span><br><span class="line">99.            if (k &#x3D;&#x3D; key) &#123;  </span><br><span class="line">100.                e.value &#x3D; value;  </span><br><span class="line">101.  </span><br><span class="line">102.                tab[i] &#x3D; tab[staleSlot];  </span><br><span class="line">103.                tab[staleSlot] &#x3D; e;  </span><br><span class="line">104.  </span><br><span class="line">105.                &#x2F;&#x2F; 如果存在则清除被弃用的Entry对象  </span><br><span class="line">106.                if (slotToExpunge &#x3D;&#x3D; staleSlot)  </span><br><span class="line">107.                    slotToExpunge &#x3D; i;  </span><br><span class="line">108.                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);  </span><br><span class="line">109.                return;  </span><br><span class="line">110.            &#125;  </span><br><span class="line">111.  </span><br><span class="line">112.            if (k &#x3D;&#x3D; null &amp;&amp; slotToExpunge &#x3D;&#x3D; staleSlot)  </span><br><span class="line">113.                slotToExpunge &#x3D; i;  </span><br><span class="line">114.        &#125;  </span><br><span class="line">115.  </span><br><span class="line">116.        tab[staleSlot].value &#x3D; null;  </span><br><span class="line">117.        tab[staleSlot] &#x3D; new Entry(key, value);  </span><br><span class="line">118.  </span><br><span class="line">119.        &#x2F;&#x2F; 如果还有其它被弃用的Entry对象，执行cleanSomeSlots方法清除他们  </span><br><span class="line">120.        if (slotToExpunge !&#x3D; staleSlot)  </span><br><span class="line">121.            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);  </span><br><span class="line">122.    &#125;  </span><br><span class="line">123.  </span><br><span class="line">124.    &#x2F;&#x2F; 清除被弃用的元素  </span><br><span class="line">125.    private boolean cleanSomeSlots(int i, int n) &#123;  </span><br><span class="line">126.        boolean removed &#x3D; false;  </span><br><span class="line">127.        Entry[] tab &#x3D; table;  </span><br><span class="line">128.        int len &#x3D; tab.length;  </span><br><span class="line">129.        do &#123;  </span><br><span class="line">130.            i &#x3D; nextIndex(i, len);  </span><br><span class="line">131.            Entry e &#x3D; tab[i];  </span><br><span class="line">132.            if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; null) &#123;  </span><br><span class="line">133.                n &#x3D; len;  </span><br><span class="line">134.                removed &#x3D; true;  </span><br><span class="line">135.                i &#x3D; expungeStaleEntry(i);  </span><br><span class="line">136.            &#125;  </span><br><span class="line">137.        &#125; while ( (n &gt;&gt;&gt;&#x3D; 1) !&#x3D; 0);  </span><br><span class="line">138.        return removed;  </span><br><span class="line">139.    &#125;  </span><br><span class="line">140.  </span><br><span class="line">141.    &#x2F;&#x2F; 清除目标对象，并向后扫描清除被弃用的元素  </span><br><span class="line">142.    private int expungeStaleEntry(int staleSlot) &#123;  </span><br><span class="line">143.        Entry[] tab &#x3D; table;  </span><br><span class="line">144.        int len &#x3D; tab.length;  </span><br><span class="line">145.  </span><br><span class="line">146.        tab[staleSlot].value &#x3D; null;  </span><br><span class="line">147.        tab[staleSlot] &#x3D; null;  </span><br><span class="line">148.        size--;  </span><br><span class="line">149.  </span><br><span class="line">150.        Entry e;  </span><br><span class="line">151.        int i;  </span><br><span class="line">152.        for (i &#x3D; nextIndex(staleSlot, len);  </span><br><span class="line">153.             (e &#x3D; tab[i]) !&#x3D; null;  </span><br><span class="line">154.             i &#x3D; nextIndex(i, len)) &#123;  </span><br><span class="line">155.            ThreadLocal&lt;?&gt; k &#x3D; e.get();  </span><br><span class="line">156.            if (k &#x3D;&#x3D; null) &#123;  </span><br><span class="line">157.                e.value &#x3D; null;  </span><br><span class="line">158.                tab[i] &#x3D; null;  </span><br><span class="line">159.                size--;  </span><br><span class="line">160.            &#125; else &#123;  </span><br><span class="line">161.                int h &#x3D; k.threadLocalHashCode &amp; (len - 1);  </span><br><span class="line">162.                if (h !&#x3D; i) &#123;  </span><br><span class="line">163.                    tab[i] &#x3D; null;  </span><br><span class="line">164.  </span><br><span class="line">165.                    while (tab[h] !&#x3D; null)  </span><br><span class="line">166.                        h &#x3D; nextIndex(h, len);  </span><br><span class="line">167.                    tab[h] &#x3D; e;  </span><br><span class="line">168.                &#125;  </span><br><span class="line">169.            &#125;  </span><br><span class="line">170.        &#125;  </span><br><span class="line">171.        return i;  </span><br><span class="line">172.    &#125;  </span><br><span class="line">173.  </span><br><span class="line">174.    &#x2F;&#x2F; 清除弃用元素并判断是否需要扩容  </span><br><span class="line">175.    private void rehash() &#123;  </span><br><span class="line">176.        expungeStaleEntries();  </span><br><span class="line">177.        if (size &gt;&#x3D; threshold - threshold &#x2F; 4)  </span><br><span class="line">178.            resize();  </span><br><span class="line">179.    &#125;  </span><br><span class="line">180.  </span><br><span class="line">181.    &#x2F;&#x2F; 扩容  </span><br><span class="line">182.    private void resize() &#123;  </span><br><span class="line">183.        Entry[] oldTab &#x3D; table;  </span><br><span class="line">184.        int oldLen &#x3D; oldTab.length;  </span><br><span class="line">185.        int newLen &#x3D; oldLen * 2;  </span><br><span class="line">186.        Entry[] newTab &#x3D; new Entry[newLen];  </span><br><span class="line">187.        int count &#x3D; 0;  </span><br><span class="line">188.  </span><br><span class="line">189.        for (int j &#x3D; 0; j &lt; oldLen; ++j) &#123;  </span><br><span class="line">190.            Entry e &#x3D; oldTab[j];  </span><br><span class="line">191.            if (e !&#x3D; null) &#123;  </span><br><span class="line">192.                ThreadLocal&lt;?&gt; k &#x3D; e.get();  </span><br><span class="line">193.                if (k &#x3D;&#x3D; null) &#123;  </span><br><span class="line">194.                    e.value &#x3D; null; &#x2F;&#x2F; Help the GC  </span><br><span class="line">195.                &#125; else &#123;  </span><br><span class="line">196.                    int h &#x3D; k.threadLocalHashCode &amp; (newLen - 1);  </span><br><span class="line">197.                    while (newTab[h] !&#x3D; null)  </span><br><span class="line">198.                        h &#x3D; nextIndex(h, newLen);  </span><br><span class="line">199.                    newTab[h] &#x3D; e;  </span><br><span class="line">200.                    count++;  </span><br><span class="line">201.                &#125;  </span><br><span class="line">202.            &#125;  </span><br><span class="line">203.        &#125;  </span><br><span class="line">204.  </span><br><span class="line">205.        setThreshold(newLen);  </span><br><span class="line">206.        size &#x3D; count;  </span><br><span class="line">207.        table &#x3D; newTab;  </span><br><span class="line">208.    &#125;  </span><br><span class="line">209.  </span><br><span class="line">210.    &#x2F;&#x2F; 清空被弃用的元素  </span><br><span class="line">211.    private void expungeStaleEntries() &#123;  </span><br><span class="line">212.        Entry[] tab &#x3D; table;  </span><br><span class="line">213.        int len &#x3D; tab.length;  </span><br><span class="line">214.        for (int j &#x3D; 0; j &lt; len; j++) &#123;  </span><br><span class="line">215.            Entry e &#x3D; tab[j];  </span><br><span class="line">216.            if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; null)  </span><br><span class="line">217.                expungeStaleEntry(j);  </span><br><span class="line">218.        &#125;  </span><br><span class="line">219.    &#125;  </span><br><span class="line">220.&#125;</span><br></pre></td></tr></table></figure><p>可以看到ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。</p><p>至此，可能大部分朋友已经明白了ThreadLocal是如何为每个线程创建变量的副本的：</p><p>首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。</p><p>实际上，ThreadLocalMap是一个数组，而数组内的元素都是由key和value组成的Entry对象。ThreadLocalMap的key就是经过哈希算法计算出来的ThreadLocal对象。神奇的是，ThreadLocal的哈希算法可以保证只要在ThreadLocalMap数组长度为2的 N 次方的时候，哈希值能平均的分布,避免键冲突。</p><h1 id="3-看一下set方法"><a href="#3-看一下set方法" class="headerlink" title="3.看一下set方法"></a>3.看一下set方法</h1><p><img src="dxc-threadlocal.assets/image-20200509171657703.png" alt="image-20200509171657703"></p><p>1) 获取当前线程对象</p><p>2) 以当前线程对象为参数获取，当前Thread对象中的ThreadLocalMap对象</p><p>3) 判断当前Thread对象中的ThreadLocalMap对象是否为null</p><p><em>*为null：为当前线程对象的ThreadLocalMaps成员变量初始化，并赋值</em></p><p><img src="dxc-threadlocal.assets/image-20200509171752156.png" alt="image-20200509171752156"></p><p>构造方法中会将val生成Entry对象存入Entry数组（索引为ThreadLocal对象内存地址哈希计算所得）</p><p><em>*不为null：调用ThreadLocalMap的set方法进行赋值</em></p><p><img src="dxc-threadlocal.assets/image-20200509171833410.png" alt="image-20200509171833410"></p><p>在ThreadLocalMap的set方法中，将传递来的参数ThreadLocal对象的地址值进行哈希计算出索引值，创建Val的Entry对象，将值插入所计算得出Entry数组的索引位置</p><h1 id="4-看一下get方法"><a href="#4-看一下get方法" class="headerlink" title="4.看一下get方法"></a>4.看一下get方法</h1><p><img src="dxc-threadlocal.assets/image-20200509171930269.png" alt="image-20200509171930269"></p><p>1) 获取当前线程对象</p><p>2) 以当前线程对象为参数获取，当前Thread对象中的ThreadLocalMap对象</p><p>3) 判断当前Thread对象中的ThreadLocalMap对象是否为null</p><p><em>*为null：进入初始化方法：创建ThrealocalMap，赋初始值</em></p><p><img src="dxc-threadlocal.assets/image-20200509172040768.png" alt="image-20200509172040768"></p><p><em>*不为null：调用ThrealocalMap的getEntry方法获取Entry对象，参数ThreadLocal对象</em></p><p><img src="dxc-threadlocal.assets/image-20200509172110335.png" alt="image-20200509172110335"></p><p>根据ThreadLocal对象的内存地址哈希计算得出指定ThreadLocal对象的值在Entry数据的存储索引，获取Entry对象进而获取值</p><h1 id="领悟："><a href="#领悟：" class="headerlink" title="领悟："></a>领悟：</h1><p>我们可以看出一个Thread对象的ThreadLocalMap成员变量是属于该线程对象的，所以ThreadLocalMap对象中的Entry数组也是属于该线程的，Entry数组索引由ThreadLocal对象内存哈希计算得出，元素为值封装的Entry对象，ThreadLocal对象的init***、get、set方法调用是加载ThreadLocal对象到Entry数组的时机，所以ThreadLocal对象用static修饰完全没有问题，因为每个线程对象的ThreadLocalMap对象是不同的，同时也只是取ThreadLocal对象的内存地址计算作为数组的索引</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。&lt;/p&gt;
&lt;p&gt;用ThreadLocal声明的变量可以在线程内部提供变量副本，线程修改ThreadLocal声明的变量互不影响，这就不存在并发的情况了。
    
    </summary>
    
    
    
      <category term="多线程" scheme="https://dcghx.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程(1)</title>
    <link href="https://dcghx.github.io/2020/05/09/dxc-msg/"/>
    <id>https://dcghx.github.io/2020/05/09/dxc-msg/</id>
    <published>2020-05-09T03:15:26.000Z</published>
    <updated>2020-05-27T16:16:58.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-线程"><a href="#1-线程" class="headerlink" title="1.线程"></a>1.线程</h1><p>线程:程序执行流的最小单元【可以理解为：进程中独立运行的子任务】。<br>多线程优点:最大限度的利用CPU的空闲时间来处理其他任务。<a id="more"></a></p><h2 id="1-1线程创建方式"><a href="#1-1线程创建方式" class="headerlink" title="1.1线程创建方式"></a>1.1线程创建方式</h2><p>继承Thread类</p><p><img src="dxc-msg.assets/image-20200528001244377.png" alt="image-20200528001244377"></p><p>实现Runable接口</p><p><img src="dxc-msg.assets/image-20200528001259400.png" alt="image-20200528001259400"></p><h2 id="1-2线程停止thread-interrupt-、thread-stop"><a href="#1-2线程停止thread-interrupt-、thread-stop" class="headerlink" title="1.2线程停止thread.interrupt()、thread.stop()"></a>1.2线程停止thread.interrupt()、thread.stop()</h2><p>在Thread类中,提供了stop(),suspend()和resume()方法,这三个方法分别是用来结束,暂停,恢复线程. 但是都已经被标记为@Deprecated废弃了. 因为一个线程不应该由其他线程来结束,他应该收到别人的通知,然后自己在合适的位置结束,如果不合理的结束,会导致很多意外的结果,比如临界区还没完全操作完,提前释放锁,但是部分状态已经改变,还有没有做一些清理操作等等.</p><p>基于上面的理由,Java提供了新的中断机制(interrupt),其他线程调用想要终止线程的interrupt()方法. 这个时候线程会根据自己的状态做出响应:</p><ul><li><p>如果线程处于阻塞状态(sleep,wait,join),则线程会抛出InterruptedException异常.</p></li><li><p>如果线程处于正常运行状态,则还是正常运行,但是中断的标志被设置为true,相当于有人通知 你该结束自己了.</p></li></ul><p>被调用线程处于阻塞状态时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">    Thread thread &#x3D; new Thread() &#123;  </span><br><span class="line">        @Override  </span><br><span class="line">        public void run() &#123;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                &#x2F;&#x2F; 被调线程阻塞自己30s  </span><br><span class="line">                sleep(30000);  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        &#x2F;&#x2F; 启动线程  </span><br><span class="line">        thread.start();  </span><br><span class="line">        &#x2F;&#x2F; 主线程阻塞自己3秒  </span><br><span class="line">        TimeUnit.SECONDS.sleep(3);  </span><br><span class="line">        &#x2F;&#x2F; 中断线程  </span><br><span class="line">        thread.interrupt();  </span><br><span class="line">    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F; ↓ out ↓  </span><br><span class="line">&#x2F;&#x2F; java.lang.InterruptedException: sleep interrupted  </span><br><span class="line">&#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure><p>被调用线程处于正常运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">    Thread thread &#x3D; new Thread() &#123;  </span><br><span class="line">        @Override  </span><br><span class="line">        public void run() &#123;  </span><br><span class="line">            while (!Thread.interrupted()) &#123;  </span><br><span class="line">                System.out.println(&quot;我还稳得住...&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        thread.start();  </span><br><span class="line">        TimeUnit.SECONDS.sleep(3);  </span><br><span class="line">        thread.interrupt();  </span><br><span class="line">    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; ↓ out ↓  </span><br><span class="line">&#x2F;&#x2F; 我能稳得住  </span><br><span class="line">&#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure><p>该程序会在检测interrupt标志,如果发现interrupt标志设置为true,则会结束自己.</p><p><code>interrupted()和isInterrupt()的区别</code></p><p>区别: 是否会清除interrupt标志. isInterrupt()方法不会改变标志,而interrupted()方法会在检测的同时,如果发现标志为true,则会返回true,然后把标志置为false.</p><h2 id="1-3-线程优先级"><a href="#1-3-线程优先级" class="headerlink" title="1.3 线程优先级"></a>1.3 线程优先级</h2><p>线程优先级范围为1-10，API提供等级分为：低（MIN_PRIORITY = 1)，中（NORM_PRIORITY=5），高（MAX_PRIORITY=10）。<br>线程优先级有以下特点：</p><ul><li><p>继承特性【线程A中启动线程B，线程B继承了A的优先级】；</p></li><li><p>随机性【线程调度的顺序不一定是根据优先级，具有随机性】；</p></li></ul><h2 id="1-4-守护线程"><a href="#1-4-守护线程" class="headerlink" title="1.4 守护线程"></a>1.4 守护线程</h2><p>Java 中有两种线程： 一种是用户线程（User Thread），一种是守护线程（Daemon Thread）。</p><p>守护线程是一种特殊的线程， 它的特殊有“陪伴”的含义， 当线程中不存在非守护线程时， 则守护线程自动销毁。</p><p><img src="dxc-msg.assets/image-20200528001322500.png" alt="image-20200528001322500"></p><p><img src="dxc-msg.assets/image-20200528001338666.png" alt="image-20200528001338666"></p><p>从上图可以看出，主线程停止DaemonThread线程也相应的停止了，但不是立即停止。</p><h2 id="1-5-线程让步yield"><a href="#1-5-线程让步yield" class="headerlink" title="1.5 线程让步yield()"></a>1.5 线程让步yield()</h2><p>线程让步【yield方法】让当前线程释放CPU资源，让其他线程抢占。</p><p><img src="dxc-msg.assets/image-20200528001353721.png" alt="image-20200528001353721"></p><p><img src="dxc-msg.assets/image-20200528001405158.png" alt="image-20200528001405158"></p><p>从以上两图可以看出，线程的让步操作比不让步耗时长。</p><h2 id="1-5线程状态、以及-sheep（）、wait-、yield-的区别"><a href="#1-5线程状态、以及-sheep（）、wait-、yield-的区别" class="headerlink" title="1.5线程状态、以及 sheep（）、wait()、yield() 的区别"></a>1.5线程状态、以及 sheep（）、wait()、yield() 的区别</h2><p><img src="dxc-msg.assets/image-20200528001421752.png" alt="image-20200528001421752"></p><p><img src="dxc-msg.assets/image-20200528001433396.png" alt="image-20200528001433396"></p><p>线程包括五种状态</p><ol><li><p>新建、初始状态（New） ：线程对象被创建后就进入了新建状态，Thread thread = new Thread();</p></li><li><p>就绪（Runnable）：也被称之为“可执行状态”，当线程被new出来后，其他的线程调用了该对象的start()方法，即thread.start()，此时线程位于“可运行线程池”中，只等待获取CPU的使用权，随时可以被CPU调用。进入就绪状态的线程除CPU之外，其他运行所需的资源都已经全部获得。</p></li><li><p>运行（Running）：线程获取CPU权限开始执行。注意：线程只能从就绪状态进入到运行状态。</p></li><li><p>阻塞（Bloacked）：阻塞状态是线程因为某种原因放弃CPU的使用权，暂时停止运行，直到线程进入就绪状态后才能有机会转到运行状态。阻塞的情况分三种：</p></li></ol><ul><li><p>a.  等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池中”。进入这个状态后是不能自动唤醒的，必须依靠其他线程调用notify()或者notifyAll()方法才能被唤醒。</p></li><li><p>b. 同步阻塞：运行的线程在获取对象的（synchronized）同步锁时，若该同步锁被其他线程占用，则JVM会吧该线程放入“锁池”中。</p></li><li><p>c. 其他阻塞：通过调用线程的sleep()或者join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新回到就绪状态</p></li></ul><ol start="5"><li>死亡（Dead）：线程执行完了或因异常退出了run()方法，则该线程结束生命周期。</li></ol><p><em>wait(), notify(), notifyAll()等方法介绍</em></p><p>这三个方法都是定义到Object类中，wait的作用是当当前线程释放它所持有的锁进入等待状态，而notify和notifyAll则是唤醒当前对象上的等待线程。</p><ul><li>notify() —— 唤醒在此对象监视器上等待的单个线程。</li><li>notifyAll() —— 唤醒在此对象监视器上等待的所有线程。</li><li>wait() —— 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。</li><li>wait(long timeout) —— 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。</li><li>wait(long timeout, int nanos) —— 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。</li><li>wait()会使“当前线程”等待，并且会释放到它所占用的“锁标志”，从而使线程所在对象中的其他synchronized数据可以被其他线程使用。</li></ul><p>waite()和notify()因为会对对象的“锁标志”进行操作，所以它们必须在synchronized函数或synchronizedblock中进行调用。如果在non-synchronized函数或non-synchronizedblock中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。</p><p>负责唤醒等待线程的那个线程(我们称为“唤醒线程”)，它只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p><h2 id="1-6-suspend-和-resume-方法"><a href="#1-6-suspend-和-resume-方法" class="headerlink" title="1.6 suspend()和 resume()方法"></a>1.6 suspend()和 resume()方法</h2><p>两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume()被调用，才能使得线程重新进入可执行状态。典型地，suspend()和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume()使其恢复。</p><p>注意区别：</p><p>初看起来wait() 和 notify() 方法与suspend()和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的suspend()及其它所有方法在线程阻塞时都不会释放占用的锁（如果占用了的话），而wait() 和 notify() 这一对方法则相反。</p><h2 id="1-7-sleep-和-yield-方法"><a href="#1-7-sleep-和-yield-方法" class="headerlink" title="1.7 sleep() 和 yield()方法"></a>1.7 sleep() 和 yield()方法</h2><p>这两个方法都定义在Thread.java中</p><p>sleep()的作用是让当前线程休眠（正在执行的线程主动让出cpu，然后cpu就可以去执行其他任务），即当前线程会从“运行状态”进入到“休眠（阻塞）状态”。sleep()会指定休眠时间，线程休眠的时候会大于或者等于该休眠时间，当时间过后该线程重新被会唤醒，他会由“阻塞状态”编程“就绪状态”，从而等待cpu的调度执行，注意：sleep方法只是让出了cpu的执行权，并不会释放同步资源锁。</p><p>yield()的作用是让步，它能够让当前线程从“运行状态”进入到“就绪状态”，从而让其他等待线程获取执行权，但是不能保证在当前线程调用yield()之后，其他线程就一定能获得执行权，也有可能是当前线程又回到“运行状态”继续运行，注意：这里我将上面的“具有相同优先级”的线程直接改为了线程，很多资料都写的是让具有相同优先级的线程开始竞争，但其实不是这样的，优先级低的线程在拿到cpu执行权后也是可以执行，只不过优先级高的线程拿到cpu执行权的概率比较大而已，并不是一定能拿到。</p><p>举个例子：一帮朋友在排队上公交车，轮到Yield的时候，他突然说：我不想先上去了，咱们大家来竞赛上公交车。然后所有人就一块冲向公交车，有可能是其他人先上车了，也有可能是Yield先上车了。但是线程是有优先级的，优先级越高的人，就一定能第一个上车吗？这是不一定的，优先级高的人仅仅只是第一个上车的概率大了一点而已，最终第一个上车的，也有可能是优先级最低的人。并且所谓的优先级执行，是在大量执行次数中才能体现出来的。</p><h2 id="1-8-wait和sleep的区别"><a href="#1-8-wait和sleep的区别" class="headerlink" title="1.8 wait和sleep的区别"></a>1.8 wait和sleep的区别</h2><p>相同点：</p><ul><li>他们都是在多线程的环境下，都可以在程序的调用出阻塞指定的毫秒数并且返回</li><li>两个方法都可以通过interrupt()方法打断线程的暂停状态，但是线程会抛出InterruptedException。需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。 </li></ul><p>不同点：</p><ul><li>Thread类的方法：sleep(),yield()，Object的方法：wait()和notify()、notifyAll()</li><li>每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。 sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 </li><li>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 。注意：wiat()必须放在synchronized block中，否则会在program runtime时扔出“java.lang.IllegalMonitorStateException”异常。</li><li>sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常</li></ul><p>综上可得两者最大的区别：sleep()睡眠时，保持对象锁，仍然占有该锁；而wait()睡眠时，释放对象锁。</p><p>注意：</p><p>第一：调用notify() 方法导致解除阻塞的线程是从因调用该对象的 wait()方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</p><p>第二：除了notify()，还有一个方法 notifyAll()也可起到类似作用，唯一的区别在于，调用 notifyAll()方法将把因调用该对象的 wait()方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</p><p>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend()方法和不指定超时期限的wait()方法的调用都可能产生死锁。遗憾的是，Java并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。</p><h2 id="1-9-join"><a href="#1-9-join" class="headerlink" title="1.9 join()"></a>1.9 join()</h2><p>join()方法能让其他线程从运行状态变为阻塞状态，直到当前线程执行完成后，其他线程才会执行。起初我对这句话理解是有误的，还好及时更正了过来。看下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Test implements Runnable &#123;  </span><br><span class="line">    private String threadName;  </span><br><span class="line">   </span><br><span class="line">    public Test(String threadName) &#123;  </span><br><span class="line">        this.threadName &#x3D; threadName;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 1000; i++) &#123;  </span><br><span class="line">            System.out.println(threadName + i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Test test1 &#x3D; new Test(&quot;线程1*&quot;);  </span><br><span class="line">        Test test2 &#x3D; new Test(&quot;线程2$&quot;);  </span><br><span class="line">        Thread thread1 &#x3D; new Thread(test1);  </span><br><span class="line">        Thread thread2 &#x3D; new Thread(test2);  </span><br><span class="line">        thread1.start();  </span><br><span class="line">        thread2.start();  </span><br><span class="line">        try &#123;  </span><br><span class="line">            thread2.join();  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我预想的结果是线程1先启动，然后执行一部分，线程2启动了，然后调用了join方法，此时线程1等待线程2执行完成后继续执行剩余部分。但是上面程序运行的结果是两个线程交替执行，并没有出现线程1等待线程2的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. public static void main(String[] args) &#123;  </span><br><span class="line">2.        Test test1 &#x3D; new Test(&quot;线程1*&quot;);  </span><br><span class="line">3.        Test test2 &#x3D; new Test(&quot;线程2$&quot;);  </span><br><span class="line">4.        Thread thread1 &#x3D; new Thread(test1);  </span><br><span class="line">5.        Thread thread2 &#x3D; new Thread(test2);  </span><br><span class="line">6.        thread2.start();  </span><br><span class="line">7.        try &#123;  </span><br><span class="line">8.            thread2.join();  </span><br><span class="line">9.        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">10.            e.printStackTrace();  </span><br><span class="line">11.        &#125;  </span><br><span class="line">12.        thread1.start();  </span><br><span class="line">13.    &#125;</span><br></pre></td></tr></table></figure><p>这次并没有出现线程1和线程2交替执行的情况。所以join方法应该这么解释：</p><p>A.join()方法之后的线程（包括主线程）会等待A线程执行结束后再执行，A线程之前的线程并不会等待A执行后再执行，而是交替执行</p><h2 id="1-10-用户线程、守护线程"><a href="#1-10-用户线程、守护线程" class="headerlink" title="1.10 用户线程、守护线程"></a>1.10 用户线程、守护线程</h2><p>在Java中有两类线程：用户线程 (User Thread)、守护线程 (Daemon Thread)。</p><p>守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。</p><p>守护线程是个服务线程，准确地来说就是服务其他的线程，这是它的作用——而其他的线程只有一种，那就是用户线程</p><p>二者其实基本上是一样的。唯一的区别在于JVM何时离开。</p><ul><li>用户线程：当存在任何一个用户线程未离开，JVM是不会离开的。就是应用程序里的自定义线程</li><li>守护线程：如果只剩下守护线程未离开，JVM是可以离开的。在JVM中，像垃圾收集器线程就是守护线程。</li></ul><p>用户线程创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                System.out.println(&quot;3.我是通过匿名内部类方式启动的线程&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;).start();</span><br></pre></td></tr></table></figure><p>守护线程创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class DamomThread &#123;  </span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        Thread thread &#x3D; new Thread( ()-&gt; &#123;  </span><br><span class="line">            while (true)&#123;  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    Thread.sleep(1000);  </span><br><span class="line">                    System.out.println(&quot;内部线程：正在执行。。。。&quot;);  </span><br><span class="line">                &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">   </span><br><span class="line">            &#125;  </span><br><span class="line">   </span><br><span class="line">        &#125;  ) ;  </span><br><span class="line">   </span><br><span class="line">        &#x2F;&#x2F;开启守护进程  </span><br><span class="line">        &#x2F;&#x2F;thread.setDaemon(true);  </span><br><span class="line">  </span><br><span class="line">        thread.start();  </span><br><span class="line">        Thread.sleep(2_000L );  </span><br><span class="line">        System.out.println(&quot;Main thread finished lifecycle !!!!!!!!!!&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码一共开启了两个线程，一个是main线程，另一个是里面执行的线程thread</p><p>未开始守护进程： thread.setDaemon(false);</p><p>外面的线程main线程，结束退出，里面的线程，依旧继续执行</p><p><img src="dxc-msg.assets/image-20200528001512362.png" alt="image-20200528001512362"></p><p>开始守护进程： thread.setDaemon(true)。main线程退出，内部线程一起退出。</p><p><img src="dxc-msg.assets/image-20200528001522567.png" alt="image-20200528001522567"></p><h2 id="1-11-锁"><a href="#1-11-锁" class="headerlink" title="1.11 锁"></a>1.11 锁</h2><p>锁有四种类型</p><ul><li>可重入锁：在执行对象中所有同步方法不用再次获得锁</li><li>可中断锁：在等待获取锁过程中可中断</li><li>公平锁： 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利</li><li>读写锁：对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写</li></ul><h3 id="1-11-1-synchronized"><a href="#1-11-1-synchronized" class="headerlink" title="1.11.1 synchronized"></a>1.11.1 synchronized</h3><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： </p><ol><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li><li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li><li>修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li><li>修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。</li></ol><ul><li>修饰代码块（注意锁对象this）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class SyncThread implements Runnable &#123;  </span><br><span class="line">        private static int count;  </span><br><span class="line">        public SyncThread() &#123;count &#x3D; 0;&#125;  </span><br><span class="line">        public void run() &#123;  </span><br><span class="line">            synchronized(this) &#123;  </span><br><span class="line">                for (int i &#x3D; 0; i &lt; 5; i++) &#123;  </span><br><span class="line">                    try &#123;  </span><br><span class="line">         System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));</span><br><span class="line">                        Thread.sleep(100);  </span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                        e.printStackTrace();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        public int getCount() &#123;  </span><br><span class="line">            return count;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SyncThread的调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.SyncThread syncThread &#x3D; new SyncThread();  </span><br><span class="line">2.Thread thread1 &#x3D; new Thread(syncThread, &quot;SyncThread1&quot;);  </span><br><span class="line">3.Thread thread2 &#x3D; new Thread(syncThread, &quot;SyncThread2&quot;);  </span><br><span class="line">4.thread1.start();  </span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure><p>使用synchronized修饰输出结果：</p><p><img src="dxc-msg.assets/image-20200528001548809.png" alt="image-20200528001548809"></p><p>取消synvhronized修饰的输出结果</p><p><img src="dxc-msg.assets/image-20200528001627365.png" alt="image-20200528001627365"></p><p>当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。Thread1和thread2是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。</p><p>我们把上方测试类稍加修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Thread thread1 &#x3D; new Thread(new SyncThread(), &quot;SyncThread1&quot;);  </span><br><span class="line">2.Thread thread2 &#x3D; new Thread(new SyncThread(), &quot;SyncThread2&quot;);  </span><br><span class="line">3.thread1.start();  </span><br><span class="line">4.thread2.start();</span><br></pre></td></tr></table></figure><p>这时创建了两个SyncThread的对象syncThread1和syncThread2，线程thread1执行的是syncThread1对象中的synchronized代码(run)，而线程thread2执行的是syncThread2对象中的synchronized代码(run)；我们知道synchronized锁定的是对象，这时会有两把锁分别锁定syncThread1对象和syncThread2对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。</p><p>当一个线程访问对象的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该对象中的非synchronized(this)同步代码块。一个线程访问一个对象的synchronized代码块时，别的线程可以访问该对象的非synchronized代码块而不受阻塞。</p><ul><li>修饰方法</li></ul><p>Synchronized修饰一个方法很简单，就是在方法的前面加synchronized，synchronized修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。</p><p>写法一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.public synchronized void method() &#123;  </span><br><span class="line">2.&#x2F;&#x2F; todo  </span><br><span class="line">3.&#125;</span><br></pre></td></tr></table></figure><p>写法二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.public void method() &#123;  </span><br><span class="line">2.    synchronized(this) &#123;  </span><br><span class="line">3.&#x2F;&#x2F; todo  </span><br><span class="line">4.    &#125;  </span><br><span class="line">5.&#125;</span><br></pre></td></tr></table></figure><p>在用synchronized修饰方法时要注意以下几点： </p><ol><li>synchronized关键字不能继承。 </li></ol><p>虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。</p><ol><li>在定义接口方法时不能使用synchronized关键字</li><li>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。</li></ol><ul><li>修饰静态方法</li></ul><p>我们知道静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class SyncThread implements Runnable &#123;  </span><br><span class="line">        private static int count;  </span><br><span class="line">  </span><br><span class="line">        public SyncThread() &#123;  </span><br><span class="line">            count &#x3D; 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public synchronized static void method() &#123;  </span><br><span class="line">            for (int i &#x3D; 0; i &lt; 5; i ++) &#123;  </span><br><span class="line">                try &#123;  </span><br><span class="line">         System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));</span><br><span class="line">                    Thread.sleep(100);  </span><br><span class="line">                &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public synchronized void run() &#123;  </span><br><span class="line">            method();  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.SyncThread syncThread1 &#x3D; new SyncThread();  </span><br><span class="line">2.SyncThread syncThread2 &#x3D; new SyncThread();  </span><br><span class="line">3.Thread thread1 &#x3D; new Thread(syncThread1, &quot;SyncThread1&quot;);  </span><br><span class="line">4.Thread thread2 &#x3D; new Thread(syncThread2, &quot;SyncThread2&quot;);  </span><br><span class="line">5.thread1.start();  </span><br><span class="line">6.thread2.start();</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.SyncThread1:0   </span><br><span class="line">2.SyncThread1:1   </span><br><span class="line">3.SyncThread1:2   </span><br><span class="line">4.SyncThread1:3   </span><br><span class="line">5.SyncThread1:4   </span><br><span class="line">6.SyncThread2:5   </span><br><span class="line">7.SyncThread2:6   </span><br><span class="line">8.SyncThread2:7   </span><br><span class="line">9.SyncThread2:8   </span><br><span class="line">SyncThread2:9</span><br></pre></td></tr></table></figure><p>syncThread1和syncThread2是SyncThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁。这与使用关键字synchronized运行结果相同</p><ul><li>修饰一个类（注意锁对象是类calss对象）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class SyncThread implements Runnable &#123;  </span><br><span class="line">        private static int count;  </span><br><span class="line">        public SyncThread() &#123;count &#x3D; 0;&#125;  </span><br><span class="line">  </span><br><span class="line">        public static void method() &#123;  </span><br><span class="line">            synchronized(SyncThread.class) &#123;  </span><br><span class="line">                for (int i &#x3D; 0; i &lt; 5; i ++) &#123;  </span><br><span class="line">                    try &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++)); </span><br><span class="line">                        Thread.sleep(100);  </span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                        e.printStackTrace();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;    </span><br><span class="line">        public synchronized void run() &#123;  </span><br><span class="line">            method();  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SyncThread syncThread1 &#x3D; new SyncThread();  </span><br><span class="line">SyncThread syncThread2 &#x3D; new SyncThread();  </span><br><span class="line">Thread thread1 &#x3D; new Thread(syncThread1, &quot;SyncThread1&quot;);  </span><br><span class="line">Thread thread2 &#x3D; new Thread(syncThread2, &quot;SyncThread2&quot;);  </span><br><span class="line">thread1.start();  </span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">11.SyncThread1:0   </span><br><span class="line">12.SyncThread1:1   </span><br><span class="line">13.SyncThread1:2   </span><br><span class="line">14.SyncThread1:3   </span><br><span class="line">15.SyncThread1:4   </span><br><span class="line">16.SyncThread2:5   </span><br><span class="line">17.SyncThread2:6   </span><br><span class="line">18.SyncThread2:7   </span><br><span class="line">19.SyncThread2:8   </span><br><span class="line">SyncThread2:9</span><br></pre></td></tr></table></figure><p>效果和上面synchronized修饰静态方法是一样的，synchronized作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁。</p><ul><li>重点知识—— wait() notify() notifyAll()的正确使用</li></ul><p>基于使用 synchronized 锁，JVM都会为锁对象维护两个集合，你必须知道的两个概念：</p><ol><li>Entry Set(别名锁池)：线程获取对象锁失败，则会进入这个对象的锁池。(若线程A获取了对象锁，那么线程B再来获取这个对象锁，必定失败，B线程则会进入锁池)</li><li>Wait Set(别名等待池)：线程获取锁后，调用了wait方法，那么就会进入这个对象的等待池。（若线程A获取了对象锁，那么线程A调用了wait方法，A会释放锁，然后进入等待池）</li></ol><p>这三个方法必须放在synchronized代码块或者方法块中使用，否则会抛出java.lang.IllegalMonitorStateException 异常</p><ol><li>wait：调用这个方法，线程就会释放锁，然后进入等待池，必须等待别的线程唤醒自己。     </li><li>notify：调用这个方法，则会随机唤醒等待池中的一个线程。Note：被唤醒的线程不会立马执行，它只是从blocked -&gt; runnable状态，形象的说是这个被唤醒的线程从等待池中进入到锁池，锁池中的线程会去竞争该对象锁，获取到了才能执行</li><li>notifyAll：唤醒等待池中的所有线程，这是和 notify 唯一的区别</li></ol><p>再来看两个常被提到的问题：</p><ol><li>wait 要放在while里面循环，不要放在if语句中，否则不安全，可能出现死锁。</li><li>唤醒最好调用notifyAll，不要使用notify，否者不安全，可能出现死锁。</li></ol><p>这两个说法并没有错，但是前提是多生产者和多消费者的情况下才是完全正确，但是如是一个生产者线程和一个消费者线程，那么问题1中也是可以使用if语句的，2中也是可以使用notify。</p><p>^ 多消费者-多生产者下为什么不要在if语句里面使用wait()？</p><p>如果只有一个生产者线程，一个消费者线程，那其实是可以用if代替while的，因为线程调度的行为是开发者可以预测的，生产者线程只有可能被消费者线程唤醒，反之亦然，因此被唤醒时条件始终满足，程序不会出错。</p><p>但是在多消费者-多生产者下，wait()的线程永远不能确定其他线程会在什么状态下notify()，所以必须在被唤醒、抢占到锁并且从wait()方法退出的时候再次进行指定条件的判断，以决定是满足条件往下执行呢还是不满足条件再次wait()</p><p>^ 多消费者-多生产者下为什么要用notifyAll？</p><p>两个生产者两个消费者的场景，如果我们代码中使用了notify()而非notifyAll()，假设消费者线程1拿到了锁，判断资源为空，那么wait()，释放锁；然后消费者2拿到了锁，同样资源为空，wait()，也就是说此时Wait Set中有两个线程；然后生产者1拿到锁，生产，有资源了，notify()了，那么可能消费者1被唤醒了，但是此时还有另一个线程生产者2在Entry Set中盼望着锁，并且最终抢占到了锁，但因为此时资源是有的，因此它要wait()；然后消费者1拿到了锁，消费，notify()；这时就有问题了，此时生产者2和消费者2都在Wait Set中，资源为空，如果唤醒生产者2，没毛病；但如果唤醒了消费者2，因为资源为空，它会再次wait()，这就尴尬了，万一生产者1已经退出不再生产了，没有其他线程在竞争锁了，只有生产者2和消费者2在Wait Set中互相等待，那传说中的死锁就发生了。</p><h3 id="1-11-2-lock"><a href="#1-11-2-lock" class="headerlink" title="1.11.2 lock"></a>1.11.2 lock</h3><p>synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？</p><p>在上面一篇文章中，我们了解到如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p><ul><li>获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</li><li>线程执行发生异常，此时JVM会让线程自动释放锁。</li></ul><p>那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。</p><p>因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p><p>再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。</p><p>但是采用synchronized关键字来实现同步的话，就会导致一个问题：</p><p>如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</p><p>另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</p><p>总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：</p><ul><li>Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</li><li>Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li></ul><h4 id="1-11-2-1java-util-concurrent-locks包下常用的类和接口"><a href="#1-11-2-1java-util-concurrent-locks包下常用的类和接口" class="headerlink" title="1.11.2.1java.util.concurrent.locks包下常用的类和接口"></a>1.11.2.1java.util.concurrent.locks包下常用的类和接口</h4><h5 id="1-Lock"><a href="#1-Lock" class="headerlink" title="1 Lock"></a>1 Lock</h5><p>首先要说明的就是Lock，通过查看Lock的源码可知，Lock是一个接口：</p><p><img src="dxc-msg.assets/image-20200527232909126.png" alt="image-20200527232909126"></p><p>​    下面来逐个讲述Lock接口中每个方法的使用，lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。newCondition()这个方法暂且不在此讲述，会在后面的线程协作一文中讲述。</p><p>在Lock中声明了四个方法来获取锁，那么这四个方法有何区别呢？</p><p>首先lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</p><p>由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：</p><p><img src="dxc-msg.assets/image-20200527232951295.png" alt="image-20200527232951295"></p><p>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p><p>　　tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</p><p>　　所以，一般情况下通过tryLock来获取锁时是这样使用的：</p><p><img src="dxc-msg.assets/image-20200527233040910.png" alt="image-20200527233040910"></p><p>lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时（也就是说想要通过interrupt()中断阻塞状态的线程，那么一定要通过lock.lockInterruptibly()获取锁），假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</p><p>　　由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。</p><p>因此lockInterruptibly()一般的使用形式如下：</p><p><img src="dxc-msg.assets/image-20200527233059509.png" alt="image-20200527233059509"></p><p>输出</p><p><img src="dxc-msg.assets/image-20200527233115123.png" alt="image-20200527233115123"></p><p>线程2在阻塞状态时被主动执行.interrupt()方法中断等待</p><p>注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为本身在前面的文章中讲过单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。</p><p>　　因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。</p><p>而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p><h5 id="2-ReentrantLock——可重入锁"><a href="#2-ReentrantLock——可重入锁" class="headerlink" title="2 ReentrantLock——可重入锁"></a>2 ReentrantLock——可重入锁</h5><p>ReentrantLock，意思是“可重入锁”，关于可重入锁的概念在下一节讲述。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。</p><p>例子1，lock()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    private ArrayList&lt;Integer&gt; arrayList &#x3D; new ArrayList&lt;Integer&gt;();  </span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();    &#x2F;&#x2F;注意这个地方，是同一个锁对象  </span><br><span class="line">    public static void main(String[] args)  &#123;  </span><br><span class="line">        final Test test &#x3D; new Test();  </span><br><span class="line">           </span><br><span class="line">        new Thread()&#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                test.insert(Thread.currentThread());  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">           </span><br><span class="line">        new Thread()&#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                test.insert(Thread.currentThread());  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">    &#125;    </span><br><span class="line">       </span><br><span class="line">    public void insert(Thread thread) &#123;  </span><br><span class="line">        lock.lock();  </span><br><span class="line">        try &#123;  </span><br><span class="line">            System.out.println(thread.getName()+&quot;得到了锁&quot;);  </span><br><span class="line">            for(int i&#x3D;0;i&lt;5;i++) &#123;  </span><br><span class="line">                arrayList.add(i);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            &#x2F;&#x2F; TODO: handle exception  </span><br><span class="line">        &#125;finally &#123;  </span><br><span class="line">            System.out.println(thread.getName()+&quot;释放了锁&quot;);  </span><br><span class="line">            lock.unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子2，tryLock()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    private ArrayList&lt;Integer&gt; arrayList &#x3D; new ArrayList&lt;Integer&gt;();  </span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();    &#x2F;&#x2F;注意这个地方，是同一个锁对象</span><br><span class="line">    public static void main(String[] args)  &#123;  </span><br><span class="line">        final Test test &#x3D; new Test();  </span><br><span class="line">           </span><br><span class="line">        new Thread()&#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                test.insert(Thread.currentThread());  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">           </span><br><span class="line">        new Thread()&#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                test.insert(Thread.currentThread());  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">    &#125;    </span><br><span class="line">       </span><br><span class="line">    public void insert(Thread thread) &#123;  </span><br><span class="line">        if(lock.tryLock()) &#123;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                System.out.println(thread.getName()+&quot;得到了锁&quot;);  </span><br><span class="line">                for(int i&#x3D;0;i&lt;5;i++) &#123;  </span><br><span class="line">                    arrayList.add(i);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; catch (Exception e) &#123;  </span><br><span class="line">                &#x2F;&#x2F; TODO: handle exception  </span><br><span class="line">            &#125;finally &#123;  </span><br><span class="line">                System.out.println(thread.getName()+&quot;释放了锁&quot;);  </span><br><span class="line">                lock.unlock();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            System.out.println(thread.getName()+&quot;获取锁失败&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="dxc-msg.assets/image-20200527233322904.png" alt="image-20200527233322904"></p><p>例子3，lockInterruptibly()响应中断的使用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();     </span><br><span class="line">    public static void main(String[] args)  &#123;  </span><br><span class="line">        Test test &#x3D; new Test();  </span><br><span class="line">        MyThread thread1 &#x3D; new MyThread(test);  </span><br><span class="line">        MyThread thread2 &#x3D; new MyThread(test);  </span><br><span class="line">        thread1.start();  </span><br><span class="line">        thread2.start();  </span><br><span class="line">           </span><br><span class="line">        try &#123;  </span><br><span class="line">            Thread.sleep(2000);  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        thread2.interrupt();  </span><br><span class="line">    &#125;    </span><br><span class="line">       </span><br><span class="line">public void insert(Thread thread) throws InterruptedException&#123;</span><br><span class="line">&#x2F;&#x2F;注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出  </span><br><span class="line">        lock.lockInterruptibly();     </span><br><span class="line">        try &#123;    </span><br><span class="line">            System.out.println(thread.getName()+&quot;得到了锁&quot;);  </span><br><span class="line">            long startTime &#x3D; System.currentTimeMillis();  </span><br><span class="line">            for(    ;     ;) &#123;  </span><br><span class="line">                if(System.currentTimeMillis() - startTime &gt;&#x3D; Integer.MAX_VALUE) </span><br><span class="line">                    break;  </span><br><span class="line">                &#x2F;&#x2F;插入数据  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        finally &#123;  </span><br><span class="line">           System.out.println(Thread.currentThread().getName()+&quot;执行finally&quot;);  </span><br><span class="line">            lock.unlock();  </span><br><span class="line">            System.out.println(thread.getName()+&quot;释放了锁&quot;);  </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    private Test test &#x3D; null;  </span><br><span class="line">    public MyThread(Test test) &#123;  </span><br><span class="line">        this.test &#x3D; test;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;          </span><br><span class="line">        try &#123;  </span><br><span class="line">            test.insert(Thread.currentThread());  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;被中断&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，发现thread2能够被正确中断。</p><h5 id="3-ReadWriteLock——读写锁"><a href="#3-ReadWriteLock——读写锁" class="headerlink" title="3 ReadWriteLock——读写锁"></a>3 ReadWriteLock——读写锁</h5><p>ReadWriteLock也是一个接口，在它里面只定义了两个方法：</p><ul><li>Lock readLock();</li><li>Lock writeLock();</li></ul><p>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。</p><h5 id="4-ReentrantReadWriteLock"><a href="#4-ReentrantReadWriteLock" class="headerlink" title="4 ReentrantReadWriteLock"></a>4 ReentrantReadWriteLock</h5><p>ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。</p><p>假如有多个线程要同时进行读操作,syncornized就不太合适了，改成读写锁如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    private ReentrantReadWriteLock rwl &#x3D; new ReentrantReadWriteLock();  </span><br><span class="line">       </span><br><span class="line">    public static void main(String[] args)  &#123;  </span><br><span class="line">        final Test test &#x3D; new Test();  </span><br><span class="line">           </span><br><span class="line">        new Thread()&#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                test.get(Thread.currentThread());  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">           </span><br><span class="line">        new Thread()&#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                test.get(Thread.currentThread());  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">           </span><br><span class="line">    &#125;    </span><br><span class="line">       </span><br><span class="line">    public void get(Thread thread) &#123;  </span><br><span class="line">        rwl.readLock().lock();  </span><br><span class="line">        try &#123;  </span><br><span class="line">            long start &#x3D; System.currentTimeMillis();  </span><br><span class="line">               </span><br><span class="line">            while(System.currentTimeMillis() - start &lt;&#x3D; 1) &#123;  </span><br><span class="line">                System.out.println(thread.getName()+&quot;正在进行读操作&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">            System.out.println(thread.getName()+&quot;读操作完毕&quot;);  </span><br><span class="line">        &#125; finally &#123;  </span><br><span class="line">            rwl.readLock().unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="dxc-msg.assets/image-20200527233630577.png" alt="image-20200527233630577"></p><p>说明thread1和thread2在同时进行读操作，这样就大大提升了读操作的效率。</p><p>不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。</p><p>　　如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</p><p>关于ReentrantReadWriteLock类中的其他方法感兴趣的朋友可以自行查阅API文档。</p><h4 id="1-11-3-Lock和synchronized的区别总结"><a href="#1-11-3-Lock和synchronized的区别总结" class="headerlink" title="1.11.3 Lock和synchronized的区别总结"></a>1.11.3 Lock和synchronized的区别总结</h4><p>总结来说，Lock和synchronized有以下几点不同：</p><ul><li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li><li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li><li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li><li>Lock可以提高多个线程进行读操作的效率。</li></ul><p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p><h4 id="1-11-4-锁的相关概念"><a href="#1-11-4-锁的相关概念" class="headerlink" title="1.11.4 锁的相关概念"></a>1.11.4 锁的相关概念</h4><h5 id="1-可重入锁"><a href="#1-可重入锁" class="headerlink" title="*.1 可重入锁"></a>*.1 可重入锁</h5><p>如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.class MyClass &#123;  </span><br><span class="line">2.    public synchronized void method1() &#123;  </span><br><span class="line">3.        method2();  </span><br><span class="line">4.    &#125;  </span><br><span class="line">5.       </span><br><span class="line">6.    public synchronized void method2() &#123;  </span><br><span class="line">7.           </span><br><span class="line">8.    &#125;  </span><br><span class="line">9.&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。</p><p>而由于synchronized和Lock都具备可重入性，所以不会发生上述现象。</p><h5 id="2-可中断锁"><a href="#2-可中断锁" class="headerlink" title="*.2 可中断锁"></a>*.2 可中断锁</h5><p>可中断锁：顾名思义，就是可以相应中断的锁。</p><p>在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</p><p>如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p><p>在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。</p><h5 id="3-公平锁"><a href="#3-公平锁" class="headerlink" title="*3. 公平锁"></a>*3. 公平锁</h5><p>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。</p><p>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p><p>在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。</p><p>而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</p><p>在ReentrantLock中定义了2个静态内部类，一个是NotFairSync，一个是FairSync，分别用来实现非公平锁和公平锁。</p><p>我们可以在创建ReentrantLock对象时，通过以下方式来设置锁的公平性：</p><p><img src="dxc-msg.assets/image-20200527234059563.png" alt="image-20200527234059563"></p><p>另外在ReentrantLock类中定义了很多方法，比如：</p><ul><li>isFair()    //判断锁是否是公平锁</li><li>isLocked()  //判断锁是否被任何线程获取了</li><li>isHeldByCurrentThread()  //判断锁是否被当前线程获取了</li><li>hasQueuedThreads()  //判断是否有线程在等待该锁</li></ul><p>在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。</p><h5 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="*4. 读写锁"></a>*4. 读写锁</h5><p>读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。</p><p>正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。</p><p>ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。</p><p>可以通过readLock()获取读锁，通过writeLock()获取写锁。</p><h2 id="1-11-Java中Volatile关键字详解"><a href="#1-11-Java中Volatile关键字详解" class="headerlink" title="1.11 Java中Volatile关键字详解"></a>1.11 Java中Volatile关键字详解</h2><h3 id="1-11-1-基本概念"><a href="#1-11-1-基本概念" class="headerlink" title="1.11.1 基本概念"></a>1.11.1 基本概念</h3><p>先补充一下概念：Java 内存模型中的可见性、原子性和有序性。</p><ul><li>可见性</li></ul><p>可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p><p>　　可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。</p><p>在 Java 中 volatile、synchronized 和 final 实现可见性。</p><ul><li>原子性：</li></ul><p>原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作是原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。</p><p>在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。</p><ul><li>有序性</li></ul><p>Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象</p><p>锁的两个同步块只能串行。</p><p>下面一段代码在多线程环境下，将存在问题。</p><p><img src="dxc-msg.assets/image-20200527234534836.png" alt="image-20200527234534836"></p><p>NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready的值。甚至NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入number的值，这种现象被称为“重排序”。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写入number，然后在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序完全相反。</p><p>　　在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，无法得到正确的结论。</p><p>这个看上去像是一个失败的设计，但却能使JVM充分地利用现代多核处理器的强大性能。例如，在缺少同步的情况下，Java内存模型允许编译器对操作顺序进行重排序，并将数值缓存在寄存器中。此外，它还允许CPU对操作顺序进行重排序，并将数值缓存在处理器特定的缓存中。</p><h3 id="1-11-2-Volatile原理"><a href="#1-11-2-Volatile原理" class="headerlink" title="1.11.2 Volatile原理"></a>1.11.2 Volatile原理</h3><p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p><p>　　在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</p><p><img src="dxc-msg.assets/image-20200527234704706.png" alt="image-20200527234704706"></p><p>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过CPU cache这一步。</p><p><strong><em>\</em>当一个变量定义为 volatile 之后，将具备两种特性：**</strong></p><p>　　1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：<a href="http://www.cnblogs.com/zhengbin/p/6407137.html" target="_blank" rel="noopener">Java内存模型</a>）来完成。</p><p>　　2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个<strong><em>\</em>内存屏障**</strong>（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。</p><p><strong><em>\</em>volatile 性能：**</strong></p><p>　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p><h1 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2.线程池"></a>2.线程池</h1><h2 id="2-1-什么是线程池"><a href="#2-1-什么是线程池" class="headerlink" title="2.1 什么是线程池"></a>2.1 什么是线程池</h2><p>线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交由线程池来管理。</p><p>为了充分利用CPU多核资源，应用都会采用多线程并行/并发计算，最大限度的利用多核提升应用程序性能。</p><p>试想一下，如果每个请求都执行一遍创建线程、执行任务、销毁线程，那么对服务器资源将是一种浪费。在高并发的情况下，甚至会耗尽服务器资源。</p><p>线程池的主要作用有两个：</p><ul><li>l 重复利用线程，无需频繁的创建和销毁线程，降低系统开销和，</li><li>l 控制线程数量上限，避免创建过多的线程耗尽进程内存空间，减少线程上下文切换次数。</li></ul><h2 id="2-2线程池的创建与使用"><a href="#2-2线程池的创建与使用" class="headerlink" title="2.2线程池的创建与使用"></a>2.2线程池的创建与使用</h2><p>在JDK5版本中增加了内置线程池实现ThreadPoolExecutor，同时提供了Executors来创建不同类型的线程池。Executors中提供了以下常见的线程池创建方法：</p><p>(1) newSingleThreadExecutor：一个单线程的线程池。如果因异常结束，会再创建一个新的，保证按照提交顺序执行。</p><p>(2) newFixedThreadPool：创建固定大小的线程池。根据提交的任务逐个增加线程，直到最大值保持不变。如果因异常结束，会新创建一个线程补充。</p><p>(3) newCachedThreadPool：创建一个可缓存的线程池。会根据任务自动新增或回收线程。</p><p>(4) newScheduledThreadPool：支持定时以及周期性执行任务的需求。·</p><p>(5) newWorkStealingPool：JDK8新增，根据所需的并行层次来动态创建和关闭线程，通过使用多个队列减少竞争，底层使用ForkJoinPool来实现。优势在于可以充分利用多CPU，把一个任务拆分成多个“小任务”，放到多个处理器核心上并行执行；当多个“小任务”执行完成之后，再将这些执行结果合并起来即可。</p><p>虽然在JDK中提供Executors类来支持以上类型的线程池创建，但通常情况下不建议开发人员直接使用（见《阿里巴巴java开发规范》）。</p><p><img src="dxc-msg.assets/image-20200527234923837.png" alt="image-20200527234923837"></p><p>Executors部分方法的弊端：</p><p>(1) newFixedThreadPool和newSingleThreadExecutor主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</p><p>(2) newCachedThreadPool和newScheduledThreadPool:主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</p><p>同时，阿里巴巴java开发规范中推荐了3种线程池创建方式。</p><p>方式一，引入commons-lang3包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;org.apache.commons.lang3.concurrent.BasicThreadFactory  </span><br><span class="line">ScheduledExecutorService executorService &#x3D; new ScheduledThreadPoolExecutor(1,      </span><br><span class="line">new BasicThreadFactory.Builder().namingPattern(&quot;example-schedule-pool-%d&quot;).daemon(true).build());</span><br></pre></td></tr></table></figure><p>方式二，引入com.google.guava包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory namedThreadFactory &#x3D; new ThreadFactoryBuilder() .setNameFormat(&quot;demo-pool-%d&quot;).build();  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Common Thread Pool  </span><br><span class="line">ExecutorService pool &#x3D; new ThreadPoolExecutor(5, 200,  0L, TimeUnit.MILLISECONDS,  </span><br><span class="line">    new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());  </span><br><span class="line"></span><br><span class="line">pool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));  </span><br><span class="line">pool.shutdown();&#x2F;&#x2F;gracefully shutdown</span><br></pre></td></tr></table></figure><p>方式三，spring配置线程池方式：自定义线程工厂bean需要实现ThreadFactory，可参考该接口的其它默认实现类，使用方式直接注入bean，调用execute(Runnable task)方法即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userThreadPool&quot;  </span><br><span class="line">    class&#x3D;&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&gt;  </span><br><span class="line">    &lt;property name&#x3D;&quot;corePoolSize&quot; value&#x3D;&quot;10&quot; &#x2F;&gt;  </span><br><span class="line">    &lt;property name&#x3D;&quot;maxPoolSize&quot; value&#x3D;&quot;100&quot; &#x2F;&gt;  </span><br><span class="line">    &lt;property name&#x3D;&quot;queueCapacity&quot; value&#x3D;&quot;2000&quot; &#x2F;&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;property name&#x3D;&quot;threadFactory&quot; value&#x3D; threadFactory &#x2F;&gt;  </span><br><span class="line">    &lt;property name&#x3D;&quot;rejectedExecutionHandler&quot;&gt;  </span><br><span class="line">        &lt;ref local&#x3D;&quot;rejectedExecutionHandler&quot; &#x2F;&gt;  </span><br><span class="line">    &lt;&#x2F;property&gt;  </span><br><span class="line">&lt;&#x2F;bean&gt;  </span><br><span class="line">&#x2F;&#x2F; 代码里使用  </span><br><span class="line">userThreadPool.execute(thread);</span><br></pre></td></tr></table></figure><h2 id="2-3ThreadPoolExecutor的构造方法"><a href="#2-3ThreadPoolExecutor的构造方法" class="headerlink" title="2.3ThreadPoolExecutor的构造方法"></a>2.3ThreadPoolExecutor的构造方法</h2><p>除了以上推荐的创建线程池的方法，还可以通过ThreadPoolExecutor的构造方法，直接创建线程池。本质上来讲，以上方法最终也是创建了ThreadPoolExecutor对象，然后进行包装处理。</p><p>ThreadPoolExecutor提供了多个构造方法，我们以调用构造方法来进行说明。</p><p><img src="dxc-msg.assets/image-20200527235208809.png" alt="image-20200527235208809"></p><p>核心参数作用解析如下：</p><p>(1) corePoolSize：线程池核心线程数最大值。</p><p>(2) maximumPoolSize：线程池最大线程数大小。</p><p>(3) keepAliveTime：线程池中非核心线程空闲的存活时间大小。</p><p>(4) unit：线程空闲存活时间单位。</p><p>(5) workQueue：存放任务的阻塞队列。</p><p>(6) threadFactory：创建新线程的工厂，所有线程都是通过该工厂创建的，有默认实现。</p><p>(7) handler：线程池的拒绝策略。</p><h2 id="2-4程池的拒绝策略"><a href="#2-4程池的拒绝策略" class="headerlink" title="2.4程池的拒绝策略"></a>2.4程池的拒绝策略</h2><p>构造方法的中最后的参数RejectedExecutionHandler用于指定线程池的拒绝策略。当请求任务不断的过来，而系统此时又处理不过来的时候，我们就需要采取对应的策略是拒绝服务。</p><p>默认有四种类型：</p><p>(1) AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。</p><p>(2) CallerRunsPolicy策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。</p><p>(3) DiscardOleddestPolicy策略：该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</p><p>(4) DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理。</p><p>当然，除了默认的4种策略之外，还可以根据业务需求自定义拒绝策略。通过实现RejectedExecutionHandler接口，在创建ThreadPoolExecutor对象时作为参数传入即可。</p><h2 id="2-5线程池的执行"><a href="#2-5线程池的执行" class="headerlink" title="2.5线程池的执行"></a>2.5线程池的执行</h2><p>创建完成ThreadPoolExecutor之后，当线程池提交任务时，通常使用execute方法。execute方法的执行流程图如下：</p><p><img src="dxc-msg.assets/image-20200527235347727.png" alt="image-20200527235347727"></p><p>(1) 如果线程池中存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。</p><p>(2) 如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</p><p>(3) 当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。</p><p>(4) 如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</p><h2 id="2-6-execute与submit的区别"><a href="#2-6-execute与submit的区别" class="headerlink" title="2.6 execute与submit的区别"></a>2.6 execute与submit的区别</h2><p>执行任务除了可以使用execute方法还可以使用submit方法。它们的主要区别是：execute适用于不需要关注返回值的场景，submit方法适用于需要关注返回值的场景。</p><h2 id="2-7-线程池中常见的队列"><a href="#2-7-线程池中常见的队列" class="headerlink" title="2.7 线程池中常见的队列"></a>2.7 线程池中常见的队列</h2><ol><li><p>ArrayBlockingQueue：有界队列，是一个用数组实现的有界阻塞队列，按FIFO排序量。</p></li><li><p>LinkedBlockingQueue：可设置容量队列，基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列。</p></li></ol><ol start="3"><li><p>DelayQueue：延迟队列，是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</p></li><li><p>PriorityBlockingQueue：优先级队列，是具有优先级的无界阻塞队列。</p></li><li><p>SynchronousQueue：同步队列，一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。</p></li></ol><h2 id="2-8关闭线程池"><a href="#2-8关闭线程池" class="headerlink" title="2.8关闭线程池"></a>2.8关闭线程池</h2><p>关闭线程池可以调用shutdownNow和shutdown两个方法来实现。</p><p>shutdownNow：对正在执行的任务全部发出interrupt()，停止执行，对还未开始执行的任务全部取消，并且返回还没开始的任务列表。</p><p>shutdown：当我们调用shutdown后，线程池将不再接受新的任务，但也不会去强制终止已经提交或者正在执行中的任务。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-线程&quot;&gt;&lt;a href=&quot;#1-线程&quot; class=&quot;headerlink&quot; title=&quot;1.线程&quot;&gt;&lt;/a&gt;1.线程&lt;/h1&gt;&lt;p&gt;线程:程序执行流的最小单元【可以理解为：进程中独立运行的子任务】。&lt;br&gt;多线程优点:最大限度的利用CPU的空闲时间来处理其他任务。
    
    </summary>
    
    
    
      <category term="多线程" scheme="https://dcghx.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
