<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>酱油村-记事录</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dcghx.github.io/"/>
  <updated>2020-05-29T14:29:20.204Z</updated>
  <id>https://dcghx.github.io/</id>
  
  <author>
    <name>酱油君</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程————CAS</title>
    <link href="https://dcghx.github.io/2020/05/09/dxc-cas/"/>
    <id>https://dcghx.github.io/2020/05/09/dxc-cas/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-29T14:29:20.204Z</updated>
    
    <content type="html"><![CDATA[<p>什么是悲观锁、乐观锁？在java语言里，总有一些名词看语义跟本不明白是啥玩意儿，也就总有部分面试官拿着这样的词来忽悠面试者，以此来找优越感，其实理解清楚了，这些词也就唬不住人了。<a id="more"></a></p><ul><li><p>synchronized是悲观锁，这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁。</p></li><li><p>CAS操作的就是乐观锁，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p></li></ul><p>在进入正题之前，我们先理解下下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.private static int count &#x3D; 0;  </span><br><span class="line">2.  </span><br><span class="line">3.   public static void main(String[] args) &#123;  </span><br><span class="line">4.       for (int i &#x3D; 0; i &lt; 2; i++) &#123;  </span><br><span class="line">5.           new Thread(new Runnable() &#123;  </span><br><span class="line">6.               @Override  </span><br><span class="line">7.               public void run() &#123;  </span><br><span class="line">8.                   try &#123;  </span><br><span class="line">9.                       Thread.sleep(10);  </span><br><span class="line">10.                   &#125; catch (Exception e) &#123;  </span><br><span class="line">11.                       e.printStackTrace();  </span><br><span class="line">12.                   &#125;  </span><br><span class="line">13.                   &#x2F;&#x2F;每个线程让count自增100次  </span><br><span class="line">14.                   for (int i &#x3D; 0; i &lt; 100; i++) &#123;  </span><br><span class="line">15.                       count++;  </span><br><span class="line">16.                   &#125;  </span><br><span class="line">17.               &#125;  </span><br><span class="line">18.           &#125;).start();  </span><br><span class="line">19.       &#125;  </span><br><span class="line">20.  </span><br><span class="line">21.       try&#123;  </span><br><span class="line">22.           Thread.sleep(2000);  </span><br><span class="line">23.       &#125;catch (Exception e)&#123;  </span><br><span class="line">24.           e.printStackTrace();  </span><br><span class="line">25.       &#125;  </span><br><span class="line">26.       System.out.println(count);  </span><br><span class="line">27.   &#125;</span><br></pre></td></tr></table></figure><p>请问cout的输出值是否为200？答案是否定的，因为这个程序是线程不安全的，所以造成的结果count值可能小于200;</p><p>那么如何改造成线程安全的呢，其实我们可以使用上Synchronized同步锁,我们只需要在count++的位置添加同步锁，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.private static int count &#x3D; 0;  </span><br><span class="line">2.  </span><br><span class="line">3.    public static void main(String[] args) &#123;  </span><br><span class="line">4.        for (int i &#x3D; 0; i &lt; 2; i++) &#123;  </span><br><span class="line">5.            new Thread(new Runnable() &#123;  </span><br><span class="line">6.                @Override  </span><br><span class="line">7.                public void run() &#123;  </span><br><span class="line">8.                    try &#123;  </span><br><span class="line">9.                        Thread.sleep(10);  </span><br><span class="line">10.                    &#125; catch (Exception e) &#123;  </span><br><span class="line">11.                        e.printStackTrace();  </span><br><span class="line">12.                    &#125;  </span><br><span class="line">13.                    &#x2F;&#x2F;每个线程让count自增100次  </span><br><span class="line">14.                    for (int i &#x3D; 0; i &lt; 100; i++) &#123;  </span><br><span class="line">15.                        synchronized (ThreadCas.class)&#123;  </span><br><span class="line">16.                            count++;  </span><br><span class="line">17.                        &#125;  </span><br><span class="line">18.                    &#125;  </span><br><span class="line">19.                &#125;  </span><br><span class="line">20.            &#125;).start();  </span><br><span class="line">21.        &#125;  </span><br><span class="line">22.  </span><br><span class="line">23.        try&#123;  </span><br><span class="line">24.            Thread.sleep(2000);  </span><br><span class="line">25.        &#125;catch (Exception e)&#123;  </span><br><span class="line">26.            e.printStackTrace();  </span><br><span class="line">27.        &#125;  </span><br><span class="line">28.        System.out.println(count);  </span><br><span class="line">29.    &#125;</span><br></pre></td></tr></table></figure><p>加了同步锁之后，count自增的操作变成了原子性操作，所以最终的输出一定是count=200，代码实现了线程安全。</p><p>但是Synchronized虽然确保了线程的安全，但是在性能上却不是最优的，Synchronized关键字会让没有得到锁资源的线程进入BLOCKED状态，而后在争夺到锁资源后恢复为RUNNABLE状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。</p><p>尽管Java1.6为Synchronized做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度，但是在最终转变为重量级锁之后，性能仍然较低。</p><p>所谓原子操作类，指的是java.util.concurrent.atomic包下，一系列以Atomic开头的包装类。例如AtomicBoolean，AtomicInteger，AtomicLong。它们分别用于Boolean，Integer，Long类型的原子性操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.private static AtomicInteger count &#x3D; new AtomicInteger(0);  </span><br><span class="line">2.  </span><br><span class="line">3.public static void main(String[] args) &#123;  </span><br><span class="line">4.    for (int i &#x3D; 0; i &lt; 2; i++) &#123;  </span><br><span class="line">5.        new Thread(new Runnable() &#123;  </span><br><span class="line">6.            @Override  </span><br><span class="line">7.            public void run() &#123;  </span><br><span class="line">8.                try &#123;  </span><br><span class="line">9.                    Thread.sleep(10);  </span><br><span class="line">10.                &#125; catch (Exception e) &#123;  </span><br><span class="line">11.                    e.printStackTrace();  </span><br><span class="line">12.                &#125;  </span><br><span class="line">13.                &#x2F;&#x2F;每个线程让count自增100次  </span><br><span class="line">14.                for (int i &#x3D; 0; i &lt; 100; i++) &#123;  </span><br><span class="line">15.                    count.incrementAndGet();  </span><br><span class="line">16.                &#125;  </span><br><span class="line">17.            &#125;  </span><br><span class="line">18.        &#125;).start();  </span><br><span class="line">19.    &#125;  </span><br><span class="line">20.  </span><br><span class="line">21.    try&#123;  </span><br><span class="line">22.        Thread.sleep(2000);  </span><br><span class="line">23.    &#125;catch (Exception e)&#123;  </span><br><span class="line">24.        e.printStackTrace();  </span><br><span class="line">25.    &#125;  </span><br><span class="line">26.    System.out.println(count);  </span><br><span class="line">27.&#125;</span><br></pre></td></tr></table></figure><p>使用AtomicInteger之后，最终的输出结果同样可以保证是200。并且在某些情况下，代码的性能会比Synchronized更好。</p><p>而Atomic操作的底层实现正是利用的CAS机制，好的，我们切入到这个博客的正点。</p><h1 id="1-什么是CAS机制"><a href="#1-什么是CAS机制" class="headerlink" title="1.什么是CAS机制"></a>1.什么是CAS机制</h1><p>CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。</p><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p><p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p><p>这样说或许有些抽象，我们来看一个例子：</p><p>1.在内存地址V当中，存储着值为10的变量。</p><p><img src="dxc-cas.assets/image-20200528232719629.png" alt="image-20200528232719629"></p><p>2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。</p><p><img src="dxc-cas.assets/image-20200528232743294.png" alt="image-20200528232743294"></p><p>3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</p><p><img src="dxc-cas.assets/image-20200528232801348.png" alt="image-20200528232801348"></p><p>4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。</p><p><img src="dxc-cas.assets/image-20200528232844170.png" alt="image-20200528232844170"></p><p>5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋</p><p><img src="dxc-cas.assets/image-20200528232902372.png" alt="image-20200528232902372"></p><p>6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。</p><p><img src="dxc-cas.assets/image-20200528232917312.png" alt="image-20200528232917312"></p><p>7.线程1进行SWAP，把地址V的值替换为B，也就是12</p><p><img src="dxc-cas.assets/image-20200528232933270.png" alt="image-20200528232933270"></p><p>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p><p>看到上面的解释是不是索然无味，查找了很多资料也没完全弄明白，通过几次验证后，终于明白，最终可以理解成一个无阻塞多线程争抢资源的模型。先上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicBoolean;    </span><br><span class="line">public class AtomicBooleanTest implements Runnable &#123;    </span><br><span class="line">    </span><br><span class="line">    private static AtomicBoolean flag &#x3D; new AtomicBoolean(true);    </span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;    </span><br><span class="line">        AtomicBooleanTest ast &#x3D; new AtomicBooleanTest();    </span><br><span class="line">        Thread thread1 &#x3D; new Thread(ast);    </span><br><span class="line">        Thread thread &#x3D; new Thread(ast);    </span><br><span class="line">        thread1.start();    </span><br><span class="line">        thread.start();    </span><br><span class="line">    &#125;    </span><br><span class="line">    @Override    </span><br><span class="line">    public void run() &#123;    </span><br><span class="line">        System.out.println(&quot;thread:&quot;+Thread.currentThread().getName()+&quot;;flag:&quot;+flag.get());    </span><br><span class="line">        if (flag.compareAndSet(true,false))&#123;    </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;&quot;+flag.get());    </span><br><span class="line">            try &#123;    </span><br><span class="line">                Thread.sleep(5000);    </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;    </span><br><span class="line">                e.printStackTrace();    </span><br><span class="line">            &#125;    </span><br><span class="line">            flag.set(true);    </span><br><span class="line">        &#125;else&#123;    </span><br><span class="line">System.out.println(&quot;重试机制thread:&quot;+Thread.currentThread().getName()+&quot;;flag:&quot;+flag.get());    </span><br><span class="line">            try &#123;    </span><br><span class="line">                Thread.sleep(500);    </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;    </span><br><span class="line">                e.printStackTrace();    </span><br><span class="line">            &#125;    </span><br><span class="line">            run();    </span><br><span class="line">        &#125;    </span><br><span class="line">    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.thread:Thread-1;flag:true  </span><br><span class="line">2.thread:Thread-0;flag:true  </span><br><span class="line">3.Thread-1false  </span><br><span class="line">4.重试机制thread:Thread-0;flag:false  </span><br><span class="line">5.thread:Thread-0;flag:false  </span><br><span class="line">6.重试机制thread:Thread-0;flag:false  </span><br><span class="line">7.thread:Thread-0;flag:false  </span><br><span class="line">8.重试机制thread:Thread-0;flag:false  </span><br><span class="line">9.thread:Thread-0;flag:false  </span><br><span class="line">10.重试机制thread:Thread-0;flag:false  </span><br><span class="line">11.thread:Thread-0;flag:false  </span><br><span class="line">12.重试机制thread:Thread-0;flag:false  </span><br><span class="line">13.thread:Thread-0;flag:false  </span><br><span class="line">14.重试机制thread:Thread-0;flag:false  </span><br><span class="line">15.thread:Thread-0;flag:false  </span><br><span class="line">16.重试机制thread:Thread-0;flag:false  </span><br><span class="line">17.thread:Thread-0;flag:false  </span><br><span class="line">18.重试机制thread:Thread-0;flag:false  </span><br><span class="line">19.thread:Thread-0;flag:false  </span><br><span class="line">20.重试机制thread:Thread-0;flag:false  </span><br><span class="line">21.thread:Thread-0;flag:false  </span><br><span class="line">22.重试机制thread:Thread-0;flag:false  </span><br><span class="line">23.thread:Thread-0;flag:true  </span><br><span class="line">24.Thread-0false</span><br></pre></td></tr></table></figure><p>这里无论怎么运行，Thread-1、Thread-0都会执行if=true条件，而且还不会产生线程脏读脏写，这是如何做到的了，这就用到了我们的compareAndSet(boolean expect,boolean update)方法<br>我们看到当Thread-1在进行操作的时候，Thread一直在进行重试机制，程序原理图:</p><p><img src="dxc-cas.assets/image-20200528233056168.png" alt="image-20200528233056168"></p><p>这个图中重最要的是compareAndSet(true,false)方法要拆开成compare(true)方法和Set(false)方法理解，是compare(true)是等于true后，就马上设置共享内存为false，这个时候，其它线程无论怎么走都无法走到只有得到共享内存为true时的程序隔离方法区。</p><p>看到这里，这种CAS机制就是完美的吗？这个程序其实存在一个问题，不知道大家注意到没有？</p><p>但是这种得不到状态为true时使用递归算法是很耗cpu资源的，所以一般情况下，都会有线程sleep。</p><h1 id="2-CAS的缺点"><a href="#2-CAS的缺点" class="headerlink" title="2.CAS的缺点"></a>2.CAS的缺点</h1><ul><li>ABA问题。当第一个线程执行CAS操作，尚未修改为新值之前，内存中的值已经被其他线程连续修改了两次，使得变量值经历 A -&gt; B -&gt; A的过程。</li></ul><p>l解决方案：添加版本号作为标识，每次修改变量值时，对应增加版本号； 做CAS操作前需要校验版本号。JDK1.5之后，新增AtomicStampedReference类来处理这种情况。</p><ul><li><p>循环时间长开销大。如果有很多个线程并发，CAS自旋可能会长时间不成功，会增大CPU的执行开销。</p></li><li><p>只能对一个变量进原子操作。JDK1.5之后，新增AtomicReference类来处理这种情况，可以将多个变量放到一个对象中。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是悲观锁、乐观锁？在java语言里，总有一些名词看语义跟本不明白是啥玩意儿，也就总有部分面试官拿着这样的词来忽悠面试者，以此来找优越感，其实理解清楚了，这些词也就唬不住人了。
    
    </summary>
    
    
    
      <category term="多线程" scheme="https://dcghx.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM——(1)</title>
    <link href="https://dcghx.github.io/2020/05/09/jvm-1/"/>
    <id>https://dcghx.github.io/2020/05/09/jvm-1/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-29T15:15:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 相比 C/C++ 最显著的特点便是引入了自动垃圾回收<a id="more"></a>(下文统一用 GC 指代自动垃圾回收)，它解决了 C/C++ 最令人头疼的内存管理问题，让程序员专注于程序本身，不用关心内存回收这些恼人的问题，这也是 Java 能大行其道的重要原因之一，GC 真正让程序员的生产力得到了释放，但是程序员很难感知到它的存在，这就好比，我们吃完饭后在桌上放下餐盘即走，服务员会替你收拾好这些餐盘，你不会关心服务员什么时候来收，怎么收。</p><p>有人说既然 GC 已经自动为我们完成了清理,不了解 GC 貌似也没啥问题。在大多数情况下确实没问题，不过如果涉及到一些性能调优，问题排查等，深入地了解 GC 还是必不可少的，曾经美团通过调整 JVM 相关 GC 参数让服务响应时间 TP90，TP99都下降了10ms+，服务可用性得到了很大的提升！所以深入了解 GC 是成为一名优秀 Java 程序员的必修课！</p><h1 id="1-JVM内存区域"><a href="#1-JVM内存区域" class="headerlink" title="1. JVM内存区域"></a>1. JVM内存区域</h1><p>要搞懂垃圾回收的机制，我们首先要知道垃圾回收主要回收的是哪些数据，这些数据主要在哪一块区域，所以我们一起来看下 JVM 的内存区域</p><p><img src="jvm-1.assets/image-20200529223132570.png" alt="image-20200529223132570"></p><ul><li>虚拟机栈：描述的是方法执行时的内存模型,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建栈桢（下文会看到），主要保存执行方法时的局部变量表、操作数栈、动态连接和方法返回地址等信息,方法执行时入栈，方法执行完出栈，出栈就相当于清空了数据，入栈出栈的时机很明确，所以这块区域不需要进行 GC。</li><li>本地方法栈：与虚拟机栈功能非常类似，主要区别在于虚拟机栈为虚拟机执行 Java 方法时服务，而本地方法栈为虚拟机执行本地方法时服务的。这块区域也不需要进行 GC</li><li>程序计数器：线程独有的， 可以把它看作是当前线程执行的字节码的行号指示器，比如如下字节码内容，在每个字节码`前面都有一个数字（行号），我们可以认为它就是程序计数器存储的内容</li></ul><p><img src="jvm-1.assets/image-20200529223245221.png" alt="image-20200529223245221"></p><p>记录这些数字（指令地址）有啥用呢，我们知道 Java 虚拟机的多线程是通过线程轮流切换并分配处理器的时间来完成的，在任何一个时刻，一个处理器只会执行一个线程，如果这个线程被分配的时间片执行完了（线程被挂起），处理器会切换到另外一个线程执行，当下次轮到执行被挂起的线程（唤醒线程）时，怎么知道上次执行到哪了呢，通过记录在程序计数器中的行号指示器即可知道，所以程序计数器的主要作用是记录线程运行时的状态，方便线程被唤醒时能从上一次被挂起时的状态继续执行，需要注意的是，程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域，所以这块区域也不需要进行 GC</p><ul><li><p>本地内存：线程共享区域，Java 8 中，本地内存，也是我们通常说的堆外内存，包含元空间和直接内存,注意到上图中 Java 8 和 Java 8 之前的 JVM 内存区域的区别了吗，在 Java 8 之前有个永久代的概念，实际上指的是 HotSpot 虚拟机上的永久代，它用永久代实现了 JVM 规范定义的方法区功能，主要存储类的信息，常量，静态变量，即时编译器编译后代码等，这部分由于是在堆中实现的，受 GC 的管理，不过由于永久代有 -XX:MaxPermSize 的上限，所以如果动态生成类（将类信息放入永久代）或大量地执行 String.intern （将字段串放入永久代中的常量区），很容易造成 OOM，有人说可以把永久代设置得足够大，但很难确定一个合适的大小，受类数量，常量数量的多少影响很大。所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了,也就不会进行 GC，也因此提升了性能（发生 GC 会发生 Stop The Word,造成性能受到一定影响，后文会提到），也就不存在由于永久代限制大小而导致的 OOM 异常了（假设总内存1G，JVM 被分配内存 100M， 理论上元空间可以分配 2G-100M = 1.9G，空间大小足够），也方便在元空间中统一管理。综上所述，在 Java 8 以后这一区域也不需要进行 GC</p></li><li><p>堆：前面几块数据区域都不进行 GC，那只剩下堆了，是的，这里是 GC 发生的区域！对象实例和数组都是在堆上分配的，GC 也主要对这两类数据进行回收，这块也是我们之后重点需要分析的区域</p></li></ul><h1 id="2-如何识别垃圾"><a href="#2-如何识别垃圾" class="headerlink" title="2. 如何识别垃圾"></a>2. 如何识别垃圾</h1><p>上一节我们详细讲述了 JVM 的内存区域，知道了 GC 主要发生在堆，那么 GC 该怎么判断堆中的对象实例或数据是不是垃圾呢，或者说判断某些数据是否是垃圾的方法有哪些。</p><h2 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h2><p>最容易想到的一种方式是引用计数法，啥叫引用计数法，简单地说，就是对象被引用一次，在它的对象头上加一次引用次数，如果没有被引用（引用次数为 0），则此对象可回收</p><p><img src="jvm-1.assets/image-20200529223531516.png" alt="image-20200529223531516"></p><p>以上代码 ref 引用了右侧定义的对象，所以引用次数是 1</p><p><img src="jvm-1.assets/image-20200529223543486.png" alt="image-20200529223543486"></p><p>如果在上述代码后面添加一个 ref = null，则由于对象没被引用，引用次数置为 0，由于不被任何变量引用，此时即被回收，动图如</p><p><img src="jvm-1.assets/1.gif" alt=""></p><p>看起来用引用计数确实没啥问题了，不过它无法解决一个主要的问题：循环引用！啥叫循环引用</p><p><img src="jvm-1.assets/image-20200529223801717.png" alt="image-20200529223801717"></p><p>按步骤一步步画图</p><p><img src="jvm-1.assets/image-20200529223818981.png" alt="image-20200529223818981"></p><p>到了第三步，虽然 a，b 都被置为 null 了，但是由于之前它们指向的对象互相指向了对方（引用计数都为 1），所以无法回收，也正是由于无法解决循环引用的问题，所以现代虚拟机都不用引用计数法来判断对象是否应该被回收。</p><h2 id="2-2-可达性算法"><a href="#2-2-可达性算法" class="headerlink" title="2.2 可达性算法"></a>2.2 可达性算法</h2><p>现代虚拟机基本都是采用这种算法来判断对象是否存活，可达性算法的原理是以一系列叫做 GC Root 的对象为起点出发，引出它们指向的下一个节点，再以下个节点为起点，引出此节点指向的下一个结点。。。（这样通过 GC Root 串成的一条线就叫引用链），直到所有的结点都遍历完毕,如果相关对象不在任意一个以 GC Root 为起点的引用链中，则这些对象会被判断为「垃圾」,会被 GC 回收。</p><p><img src="jvm-1.assets/image-20200529223913887.png" alt="image-20200529223913887"></p><p>如图示，用可达性算法即可解决上述循环引用的问题，因为从GC Root 出发没有到达 a,b,所以 a，b 可回收</p><p>a, b 对象可回收，就一定会被回收吗?并不是，对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收！</p><p>注意： finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记!</p><p>那么这些 GC Roots 到底是什么东西呢，哪些对象可以作为 GC Root 呢，有以下几类</p><ul><li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</p></li></ul><h3 id="2-2-1-虚拟机栈中的引用对象"><a href="#2-2-1-虚拟机栈中的引用对象" class="headerlink" title="2.2.1 虚拟机栈中的引用对象"></a>2.2.1 虚拟机栈中的引用对象</h3><p>如下代码所示，a 是栈帧中的本地变量，当 a = null 时，由于此时 a 充当了 GC Root 的作用，a 与原来指向的实例 new Test() 断开了连接，所以对象会被回收。</p><p><img src="jvm-1.assets/image-20200529224054484.png" alt="image-20200529224054484"></p><h3 id="2-2-2方法区中类静态属性引用的对象"><a href="#2-2-2方法区中类静态属性引用的对象" class="headerlink" title="2.2.2方法区中类静态属性引用的对象"></a>2.2.2方法区中类静态属性引用的对象</h3><p>如下代码所示，当栈帧中的本地变量 a = null 时，由于 a 原来指向的对象与 GC Root (变量 a) 断开了连接，所以 a 原来指向的对象会被回收，而由于我们给 s 赋值了变量的引用，s 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活!</p><p><img src="jvm-1.assets/image-20200529224153794.png" alt="image-20200529224153794"></p><h3 id="2-2-3-方法区中常量引用的对象"><a href="#2-2-3-方法区中常量引用的对象" class="headerlink" title="2.2.3 方法区中常量引用的对象"></a>2.2.3 方法区中常量引用的对象</h3><p>如下代码所示，常量 s 指向的对象并不会因为 a 指向的对象被回收而回收</p><p><img src="jvm-1.assets/image-20200529224252734.png" alt="image-20200529224252734"></p><h3 id="2-2-4-本地方法栈中-JNI-引用的对象"><a href="#2-2-4-本地方法栈中-JNI-引用的对象" class="headerlink" title="2.2.4 本地方法栈中 JNI 引用的对象"></a>2.2.4 本地方法栈中 JNI 引用的对象</h3><p>这是简单给不清楚本地方法为何物的童鞋简单解释一下：所谓本地方法就是一个 java 调用非 java 代码的接口，该方法并非 Java 实现的，可能由 C 或 Python等其他语言实现的， Java 通过 JNI 来调用本地方法， 而本地方法是以库文件的形式存放的（在 WINDOWS 平台上是 DLL 文件形式，在 UNIX 机器上是 SO 文件形式）。通过调用本地的库文件的内部方法，使 JAVA 可以实现和本地机器的紧密联系，调用系统级的各接口方法，还是不明白？见文末参考，对本地方法定义与使用有详细介绍。</p><p>当调用 Java 方法时，虚拟机会创建一个栈桢并压入 Java 栈，而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不会在 Java 栈祯中压入新的祯，虚拟机只是简单地动态连接并直接调用指定的本地方法。</p><p><img src="jvm-1.assets/image-20200529224353825.png" alt="image-20200529224353825"></p><p><img src="jvm-1.assets/image-20200529224405686.png" alt="image-20200529224405686"></p><p>如上代码所示，当 java 调用以上本地方法时，jc 会被本地方法栈压入栈中, jc 就是我们说的本地方法栈中 JNI 的对象引用，因此只会在此本地方法执行完成后才会被释放。</p><h1 id="3-垃圾回收主要方法"><a href="#3-垃圾回收主要方法" class="headerlink" title="3. 垃圾回收主要方法"></a>3. 垃圾回收主要方法</h1><p>上一节我们知道了可以通过可达性算法来识别哪些数据是垃圾，那该怎么对这些垃圾进行回收呢。主要有以下几种方式方式:标记清除算法、复制算法、标记整理法、分代收集算法</p><h2 id="3-1-标记清除法"><a href="#3-1-标记清除法" class="headerlink" title="3.1 标记清除法"></a>3.1 标记清除法</h2><p>步骤很简单</p><p>1) 先根据可达性算法标记出相应的可回收对象（图中黄色部分）</p><p>2) 对可回收的对象进行回收</p><p><img src="jvm-1.assets/image-20200529224620333.png" alt="image-20200529224620333"></p><p>操作起来确实很简单，也不用做移动数据的操作，那有啥问题呢？仔细看上图，没错，内存碎片！假如我们想在上图中的堆中分配一块需要连续内存占用 4M 或 5M 的区域，显然是会失败，怎么解决呢，如果能把上面未使用的 2M， 2M，1M 内存能连起来就能连成一片可用空间为 5M 的区域即可，怎么做呢?</p><h2 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h2><p>把堆等分成两块区域, A 和 B，区域 A 负责分配对象，区域 B 不分配, 对区域 A 使用以上所说的标记法把存活的对象标记出来（下图有误无需清除），然后把区域 A 中存活的对象都复制到区域 B（存活对象都依次紧邻排列）最后把 A 区对象全部清理掉释放出空间，这样就解决了内存碎片的问题了。</p><p><img src="jvm-1.assets/image-20200529224717578.png" alt="image-20200529224717578"></p><p>不过复制算法的缺点很明显，比如给堆分配了 500M 内存，结果只有 250M 可用，空间平白无故减少了一半！这肯定是不能接受的！另外每次回收也要把存活对象移动到另一半，效率低下（我们可以想想删除数组元素再把非删除的元素往一端移，效率显然堪忧）</p><h2 id="3-3-标记整理"><a href="#3-3-标记整理" class="headerlink" title="3.3 标记整理"></a>3.3 标记整理</h2><p>前面两步和标记清除法一样，不同的是它在标记清除法的基础上添加了一个整理的过程 ，即将所有的存活对象都往一端移动,紧邻排列（如图示），再清理掉另一端的所有区域，这样的话就解决了内存碎片的问题。</p><p><img src="jvm-1.assets/image-20200529224810281.png" alt="image-20200529224810281"></p><p>但是缺点也很明显：每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下。</p><h2 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h2><p>分代收集算法整合了以上算法，综合了这些算法的优点，最大程度避免了它们的缺点，所以是现代虚拟机采用的首选算法,与其说它是算法，倒不是说它是一种策略，因为它是把上述几种算法整合在了一起，为啥需要分代收集呢，来看一下对象的分配有啥规律</p><p><img src="jvm-1.assets/image-20200529225009030.png" alt="image-20200529225009030"></p><p>如图示：纵轴代表已分配的字节，而横轴代表程序运行时间</p><p>由图可知，大部分的对象都很短命，都在很短的时间内都被回收了（IBM 专业研究表明，一般来说，98% 的对象都是朝生夕死的，经过一次 Minor GC 后就会被回收），所以分代收集算法根据对象存活周期的不同将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),三者的比例为 8: 1 : 1，这样就可以根据新老生代的特点选择最合适的垃圾回收算法，我们把新生代发生的 GC 称为 Young GC（也叫 Minor GC）,老年代发生的 GC 称为 Old GC（也称为 Full GC）。</p><p><img src="jvm-1.assets/image-20200529225029114.png" alt="image-20200529225029114"></p><p>画外音：思考一下，新生代为啥要分这么多区？</p><p>那么分代垃圾收集是怎么工作的呢，我们一起来看看分代收集原理</p><h3 id="3-4-1-对象在新生代的分配与回收"><a href="#3-4-1-对象在新生代的分配与回收" class="headerlink" title="3.4.1 对象在新生代的分配与回收"></a>3.4.1 对象在新生代的分配与回收</h3><p>由以上的分析可知，大部分对象在很短的时间内都会被回收，对象一般分配在 Eden 区</p><p><img src="jvm-1.assets/image-20200529225506621.png" alt="image-20200529225506621"></p><p>当 Eden 区将满时，触发 Minor GC</p><p><img src="jvm-1.assets/image-20200529225523964.png" alt="image-20200529225523964"></p><p>我们之前怎么说来着，大部分对象在短时间内都会被回收, 所以经过 Minor GC 后只有少部分对象会存活，它们会被移到 S0 区（这就是为啥空间大小 Eden: S0: S1 = 8:1:1, Eden 区远大于 S0,S1 的原因，因为在 Eden 区触发的 Minor GC 把大部对象（接近98%）都回收了,只留下少量存活的对象，此时把它们移到 S0 或 S1 绰绰有余）同时对象年龄加一（对象的年龄即发生 Minor GC 的次数），最后把 Eden 区对象全部清理以释放出空间。</p><p><img src="jvm-1.assets/2.gif" alt=""></p><p>当触发下一次 Minor GC 时，会把 Eden 区的存活对象和 S0（或S1） 中的存活对象（S0 或 S1 中的存活对象经过每次 Minor GC 都可能被回收）一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。</p><p><img src="jvm-1.assets/3.gif" alt=""></p><p>若再触发下一次 Minor GC，则重复上一步，只不过此时变成了 从 Eden，S1 区将存活对象复制到 S0 区,每次垃圾回收, S0, S1 角色互换，都是从 Eden ,S0(或S1) 将存活对象移动到 S1(或S0)。也就是说在 Eden 区的垃圾回收我们采用的是复制算法，因为在 Eden 区分配的对象大部分在 Minor GC 后都消亡了，只剩下极少部分存活对象（这也是为啥 Eden:S0:S1 默认为 8:1:1 的原因），S0,S1 区域也比较小，所以最大限度地降低了复制算法造成的对象频繁拷贝带来的开销。</p><h3 id="3-4-2-对象何时晋升老年代"><a href="#3-4-2-对象何时晋升老年代" class="headerlink" title="3.4.2 对象何时晋升老年代"></a>3.4.2 对象何时晋升老年代</h3><ul><li>阈值：当对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代</li></ul><p><img src="jvm-1.assets/4.gif" alt=""></p><p>如图示：年龄阈值设置为 15， 当发生下一次 Minor GC 时，S0 中有个对象年龄达到 15，达到我们的设定阈值，晋升到老年代！</p><ul><li><p>大对象：当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代，因为如果把大对象分配在 Eden 区, Minor GC 后再移动到 S0,S1 会有很大的开销（对象比较大，复制会比较慢，也占空间），也很快会占满 S0,S1 区，所以干脆就直接移到老年代.</p></li><li><p>还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。</p></li></ul><h3 id="3-4-3-空间分配担保"><a href="#3-4-3-空间分配担保" class="headerlink" title="3.4.3 空间分配担保"></a>3.4.3 空间分配担保</h3><p>在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。</p><h3 id="3-4-4-Stop-The-World"><a href="#3-4-4-Stop-The-World" class="headerlink" title="3.4.4 Stop The World"></a>3.4.4 Stop The World</h3><p>如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。</p><p>什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。</p><p><img src="jvm-1.assets/image-20200529225922032.png" alt="image-20200529225922032"></p><p><strong>画外音：为啥在垃圾收集期间其他工作线程会被挂起？想象一下，你一边在收垃圾，另外一群人一边丢垃圾，垃圾能收拾干净吗。</strong></p><p>一般 Full GC 会导致工作线程停顿时间过长（因为Full GC 会清理整个堆中的不可用对象，一般要花较长的时间），如果在此 server 收到了很多请求，则会被拒绝服务！所以我们要尽量减少 Full GC（Minor GC 也会造成 STW,但只会触发轻微的 STW,因为 Eden 区的对象大部分都被回收了，只有极少数存活对象会通过复制算法转移到 S0 或 S1 区，所以相对还好）。</p><p>现在我们应该明白把新生代设置成 Eden, S0，S1区或者给对象设置年龄阈值或者默认把新生代与老年代的空间大小设置成 1:2 都是为了尽可能地避免对象过早地进入老年代，尽可能晚地触发 Full GC。想想新生代如果只设置 Eden 会发生什么，后果就是每经过一次 Minor GC，存活对象会过早地进入老年代，那么老年代很快就会装满，很快会触发 Full GC，而对象其实在经过两三次的 Minor GC 后大部分都会消亡，所以有了 S0,S1的缓冲，只有少数的对象会进入老年代，老年代大小也就不会这么快地增长，也就避免了过早地触发 Full GC。</p><p>由于 Full GC（或Minor GC） 会影响性能，所以我们要在一个合适的时间点发起 GC，这个时间点被称为 Safe Point，这个时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷。一般当线程在这个时间点上状态是可以确定的，如确定 GC Root 的信息等，可以使 JVM 开始安全地 GC。Safe Point 主要指的是以下特定位置：</p><ul><li><p>循环的末尾</p></li><li><p>方法返回前</p></li><li><p>调用方法的 call 之后</p></li><li><p>抛出异常的位置 另外需要注意的是由于新生代的特点（大部分对象经过 Minor GC后会消亡）， Minor GC 用的是复制算法，而在老生代由于对象比较多，占用的空间较大，使用复制算法会有较大开销（复制算法在对象存活率较高时要进行多次复制操作，同时浪费一半空间）所以根据老生代特点，在老年代进行的 GC 一般采用的是标记整理法来进行回收。</p></li></ul><h1 id="4-垃圾收集器种类"><a href="#4-垃圾收集器种类" class="headerlink" title="4. 垃圾收集器种类"></a>4. 垃圾收集器种类</h1><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范并没有规定垃圾收集器应该如何实现，因此一般来说不同厂商，不同版本的虚拟机提供的垃圾收集器实现可能会有差别，一般会给出参数来让用户根据应用的特点来组合各个年代使用的收集器，主要有以下垃圾收集器</p><p><img src="jvm-1.assets/image-20200529230043106.png" alt="image-20200529230043106"></p><ul><li><p>在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge</p></li><li><p>在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old</p></li><li><p>同时在新老生代工作的垃圾回收器：G1</p></li></ul><p>图片中的垃圾收集器如果存在连线，则代表它们之间可以配合使用，接下来我们来看看各个垃圾收集器的具体功能。</p><h2 id="4-1新生代收集器"><a href="#4-1新生代收集器" class="headerlink" title="4.1新生代收集器"></a>4.1新生代收集器</h2><h3 id="4-1-1-Serial-收集器"><a href="#4-1-1-Serial-收集器" class="headerlink" title="4.1.1 Serial 收集器"></a>4.1.1 Serial 收集器</h3><p>Serial 收集器是工作在新生代的，单线程的垃圾收集器，单线程意味着它只会使用一个 CPU 或一个收集线程来完成垃圾回收，不仅如此，还记得我们上文提到的 STW 了吗，它在进行垃圾收集时，其他用户线程会暂停，直到垃圾收集结束，也就是说在 GC 期间，此时的应用不可用。</p><p>看起来单线程垃圾收集器不太实用，不过我们需要知道的任何技术的使用都不能脱离场景，在Client 模式下，它简单有效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 单线程模式无需与其他线程交互，减少了开销，专心做 GC 能将其单线程的优势发挥到极致，另外在用户的桌面应用场景，分配给虚拟机的内存一般不会很大，收集几十甚至一两百兆（仅是新生代的内存，桌面应用基本不会再大了），STW 时间可以控制在一百多毫秒内，只要不是频繁发生，这点停顿是可以接受的，所以对于运行在 Client 模式下的虚拟机，Serial 收集器是新生代的默认收集器</p><h2 id="4-1-2-ParNew-收集器"><a href="#4-1-2-ParNew-收集器" class="headerlink" title="4.1.2  ParNew 收集器"></a>4.1.2  ParNew 收集器</h2><p>ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程，其他像收集算法,STW,对象分配规则，回收策略与 Serial 收集器完成一样，在底层上，这两种收集器也共用了相当多的代码，它的垃圾收集过程如下</p><p><img src="jvm-1.assets/image-20200529230244108.png" alt="image-20200529230244108"></p><p>ParNew 主要工作在 Server 模式，我们知道服务端如果接收的请求多了，响应时间就很重要了，多线程可以让垃圾回收得更快，也就是减少了 STW 时间，能提升响应时间，所以是许多运行在 Server 模式下的虚拟机的首选新生代收集器，另一个与性能无关的原因是因为除了 Serial  收集器，只有它能与 CMS 收集器配合工作，CMS 是一个划时代的垃圾收集器，是真正意义上的并发收集器，它第一次实现了垃圾收集线程与用户线程（基本上）同时工作，它采用的是传统的 GC 收集器代码框架，与 Serial,ParNew 共用一套代码框架，所以能与这两者一起配合工作，而后文提到的 Parallel Scavenge 与 G1 收集器没有使用传统的 GC 收集器代码框架，而是另起炉灶独立实现的，另外一些收集器则只是共用了部分的框架代码,所以无法与 CMS 收集器一起配合工作。</p><p>在多 CPU 的情况下，由于 ParNew 的多线程回收特性，毫无疑问垃圾收集会更快，也能有效地减少 STW 的时间，提升应用的响应速度。</p><h3 id="4-1-3-Parallel-Scavenge-收集器"><a href="#4-1-3-Parallel-Scavenge-收集器" class="headerlink" title="4.1.3 Parallel Scavenge 收集器"></a>4.1.3 Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是一个使用复制算法，多线程，工作于新生代的垃圾收集器，看起来功能和 ParNew 收集器一样，它有啥特别之处吗</p><p>关注点不同，CMS 等垃圾收集器关注的是尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 目标是达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）），也就是说 CMS 等垃圾收集器更适合用到与用户交互的程序，因为停顿时间越短，用户体验越好，而 Parallel Scavenge 收集器关注的是吞吐量，所以更适合做后台运算等不需要太多用户交互的任务。</p><p>Parallel Scavenge 收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集时间的 -XX:MaxGCPauseMillis 参数及直接设置吞吐量大小的 -XX:GCTimeRatio（默认99%）</p><p>除了以上两个参数，还可以用 Parallel Scavenge 收集器提供的第三个参数 -XX:UseAdaptiveSizePolicy，开启这个参数后，就不需要手工指定新生代大小,Eden 与 Survivor 比例（SurvivorRatio）等细节，只需要设置好基本的堆大小（-Xmx 设置最大堆）,以及最大垃圾收集时间与吞吐量大小，虚拟机就会根据当前系统运行情况收集监控信息，动态调整这些参数以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标。自适应策略也是 Parallel Scavenge  与 ParNew 的重要区别！</p><h2 id="4-2-老年代收集器"><a href="#4-2-老年代收集器" class="headerlink" title="4.2 老年代收集器"></a>4.2 老年代收集器</h2><h3 id="4-2-1-Serial-Old-收集器"><a href="#4-2-1-Serial-Old-收集器" class="headerlink" title="4.2.1 Serial Old 收集器"></a>4.2.1 Serial Old 收集器</h3><p>上文我们知道， Serial 收集器是工作于新生代的单线程收集器，与之相对地，Serial Old 是工作于老年代的单线程收集器，此收集器的主要意义在于给 Client 模式下的虚拟机使用，如果在 Server 模式下，则它还有两大用途：一种是在 JDK 1.5 及之前的版本中与 Parallel Scavenge 配合使用，另一种是作为 CMS 收集器的后备预案,在并发收集发生 Concurrent Mode Failure 时使用（后文讲述）,它与 Serial 收集器配合使用示意图如下</p><p><img src="jvm-1.assets/image-20200529230707616.png" alt="image-20200529230707616"></p><h3 id="4-2-2-Parallel-Old-收集器"><a href="#4-2-2-Parallel-Old-收集器" class="headerlink" title="4.2.2 Parallel Old 收集器"></a>4.2.2 Parallel Old 收集器</h3><p>Parallel Old 是相对于 Parallel Scavenge 收集器的老年代版本，使用多线程和标记整理法，两者组合示意图如下,这两者的组合由于都是多线程收集器，真正实现了「吞吐量优先」的目标</p><p><img src="jvm-1.assets/image-20200529230746994.png" alt="image-20200529230746994"></p><h3 id="4-2-3-CMS-收集器"><a href="#4-2-3-CMS-收集器" class="headerlink" title="4.2.3 CMS 收集器"></a>4.2.3 CMS 收集器</h3><p>CMS 收集器是以实现最短 STW 时间为目标的收集器，如果应用很重视服务的响应速度，希望给用户最好的体验，则 CMS 收集器是个很不错的选择！</p><p>我们之前说老年代主要用标记整理法，而 CMS 虽然工作于老年代，但采用的是标记清除法，主要有以下四个步骤</p><p>初始标记—&gt;并发标记—&gt;重新标记—&gt;并发清除</p><p><img src="jvm-1.assets/image-20200529230827055.png" alt="image-20200529230827055"></p><p>从图中可以的看到初始标记和重新标记两个阶段会发生 STW，造成用户线程挂起，不过初始标记仅标记 GC Roots 能关联的对象，速度很快，并发标记是进行 GC Roots  Tracing 的过程，重新标记是为了修正并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，这一阶段停顿时间一般比初始标记阶段稍长，但远比并发标记时间短。</p><p>整个过程中耗时最长的是并发标记和标记清理，不过这两个阶段用户线程都可工作，所以不影响应用的正常使用，所以总体上看，可以认为 CMS 收集器的内存回收过程是与用户线程一起并发执行的。</p><p>但 CMS 收集器远达不到完美的程度，主要有以下三个缺点</p><ul><li><p>CMS 收集器对 CPU 资源非常敏感  原因也可以理解，比如本来我本来可以有 10 个用户线程处理请求，现在却要分出 3 个作为回收线程，吞吐量下降了30%，CMS 默认启动的回收线程数是 （CPU数量+3）/ 4, 如果 CPU 数量只有一两个，那吞吐量就直接下降 50%,显然是不可接受的</p></li><li><p>CMS 无法处理浮动垃圾（Floating Garbage）,可能出现 「Concurrent Mode Failure」而导致另一次 Full GC 的产生，由于在并发清理阶段用户线程还在运行，所以清理的同时新的垃圾也在不断出现，这部分垃圾只能在下一次 GC 时再清理掉（即浮云垃圾），同时在垃圾收集阶段用户线程也要继续运行，就需要预留足够多的空间要确保用户线程正常执行，这就意味着 CMS 收集器不能像其他收集器一样等老年代满了再使用，JDK 1.5 默认当老年代使用了68%空间后就会被激活，当然这个比例可以通过 -XX:CMSInitiatingOccupancyFraction 来设置，但是如果设置地太高很容易导致在 CMS 运行期间预留的内存无法满足程序要求，会导致 Concurrent Mode Failure 失败，这时会启用 Serial Old 收集器来重新进行老年代的收集，而我们知道 Serial Old 收集器是单线程收集器，这样就会导致 STW 更长了。</p></li><li><p>CMS 采用的是标记清除法，上文我们已经提到这种方法会产生大量的内存碎片，这样会给大内存分配带来很大的麻烦，如果无法找到足够大的连续空间来分配对象，将会触发 Full GC，这会影响应用的性能。当然我们可以开启 -XX:+UseCMSCompactAtFullCollection（默认是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理会导致 STW，停顿时间会变长，还可以用另一个参数 -XX:CMSFullGCsBeforeCompation 用来设置执行多少次不压缩的 Full GC 后跟着带来一次带压缩的。</p></li></ul><h3 id="4-2-4-G1（Garbage-First）-收集器"><a href="#4-2-4-G1（Garbage-First）-收集器" class="headerlink" title="4.2.4  G1（Garbage First） 收集器"></a>4.2.4  G1（Garbage First） 收集器</h3><p>G1收集器是面向服务端的垃圾收集器，被称为驾驭一切的垃圾回收器，有以下几个特点</p><ul><li><p>像 CMS 收集器一样，能与应用程序线程并发执行。</p></li><li><p>整理空闲空间更快。</p></li><li><p>需要 GC 停顿时间更好预测。</p></li><li><p>不会像 CMS 那样牺牲大量的吞吐性能。</p></li><li><p>不需要更大的 Java Heap</p></li></ul><p>与 CMS 相比，它在以下两个方面表现更出色</p><ul><li><p>运作期间不会产生内存碎片，G1 从整体上看采用的是标记-整理法，局部（两个 Region）上看是基于复制算法实现的，两个算法都不会产生内存碎片，收集后提供规整的可用内存，这样有利于程序的长时间运行。</p></li><li><p>在 STW 上建立了可预测的停顿时间模型，用户可以指定期望停顿时间，G1 会将停顿时间控制在用户设定的停顿时间以内。</p></li></ul><p>为什么G1能建立可预测的停顿模型呢，主要原因在于 G1 对堆空间的分配与传统的垃圾收集器不一样，传统的内存分配就像我们前文所述，是连续的，分成新生代，老年代，新生代又分 Eden,S0,S1,如下</p><p><img src="jvm-1.assets/image-20200529231246462.png" alt="image-20200529231246462"></p><p>而 G1 各代的存储地址不是连续的，每一代都使用了 n 个不连续的大小相同的 Region，每个Region占有一块连续的虚拟内存地址，如图示</p><p><img src="jvm-1.assets/image-20200529231310467.png" alt="image-20200529231310467"></p><p>除了和传统的新老生代，幸存区的空间区别，Region还多了一个H，它代表Humongous，这表示这些Region存储的是巨大对象（humongous object，H-obj），即大小大于等于region一半的对象，这样超大对象就直接分配到了老年代，防止了反复拷贝移动。那么 G1 分配成这样有啥好处呢？</p><p>传统的收集器如果发生 Full GC 是对整个堆进行全区域的垃圾收集，而分配成各个 Region 的话，方便 G1 跟踪各个 Region 里垃圾堆积的价值大小（回收所获得的空间大小及回收所需经验值），这样根据价值大小维护一个优先列表，根据允许的收集时间，优先收集回收价值最大的 Region,也就避免了整个老年代的回收，也就减少了 STW 造成的停顿时间。同时由于只收集部分 Region,可就做到了 STW 时间的可控。</p><p>G1 收集器的工作步骤如下</p><ul><li><p>初始标记</p></li><li><p>并发标记</p></li><li><p>最终标记</p></li><li><p>筛选回收</p></li></ul><p><img src="jvm-1.assets/image-20200529231355861.png" alt="image-20200529231355861"></p><p>可以看到整体过程与 CMS 收集器非常类似，筛选阶段会根据各个 Region 的回收价值和成本进行排序，根据用户期望的 GC 停顿时间来制定回收计划。</p><h3 id="4-2-5-总结"><a href="#4-2-5-总结" class="headerlink" title="4.2.5 总结"></a>4.2.5 总结</h3><p>本文简述了垃圾回收的原理与垃圾收集器的种类，相信大家对开头提的一些问题应该有了更深刻的认识，在生产环境中我们要根据不同的场景来选择垃圾收集器组合，如果是运行在桌面环境处于 Client 模式的，则用 Serial + Serial Old 收集器绰绰有余，如果需要响应时间快，用户体验好的，则用 ParNew + CMS 的搭配模式，即使是号称是「驾驭一切」的 G1，也需要根据吞吐量等要求适当调整相应的 JVM 参数，没有最牛的技术，只有最合适的使用场景，切记！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java 相比 C/C++ 最显著的特点便是引入了自动垃圾回收
    
    </summary>
    
    
    
      <category term="JVM" scheme="https://dcghx.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>多线程————synchronized底层原理</title>
    <link href="https://dcghx.github.io/2020/05/09/dxc-synchronized/"/>
    <id>https://dcghx.github.io/2020/05/09/dxc-synchronized/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-28T14:25:47.881Z</updated>
    
    <content type="html"><![CDATA[<p>在java中如果使用了多线程对共享数据进行操作，那无可避免会遇到同步问题。为解决此问题可以使用synchronized对方法或者代码块进行修饰。java代码执行时先编译为.class文件再在JVM上运行，在讲述JVM如何实现synchronized前先了解一下相关准备知识。<a id="more"></a></p><p><img src="dxc-synchronized.assets/image-20200528221527507.png" alt="image-20200528221527507"></p><p>JVM内存结构主要分为三大块：堆、栈和方法区。每个线程都有自己的一个虚拟机栈，栈保存着局部变量以及所有调用的方法的参数和返回值。其他线程无法访问该线程的栈中数据。栈仅能保存基本类型和对象引用，对象是存放在堆中的。堆内存和方法区中的静态变量等数据可以被线程共享，而同步处理针对的正是共享数据。</p><p>上面采用JVM的内存结构来说明共享数据和synchronized的关系其实不太严谨，synchronized是java内存模型封装了底层后提供的一个关键字，针对的是主存和线程的工作内存而言，而JAVA的内存模型是一种抽象概念，并不能和JVM的内存结构相提并论。因为这里讲述的是JVM层面如何实现synchronized，所以就将栈的部分区域数据和线程的工作内存联系起来。</p><p>看下这段代码生成的.class文件，用以了解synchronized对方法和代码块所做的不同处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.class SynchronizedDemo &#123;  </span><br><span class="line">2.  </span><br><span class="line">3.    public synchronized void m() &#123;  </span><br><span class="line">4.        System.out.printf(&quot;WUST&quot;);  </span><br><span class="line">5.    &#125;  </span><br><span class="line">6.  </span><br><span class="line">7.    public void m2() &#123;  </span><br><span class="line">8.        synchronized(this) &#123;  </span><br><span class="line">9.            System.out.printf(&quot;WUST&quot;);  </span><br><span class="line">10.        &#125;  </span><br><span class="line">11.    &#125;  </span><br><span class="line">12.&#125;</span><br></pre></td></tr></table></figure><p>反编译后：</p><p><img src="dxc-synchronized.assets/image-20200528221647533.png" alt="image-20200528221647533"></p><p>synchronized修饰的方法在字节码中添加了一个ACC_SYNCHRONIZED的flags，同步代码块则是在同步代码块前插入monitorenter，在同步代码块结束后插入monitorexit。这两者的处理是分别是这样的：当线程执行到某个方法时，JVM会去检查该方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了那线程会去获取这个对象所对应的monitor对象（每一个对象都有且仅有一个与之对应的monitor对象）,获取成功后才执行方法体，方法执行完再释放monitor对象，在这一期间，任何其他线程都无法获得这个monitor对象。而线程执行同步代码块时遇到的monitorenter和monitorexit指令依赖monitor对象完成。这两者实现的方式本质上无区别，只是方法的同步是一种隐式的方式，不通过字节码实现。</p><p>同步和monitor有关，而monitor则和对象头有关。</p><p>这里讲一下java的对象模型。在java中，万物皆对象，而一个对象Object是一个类Class的实例。对象保存在堆中，而对象引用存放于栈中，JVM为了描述对象的结构设计了一套OOP-Klass Model（基于HotSpot虚拟机），OOP（ordinary object pointer）指的是普通的对象指针，Klass用于描述对象实例的具体类型。虽然JVM基于C++实现，但并不是将java对象直接转换为了C++的对象，这和多态的实现有一定的关系。</p><p>C++中通过虚函数表实现多态，每个包含虚函数的类都有一个虚函数表(virtual table)，虚函数表中排列着按顺序声明的所有虚函数，类对象的地址空间最靠前的位置保存着指向虚函数表的指针。C++在运行时并不维护类型信息，在编译时直接将子类的虚函数表中的虚函数替换为子类重写的方法。</p><p>java在运行时会维护类型信息以及类的继承体系，每一个类会对应方法区中的一个存放类信息的数据结构，可以通过class对象访问此数据结构。其中类型信息superclass属性指示了其超类，还有这个类所对应的方法表。在堆上创建的对象都有一个指向方法区类型信息数据结构的指针，通过这个指针可以确定对象的类型。</p><p>HotSpot设计者将对象模型拆为oop和klass，oop不含任何虚函数，而klass则含有虚函数表。klass是java类在c++中的对等体，一般在JVM加载.class文件时，在方法区中创建instanceKlass表示元数据，包括常量、字段和方法等。Klass主要有两个功能：</p><ul><li><p>实现语言层面的java类</p></li><li><p>实现java对象的分发功能</p></li></ul><p>oop是JVM在运行的过程中遇到new对象时创建的，对象包含对象头、实例数据和填充数据三部分，其中对象头包含两部分：</p><ul><li><p>Mark Word，存储对象运行时记录信息</p></li><li><p>Klass Pointer，即元数据指针，指向方法区的instanceKlass实例</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Model  &#123;  </span><br><span class="line">    public static int a &#x3D; 1;  </span><br><span class="line">    public int b;  </span><br><span class="line">  </span><br><span class="line">    public Model(int b) &#123;  </span><br><span class="line">        this.b &#x3D; b;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">    int c &#x3D; 10;  </span><br><span class="line">    Model modelA &#x3D; new Model(2);  </span><br><span class="line">    Model modelB &#x3D; new Model(3);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="dxc-synchronized.assets/image-20200528221812680.png" alt="image-20200528221812680"></p><p>感受过具体例子后再来看一下oop-klass结构图：</p><p><img src="dxc-synchronized.assets/image-20200528221829509.png" alt="image-20200528221829509"></p><p>在openJdk中的oopsHierarchy.hpp文件中定义了oop和klass体系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义了oops共同的基类  </span><br><span class="line">typedef class oopDesc*                            oop;  </span><br><span class="line">&#x2F;&#x2F; 表示一个java类型实例  </span><br><span class="line">typedef class   instanceOopDesc*            instanceOop;  </span><br><span class="line">&#x2F;&#x2F; 表示java的一个方法  </span><br><span class="line">typedef class   methodOopDesc*                    methodOop;  </span><br><span class="line">&#x2F;&#x2F; 表示java方法中不变的信息  </span><br><span class="line">typedef class   constMethodOopDesc*            constMethodOop;  </span><br><span class="line">&#x2F;&#x2F; 记录性能信息的数据结构  </span><br><span class="line">typedef class   methodDataOopDesc*            methodDataOop;  </span><br><span class="line">&#x2F;&#x2F; 定义了数组OOPS数组  </span><br><span class="line">typedef class   arrayOopDesc*                    arrayOop;  </span><br><span class="line">&#x2F;&#x2F; 表示持有一个OOP数组  </span><br><span class="line">typedef class   objArrayOopDesc*            objArrayOop;  </span><br><span class="line">&#x2F;&#x2F; 表示容纳基本类型的数组  </span><br><span class="line">typedef class   typeArrayOopDesc*            typeArrayOop;  </span><br><span class="line">&#x2F;&#x2F; 表示在Class文件中描述的常量池  </span><br><span class="line">typedef class   constantPoolOopDesc*            constantPoolOop;  </span><br><span class="line">&#x2F;&#x2F; 常量池高速缓存  </span><br><span class="line">typedef class   constantPoolCacheOopDesc*   constantPoolCacheOop;  </span><br><span class="line">&#x2F;&#x2F; 描述一个与JAVA类对等的C++类  </span><br><span class="line">typedef class   klassOopDesc*                    klassOop;  </span><br><span class="line">&#x2F;&#x2F; 表示对象头  </span><br><span class="line">typedef class   markOopDesc*                    markOop;</span><br></pre></td></tr></table></figure><p>程序每创建一个对象时便会在JVM中创建与之相对应的一个OOP对象，instanceOopDesc表示类实例，arrayOopDesc表示数组,它们的基类OopDesc定义在oop.hpp中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.private:  </span><br><span class="line">2.  volatile markOop  _mark;  </span><br><span class="line">3.  union _metadata &#123;  </span><br><span class="line">4.    wideKlassOop    _klass;  </span><br><span class="line">5.    narrowOop       _compressed_klass;  </span><br><span class="line">6.  &#125; _metadata;</span><br></pre></td></tr></table></figure><p>这一段代码表示对象头，_mark指的对象头中的Mark Word,联合体_metadata中的_klass表示未压缩的Klass指针，_compressed_klass表示压缩的Klass指针，这个Klass指针指向一个Klass对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;&#x2F;klassOop的一部分，用来描述语言层的类型  </span><br><span class="line">2.class  Klass;  </span><br><span class="line">3.&#x2F;&#x2F;在虚拟机层面描述一个Java类  </span><br><span class="line">4.class   instanceKlass;  </span><br><span class="line">5.&#x2F;&#x2F;专有instantKlass，表示java.lang.Class的Klass  </span><br><span class="line">6.class     instanceMirrorKlass;  </span><br><span class="line">7.&#x2F;&#x2F;专有instantKlass，表示java.lang.ref.Reference的子类的Klass  </span><br><span class="line">8.class     instanceRefKlass;  </span><br><span class="line">9.&#x2F;&#x2F;表示methodOop的Klass  </span><br><span class="line">10.class   methodKlass;  </span><br><span class="line">11.&#x2F;&#x2F;表示constMethodOop的Klass  </span><br><span class="line">12.class   constMethodKlass;  </span><br><span class="line">13.&#x2F;&#x2F;表示methodDataOop的Klass  </span><br><span class="line">14.class   methodDataKlass;  </span><br><span class="line">15.&#x2F;&#x2F;最为klass链的端点，klassKlass的Klass就是它自身  </span><br><span class="line">16.class   klassKlass;  </span><br><span class="line">17.&#x2F;&#x2F;表示instanceKlass的Klass  </span><br><span class="line">18.class     instanceKlassKlass;  </span><br><span class="line">19.&#x2F;&#x2F;表示arrayKlass的Klass  </span><br><span class="line">20.class     arrayKlassKlass;  </span><br><span class="line">21.&#x2F;&#x2F;表示objArrayKlass的Klass  </span><br><span class="line">22.class       objArrayKlassKlass;  </span><br><span class="line">23.&#x2F;&#x2F;表示typeArrayKlass的Klass  </span><br><span class="line">24.class       typeArrayKlassKlass;  </span><br><span class="line">25.&#x2F;&#x2F;表示array类型的抽象基类  </span><br><span class="line">26.class   arrayKlass;  </span><br><span class="line">27.&#x2F;&#x2F;表示objArrayOop的Klass  </span><br><span class="line">28.class     objArrayKlass;  </span><br><span class="line">29.&#x2F;&#x2F;表示typeArrayOop的Klass  </span><br><span class="line">30.class     typeArrayKlass;  </span><br><span class="line">31.&#x2F;&#x2F;表示constantPoolOop的Klass  </span><br><span class="line">32.class   constantPoolKlass;  </span><br><span class="line">33.&#x2F;&#x2F;表示constantPoolCacheOop的Klass  </span><br><span class="line">34.class   constantPoolCacheKlass;</span><br></pre></td></tr></table></figure><p>JVM会为每个已经加载了的类创建一个instanceKlass，也就是说当编译成.class文件并完成类加载后便会得到一个instanceKlass对象,instanceKlass表示为JVM层的java类。</p><p><img src="dxc-synchronized.assets/image-20200528222020631.png" alt="image-20200528222020631"></p><p>在JVM中，对象存在于内存中的基本形式为oop，对象对应的class也是一个对象，JVM使用klassOop来描述这个class，而klassOop又被klassklass所描述。关于对象和数组链大致如下</p><p><img src="dxc-synchronized.assets/image-20200528222041147.png" alt="image-20200528222041147"></p><p>结合JAVA内存模型，看一下new一个对象所经历的JVM操作：</p><ul><li>判断对象对应的类是否加载、链接和初始化</li></ul><p>JVM首先会根据所给的参数去常量池检查是否有这个类的符号引用，并检查这个符号引用所代表的的类是否被类加载器加载、链接和初始化过。如果没有则进行<a href="http://note.youdao.com/noteshare?id=2a53393ebcbf28d15388ab1ba14135aa&sub=AF6155EAFC3A40B28411C9F64AAF1BDB" target="_blank" rel="noopener">类加载</a>。此阶段JVM会生成instanceKlass对象表示这个类的运行时元数据。</p><ul><li>为对象分配内存</li></ul><p>类加载完成后会在堆中划分一块内存给对象。内存分配根据JAVA堆是否规整分两种方式：</p><ol><li><p>·指针碰撞：如果java堆是规整的，所有使用过的内存放一边，空闲的在另一边，此时会将指针的指示器向空闲的那端移动一段与对象头大小一致的空间。</p></li><li><p>·空闲列表：如果java堆不是规整的，JVM会维持一个列表记录空间的使用情况，分配内存时从列表中查询一个大小足够的内存分配出来，然后更新列表记录。</p></li></ol><ul><li>处理并发安全问题</li></ul><p>创建对象是频繁的动作，需要解决并发问题，有两种方式：</p><ol><li>对分配内存空间的动作进行同步处理，比如采用CAS算法并配上失败重试的方式保证更新操作的原子性。</li><li>每个线程在java堆中预先分配一小块内存，称之为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）当线程需要分配内存时在对应的TLAB上分配，当该TLAB用完再分配新的TLAB是才进行同步操作。是否使用TLAB可通过-XX:+/-UserTLAB参数进行设定。</li></ol><ul><li>初始化分配到的内存空间</li></ul><p>将分配的内存，除了对象头都初始化为0。在此阶段生成instanceOop表示java类的对象，JVM栈中会持有此对象的引用。</p><ul><li><p>设置对象的对象头</p></li><li><p>执行init方法进行初始化</p></li></ul><p>初始化对象的成员变量、调用类的构造方法</p><h1 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h1><p>前面说到monitor与对象头有关，现在分别介绍monitor和对象头（Mark Word）的结构（基于32位JVM）</p><p>monitor意为监视者，每个对象都有一个自己的监视锁。可以把monitor理解为一个特殊建筑物，这个建筑物有走廊(_EntryList)，有等候室（_WaitSet）以及一间只能容纳一个特殊访客的房间(_owner)。可以想象这样一个场景：教父在这间特殊的房子里倾听访客的要求，走廊上排着其他想寻求帮助的客人，还有一间房子是给暂时中断服务的客人等待的。示意图如下：</p><p><img src="dxc-synchronized.assets/image-20200528222326476.png" alt="image-20200528222326476"></p><p>monitor也是一个对象，在C++中由ObjectMonitor实现，其数据结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.ObjectMonitor() &#123;  </span><br><span class="line">2.  _header       &#x3D; NULL;  </span><br><span class="line">3.  _count        &#x3D; 0;  </span><br><span class="line">4.  _waiters      &#x3D; 0,  </span><br><span class="line">5.  _recursions   &#x3D; 0;  </span><br><span class="line">6.  _object       &#x3D; NULL;  </span><br><span class="line">7.  _owner        &#x3D; NULL;  </span><br><span class="line">8.  _WaitSet      &#x3D; NULL;  </span><br><span class="line">9.  _WaitSetLock  &#x3D; 0 ;  </span><br><span class="line">10.  _Responsible  &#x3D; NULL ;  </span><br><span class="line">11.  _succ         &#x3D; NULL ;  </span><br><span class="line">12.  _cxq          &#x3D; NULL ;  </span><br><span class="line">13.  FreeNext      &#x3D; NULL ;  </span><br><span class="line">14.  _EntryList    &#x3D; NULL ;  </span><br><span class="line">15.  _SpinFreq     &#x3D; 0 ;  </span><br><span class="line">16.  _SpinClock    &#x3D; 0 ;  </span><br><span class="line">17.  OwnerIsThread &#x3D; 0 ;  </span><br><span class="line">18.&#125;</span><br></pre></td></tr></table></figure><p>可以关注下几个比较关键的属性：</p><ul><li><p>owner 指向持有ObjectMonitor对象的线程</p></li><li><p>WaitSet 存放处于wait状态的线程</p></li><li><p>EntryList 存放处于等待锁block状态的线程队列</p></li><li><p>recursions 锁的重入次数</p></li><li><p>count 记录该线程获取锁的次数</p></li></ul><p>多个线程在竞争共享数据执行到同步代码块时，会在_EntryList中排队，获得对象monitor的线程在进入_Owner区域时会将monitor的_owner设为当前线程，同时计数器_count加1。若持有mnitor对象的线程调用了wait()方法会释放monitor，_owner为null，计数器_count减一，进入到_WaitSet集合中等待被唤醒。以下是获得锁和释放锁的流程图：</p><p><img src="dxc-synchronized.assets/image-20200528222424116.png" alt="image-20200528222424116"></p><p><img src="dxc-synchronized.assets/image-20200528222431370.png" alt="image-20200528222431370"></p><p>线程获取对象锁的过程并不是简单的设置，而是采用一定的策略，比如当前只有一个线程访问同步代码，则设置偏向锁，避免多次CAS操作，适应性自旋锁则可以减少阻塞导致的线程切换。在jdk1.6之前，调用objectMonitor的enter和exit是和操作系统的互斥量mutex直接映射的，同步操作时无可避免会导致核心态和用户态切换等问题，所以把这种锁称为重量锁。</p><p>在描述为锁优化和锁膨胀技术前，看下和monitor有关的对象头结构：</p><p><img src="dxc-synchronized.assets/image-20200528222447532.png" alt="image-20200528222447532"></p><p>对象头存放着对象的hashCode、锁标志位以及GC分代年龄等信息。由图中可知对象有五种状态四种锁，用1bit表示是否为偏向锁。</p><ul><li>偏向锁</li></ul><p>偏向锁的目标是减少在无竞争其只有一个线程使用锁的情况下使用轻量锁产生的性能消耗。轻量锁在申请和释放锁时都会做一次CAS，而偏向锁只在申请的时候做一次CAS。第一个访问同步代码块的线程申请锁时在mark word中CAS记录owner，如果记录成功则偏向锁获取成功，标志位偏向锁，否则说明有其他的线程在竞争，膨胀为轻量锁。</p><ul><li>轻量锁</li></ul><p>轻量锁的目标是减少无实际竞争情况下使用重量锁产生的性能消耗。使用轻量锁时无需使用metux互斥量，仅仅将Mrak Word中的部分字节CAS更新指向线程栈中的Lock Record（每个线程在JVM中都有一个自己的栈，可记录线程和方法调用的基本信息），如果成功则获取轻量锁成功，在对象头中标志位轻量锁，否则说明当前发生了竞争，膨胀为重量锁。</p><ul><li>自旋锁</li></ul><p>自旋锁可以优化因阻塞而引起的线程切换。当竞争不激烈且持有锁的时间不长时，并不让线程挂起等待锁的释放，而是让线程做一个空循环的自旋操作，如果在循环结束后获得锁则说明自旋锁成功，否则会阻塞自己。自适应自旋锁是自旋锁的基础上自己调整自己。比如针对同一个同步代码块做自旋锁操作时，如果经常没获取成功，则下一次就要增加时长（当然并不能无限增大，自旋锁针对的是持有锁时间短的情况，在其他场景下自旋锁就会白白浪费CPU时间）</p><ul><li>重量锁</li></ul><p>重量锁直接调用objectMonitor的enter和exit，它和操作系统的互斥量直接对应，系统调用会引起用户态和和心态的切换等问题，性能消耗大。</p><ul><li>锁消除</li></ul><p>有时候虽然对代码块进行了同步操作，但是是多数的的时候JIT编译器会在编译同步代码块时取消对这部分代码的同步。JIT(just in time)编译器会利用逃逸分析技术<br>判断同步代码所使用的锁对象是否只能怪被一个线程访问而不发布到其他线程。比如在一个方法中声明一个对象，在方法中利用这个对象进行同步操作，除此方法外其他地方都没用到这个对象，那这个同步操作将会被消除，因为当方法执行完后这个对象也会被回收，其他线程自然访问不到该对象，也就没必要做同步操作。</p><ul><li>锁粗化</li></ul><p>锁粗化和锁消除相反，是将同步范围扩大的操作。在一般开发中，提倡减少锁的粒度，但有时候对一段同步代码频繁地使用，比如在循环体内做同步操作，JIT发现一系列的操作都在对同一个对象进行反复加锁和解锁时，则会将锁同步的范围扩散至整个操作序列的外部。</p><p>介绍完锁的优化技术后，配合下图可以更好地理解synchronized的原理。</p><p><img src="dxc-synchronized.assets/image-20200528222546878.png" alt="image-20200528222546878"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在java中如果使用了多线程对共享数据进行操作，那无可避免会遇到同步问题。为解决此问题可以使用synchronized对方法或者代码块进行修饰。java代码执行时先编译为.class文件再在JVM上运行，在讲述JVM如何实现synchronized前先了解一下相关准备知识。
    
    </summary>
    
    
    
      <category term="多线程" scheme="https://dcghx.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM——2-类加载机制</title>
    <link href="https://dcghx.github.io/2020/05/09/jvm-2-ljz/"/>
    <id>https://dcghx.github.io/2020/05/09/jvm-2-ljz/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-29T16:31:28.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>你是否真的理解java的类加载机制？点进文章的盆友不如先来做一道非常常见的面试题，如果你能做出来，可能你早已掌握并理解了java的类加载机制，若结果出乎你的意料，那就很有必要来了解了解java的类加载机制了。代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.package com.jvm.classloader;  </span><br><span class="line">2.  </span><br><span class="line">3.class Father2&#123;  </span><br><span class="line">4.    public static String strFather&#x3D;&quot;HelloJVM_Father&quot;;  </span><br><span class="line">5.  </span><br><span class="line">6.    static&#123;  </span><br><span class="line">7.        System.out.println(&quot;Father静态代码块&quot;);  </span><br><span class="line">8.    &#125;  </span><br><span class="line">9.&#125;  </span><br><span class="line">10.  </span><br><span class="line">11.class Son2 extends Father2&#123;  </span><br><span class="line">12.    public static String strSon&#x3D;&quot;HelloJVM_Son&quot;;  </span><br><span class="line">13.  </span><br><span class="line">14.    static&#123;  </span><br><span class="line">15.        System.out.println(&quot;Son静态代码块&quot;);  </span><br><span class="line">16.    &#125;  </span><br><span class="line">17.&#125;  </span><br><span class="line">18.  </span><br><span class="line">19.public class InitativeUseTest2 &#123;  </span><br><span class="line">20.    public static void main(String[] args) &#123;  </span><br><span class="line">21.  </span><br><span class="line">22.       System.out.println(Son2.strSon);  </span><br><span class="line">23.    &#125;  </span><br><span class="line">24.&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Father静态代码块  </span><br><span class="line">2. Son静态代码块  </span><br><span class="line">   HelloJVM_Son</span><br></pre></td></tr></table></figure><p>嗯哼？其实上面程序并不是关键，可能真的难不倒各位，不妨做下面一道面试题可好？如果下面这道面试题都做对了，那没错了，这篇文章你就不用看了，真的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.class YeYe&#123;  </span><br><span class="line">2.    static &#123;  </span><br><span class="line">3.        System.out.println(&quot;YeYe静态代码块&quot;);  </span><br><span class="line">4.    &#125;  </span><br><span class="line">5.&#125;  </span><br><span class="line">6.  </span><br><span class="line">7.class Father extends YeYe&#123;  </span><br><span class="line">8.    public static String strFather&#x3D;&quot;HelloJVM_Father&quot;;  </span><br><span class="line">9.  </span><br><span class="line">10.    static&#123;  </span><br><span class="line">11.        System.out.println(&quot;Father静态代码块&quot;);  </span><br><span class="line">12.    &#125;  </span><br><span class="line">13.&#125;  </span><br><span class="line">14.  </span><br><span class="line">15.class Son extends Father&#123;  </span><br><span class="line">16.    public static String strSon&#x3D;&quot;HelloJVM_Son&quot;;  </span><br><span class="line">17.  </span><br><span class="line">18.    static&#123;  </span><br><span class="line">19.        System.out.println(&quot;Son静态代码块&quot;);  </span><br><span class="line">20.    &#125;  </span><br><span class="line">21.&#125;  </span><br><span class="line">22.  </span><br><span class="line">23.public class InitiativeUse &#123;  </span><br><span class="line">24.    public static void main(String[] args) &#123;  </span><br><span class="line">25.        System.out.println(Son.strFather);   </span><br><span class="line">26.    &#125;  </span><br><span class="line">27.&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.YeYe静态代码块  </span><br><span class="line">2.Father静态代码块  </span><br><span class="line">3.HelloJVM_Father</span><br></pre></td></tr></table></figure><p>是对是错已经有个数了吧，我就不拆穿各位的小心思了…</p><p>以上的面试题其实就是典型的java类的加载问题，如果你对Java加载机制不理解，那么你可能就错了上面两道题目的。这篇文章将通过对Java类加载机制的讲解，让各位熟练理解java类的加载机制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.package com.jvm.classloader;  </span><br><span class="line">2.  </span><br><span class="line">3.class YeYe&#123;  </span><br><span class="line">4.    static &#123;  </span><br><span class="line">5.        System.out.println(&quot;YeYe静态代码块&quot;);  </span><br><span class="line">6.    &#125;  </span><br><span class="line">7.&#125;  </span><br><span class="line">8.  </span><br><span class="line">9.class Father extends YeYe&#123;  </span><br><span class="line">10.    public final static String strFather&#x3D;&quot;HelloJVM_Father&quot;;  </span><br><span class="line">11.  </span><br><span class="line">12.    static&#123;  </span><br><span class="line">13.        System.out.println(&quot;Father静态代码块&quot;);  </span><br><span class="line">14.    &#125;  </span><br><span class="line">15.&#125;  </span><br><span class="line">16.  </span><br><span class="line">17.class Son extends Father&#123;  </span><br><span class="line">18.    public static String strSon&#x3D;&quot;HelloJVM_Son&quot;;  </span><br><span class="line">19.  </span><br><span class="line">20.    static&#123;  </span><br><span class="line">21.        System.out.println(&quot;Son静态代码块&quot;);  </span><br><span class="line">22.    &#125;  </span><br><span class="line">23.&#125;  </span><br><span class="line">24.  </span><br><span class="line">25.public class InitiativeUse &#123;  </span><br><span class="line">26.    public static void main(String[] args) &#123;  </span><br><span class="line">27.        System.out.println(Son.strFather);  </span><br><span class="line">28.    &#125;  </span><br><span class="line">29.&#125;</span><br></pre></td></tr></table></figure><p>运行结果： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果：HelloJVM_Father</span><br></pre></td></tr></table></figure><h1 id="2-什么是类的加载（类初始化）"><a href="#2-什么是类的加载（类初始化）" class="headerlink" title="2.什么是类的加载（类初始化）"></a>2.什么是类的加载（类初始化）</h1><p>JVM重要的一个领域：类加载</p><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。而类加载必然涉及类加载器，下面我们先来了解一下类的加载。</p><p>类的加载（类初始化）：</p><ul><li><p>在java代码中，类型的加载、连接、与初始化过程都是在程序运行期间完成的（类从磁盘加载到内存中经历的三个阶段）【牢牢记在心里】</p></li><li><p>提供了更大的灵活性，增加了更多的可能性</p></li></ul><p>虽然上面的第一句话非常简短，但是蕴含的知识量却是巨大的！包含两个重要的概念：</p><p>1) 类型</p><p>定义的类、接口或者枚举称为类型而不涉及对象，在类加载的过程中，是一个创建对象之前的一些信息</p><p>2) 程序运行期间</p><p>程序运行期间完成典型例子就是动态代理，其实很多语言都是在编译期就完成了加载，也正因为这个特性给Java程序提供了更大的灵活性，增加了更多的可能性</p><h2 id="2-1-类加载注意事项"><a href="#2-1-类加载注意事项" class="headerlink" title="2.1 类加载注意事项"></a>2.1 类加载注意事项</h2><p>1) 类加载器并不需要等到某个类被 “首次主动使用” 时再加载它（关于首次主动使用这个重要概念下文将讲解）</p><p>2) JVM规范允许类加载器在预料某个类将要被使用时就预先加载它</p><p>3) 如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><h1 id="3-类的生命周期"><a href="#3-类的生命周期" class="headerlink" title="3.类的生命周期"></a>3.类的生命周期</h1><p><img src="jvm-2-ljz.assets/image-20200529234307180.png" alt="image-20200529234307180"></p><p>从上图可知，类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括 7 个阶段，而验证、准备、解析 3 个阶段统称为连接。</p><p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是固定确定的，类的加载过程必须按照这种顺序开始（注意是“开始”，而不是“进行”），而解析阶段则不一定：它在某些情况下可以在初始化后再开始，这是为了支持 Java 语言的运行时绑定【也就是java的动态绑定/晚期绑定】。</p><h2 id="3-1加载"><a href="#3-1加载" class="headerlink" title="3.1加载"></a>3.1加载</h2><p>在上面已经提到过，加载阶段是类加载的第一个阶段！类的加载过程就是从加载阶段开始~</p><p>加载阶段指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象（JVM规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在方法区中），用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 Class对象， Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p>Class对象是存放在堆区的，不是方法区，这点很多人容易犯错。类的元数据才是存在方法区的。【元数据并不是类的Class对象。Class对象是加载的最终产品，类的方法代码，变量名，方法名，访问权限，返回值等等都是在方法区的】</p><p>JDK7创建Class实例存在堆中；因为JDK7中JavaObjectsInPerm参数值固定为false。<br>JDK8移除了永久代，转而使用元空间来实现方法区，创建的Class实例依旧在java heap（堆）中</p><p><img src="jvm-2-ljz.assets/image-20200529234402176.png" alt="image-20200529234402176"></p><p>编写一个新的java类时,JVM就会帮我们编译成class对象,存放在同名的.class文件中。在运行时，当需要生成这个类的对象，JVM就会检查此类是否已经装载内存中。若是没有装载，则把.class文件装入到内存中。若是装载，则根据class文件生成实例对象。</p><p>怎么理解Class对象与new出来的对象之间的关系呢？</p><p>new出来的对象以car为例。可以把car的Class类看成具体的一个人，而new car则是人物映像，具体的一个人（Class）是唯一的，人物映像（new car）是多个的。镜子中的每个人物映像都是根据具体的人映造出来的，也就是说每个new出来的对象都是以Class类为模板参照出来的！为啥可以参照捏？因为Class对象提供了访问方法区内的数据结构的接口哇，上面提及过了喔！</p><p><img src="jvm-2-ljz.assets/image-20200529235200676.png" alt="image-20200529235200676"></p><p>总结：</p><p>加载阶段简单来说就是：</p><p>.class文件（二进制数据）——&gt;读取到内存——&gt;元数据放进方法区——&gt;堆中创建对应Class对象——&gt;并提供访问方法区的接口</p><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p>加载.calss文件的方式:</p><p>类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。通过使用不同的类加载器，可以从不同来源加载类的二进制数据，二进制数据通常有如下几种来源：</p><p>（1）从本地系统中直接加载</p><p>（2）通过网络下载.class文件</p><p>（3）从zip，jar等归档文件中加载.class文件</p><p>（4）从专用数据库中提取.class文件</p><p>（5）将java源文件动态编译为.class文件</p><h2 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a>3.2 验证</h2><p>验证：确保被加载的类的正确性。</p><p>关于验证大可不必深入但是了解类加载机制必须要知道有这么个过程以及知道验证就是为了验证确保Class文件的字节流中包含的信息符合当前虚拟机的要求即可。<br>所以下面关于验证的内容作为了解即可</p><p>验证是连接阶段的第一阶段，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：确保解析动作能正确执行。</li></ul><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h2 id="3-3-准备"><a href="#3-3-准备" class="headerlink" title="3.3 准备"></a>3.3 准备</h2><p>当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</p><p>这里需要注意两个关键点，即<strong><em>\</em>内存分配的对象**</strong>以及<strong><em>\</em>初始化的类型**</strong>。</p><p>内存分配的对象：要明白首先要知道Java 中的变量有类变量以及类成员变量两种类型，类变量指的是被 static 修饰的变量，而其他所有类型的变量都属于类成员变量。在准备阶段，JVM 只会为类变量分配内存，而不会为类成员变量分配内存。类成员变量的内存分配需要等到初始化阶段才开始（初始化阶段下面会讲到）。</p><p>举个例子：例如下面的代码在准备阶段，只会为 LeiBianLiang属性分配内存，而不会为 ChenYuanBL属性分配内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.public static int LeiBianLiang &#x3D; 666;  </span><br><span class="line">2.public String ChenYuanBL &#x3D; &quot;jvm&quot;;</span><br></pre></td></tr></table></figure><p>初始化的类型：在准备阶段，JVM 会为类变量分配内存，并为其初始化（JVM 只会为类变量分配内存，而不会为类成员变量分配内存，类成员变量自然这个时候也不能被初始化）。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的默认值，而不是用户代码里初始化的值。</p><p>例如下面的代码在准备阶段之后，LeiBianLiang 的值将是 0，而不是 666。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.public static int LeiBianLiang &#x3D; 666;</span><br></pre></td></tr></table></figure><p>但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。例如下面的代码在准备阶段之后，ChangLiang的值将是 666，而不再会是 0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.public static final int ChangLiang &#x3D; 666;</span><br></pre></td></tr></table></figure><p>之所以 static final 会直接被复制，而 static 变量会被赋予java语言类型的默认值。其实我们稍微思考一下就能想明白了。</p><p>两个语句的区别是一个有 final 关键字修饰，另外一个没有。而 final 关键字在 Java 中代表不可改变的意思，意思就是说 ChangLiang的值一旦赋值就不会在改变了。既然一旦赋值就不会再改变，那么就必须一开始就给其赋予用户想要的值，因此被 final 修饰的类变量在准备阶段就会被赋予想要的值。而没有被 final 修饰的类变量，其可能在初始化阶段或者运行阶段发生变化，所以就没有必要在准备阶段对它赋予用户想要的值。</p><h2 id="3-4-解析"><a href="#3-4-解析" class="headerlink" title="3.4 解析"></a>3.4 解析</h2><p>当通过准备阶段之后，进入解析阶段。解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p><p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p>其实这个阶段对于我们来说也是几乎透明的，了解一下就好。</p><h2 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a>3.5 初始化</h2><p>到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。</p><p>Java程序对类的使用方式可分为两种:主动使用与被动使用。一般来说只有当对类的首次主动使用的时候才会导致类的初始化，所以主动使用又叫做类加载过程中“初始化”开始的时机。那啥是主动使用呢？类的主动使用包括以下六种【超级重点】：</p><p>1) 创建类的实例，也就是new的方式</p><p>2) 访问某个类或接口的静态变量，或者对该静态变量赋值（凡是被final修饰不不不其实更准确的说是在编译器把结果放入常量池的静态字段除外） </p><p>3) 调用类的静态方法</p><p>4) 反射（如 Class.forName(“com.gx.yichun”)）</p><p>5) 初始化某个类的子类，则其父类也会被初始化</p><p>6) Java虚拟机启动时被标明为启动类的类（ JavaTest ），还有就是Main方法的类会首先被初始化</p><p>最后注意一点对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块），这句话在继承、多态中最为明显！为了方便理解下文会陆续通过例子讲解</p><h2 id="3-6-使用"><a href="#3-6-使用" class="headerlink" title="3.6 使用"></a>3.6 使用</h2><p>当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。这个使用阶段也只是了解一下就可以了。</p><h2 id="3-7-卸载"><a href="#3-7-卸载" class="headerlink" title="3.7 卸载"></a>3.7 卸载</h2><p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。这个卸载阶段也只是了解一下就可以了。</p><h2 id="3-8-结束生命周期"><a href="#3-8-结束生命周期" class="headerlink" title="3.8 结束生命周期"></a>3.8 结束生命周期</h2><p>在如下几种情况下，Java虚拟机将结束生命周期</p><p>1) 执行了 System.exit()方法</p><p>2) 程序正常执行结束</p><p>3) 程序在执行过程中遇到了异常或错误而异常终止</p><p>4) 由于操作系统出现错误而导致Java虚拟机进程终止</p><h1 id="4-接口的加载过程"><a href="#4-接口的加载过程" class="headerlink" title="4 接口的加载过程"></a>4 接口的加载过程</h1><p>接口加载过程与类加载过程稍有不同。</p><p>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。</p><h1 id="5-解开开篇面试题"><a href="#5-解开开篇面试题" class="headerlink" title="5 解开开篇面试题"></a>5 解开开篇面试题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.class Father2&#123;  </span><br><span class="line">2.    public static String strFather&#x3D;&quot;HelloJVM_Father&quot;;  </span><br><span class="line">3.  </span><br><span class="line">4.    static&#123;  </span><br><span class="line">5.        System.out.println(&quot;Father静态代码块&quot;);  </span><br><span class="line">6.    &#125;  </span><br><span class="line">7.&#125;  </span><br><span class="line">8.  </span><br><span class="line">9.class Son2 extends Father2&#123;  </span><br><span class="line">10.    public static String strSon&#x3D;&quot;HelloJVM_Son&quot;;  </span><br><span class="line">11.  </span><br><span class="line">12.    static&#123;  </span><br><span class="line">13.        System.out.println(&quot;Son静态代码块&quot;);  </span><br><span class="line">14.    &#125;  </span><br><span class="line">15.&#125;  </span><br><span class="line">16.  </span><br><span class="line">17.public class InitativeUseTest2 &#123;  </span><br><span class="line">18.    public static void main(String[] args) &#123;  </span><br><span class="line">19.  </span><br><span class="line">20.       System.out.println(Son2.strSon);  </span><br><span class="line">21.    &#125;  </span><br><span class="line">22.&#125;  </span><br><span class="line">23.  </span><br><span class="line">24.运行结果：  </span><br><span class="line">25.        Father静态代码块  </span><br><span class="line">26.        Son静态代码块  </span><br><span class="line">27.        HelloJVM_Son</span><br></pre></td></tr></table></figure><p>再回头看这个题，这也太简单了吧，由于Son2.strSon是调用了Son类自己的静态方法属于主动使用，所以会初始化Son类，又由于继承关系，类继承原则是初始化一个子类，会先去初始化其父类，所以会先去初始化父类！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1.class YeYe&#123;  </span><br><span class="line">2.    static &#123;  </span><br><span class="line">3.        System.out.println(&quot;YeYe静态代码块&quot;);  </span><br><span class="line">4.    &#125;  </span><br><span class="line">5.&#125;  </span><br><span class="line">6.  </span><br><span class="line">7.class Father extends YeYe&#123;  </span><br><span class="line">8.    public static String strFather&#x3D;&quot;HelloJVM_Father&quot;;  </span><br><span class="line">9.  </span><br><span class="line">10.    static&#123;  </span><br><span class="line">11.        System.out.println(&quot;Father静态代码块&quot;);  </span><br><span class="line">12.    &#125;  </span><br><span class="line">13.&#125;  </span><br><span class="line">14.  </span><br><span class="line">15.class Son extends Father&#123;  </span><br><span class="line">16.    public static String strSon&#x3D;&quot;HelloJVM_Son&quot;;  </span><br><span class="line">17.  </span><br><span class="line">18.    static&#123;  </span><br><span class="line">19.        System.out.println(&quot;Son静态代码块&quot;);  </span><br><span class="line">20.    &#125;  </span><br><span class="line">21.&#125;  </span><br><span class="line">22.  </span><br><span class="line">23.public class InitiativeUse &#123;  </span><br><span class="line">24.    public static void main(String[] args) &#123;  </span><br><span class="line">25.        System.out.println(Son.strFather);   </span><br><span class="line">26.    &#125;  </span><br><span class="line">27.&#125;  </span><br><span class="line">28.  </span><br><span class="line">29.运行结果：  </span><br><span class="line">30.    YeYe静态代码块  </span><br><span class="line">31.    Father静态代码块  </span><br><span class="line">32.    HelloJVM_Father</span><br></pre></td></tr></table></figure><p>注意子类Son类没有被初始化</p><p>首先看到Son.strFather，你会发现是子类Son访问父类Father的静态变量strFather，这个时候就千万要记住我在归纳主动使用概念时特别提到过的一个注意点了：对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块），这句话在继承、多态中最为明显！</p><p>嗯哼，对吧，Son.strFather中的静态字段是属于父类Father的对吧，也就是说直接定义这个字段的类是父类Father，所以在执行 System.out.println(Son.strFather); 这句代码的时候会去初始化Father类而不是子类Son！是不是一下子明白了？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.class YeYe&#123;  </span><br><span class="line">2.    static &#123;  </span><br><span class="line">3.        System.out.println(&quot;YeYe静态代码块&quot;);  </span><br><span class="line">4.    &#125;  </span><br><span class="line">5.&#125;  </span><br><span class="line">6.  </span><br><span class="line">7.class Father extends YeYe&#123;  </span><br><span class="line">8.    public final static String strFather&#x3D;&quot;HelloJVM_Father&quot;;  </span><br><span class="line">9.  </span><br><span class="line">10.    static&#123;  </span><br><span class="line">11.        System.out.println(&quot;Father静态代码块&quot;);  </span><br><span class="line">12.    &#125;  </span><br><span class="line">13.&#125;  </span><br><span class="line">14.  </span><br><span class="line">15.class Son extends Father&#123;  </span><br><span class="line">16.    public static String strSon&#x3D;&quot;HelloJVM_Son&quot;;  </span><br><span class="line">17.  </span><br><span class="line">18.    static&#123;  </span><br><span class="line">19.        System.out.println(&quot;Son静态代码块&quot;);  </span><br><span class="line">20.    &#125;  </span><br><span class="line">21.&#125;  </span><br><span class="line">22.  </span><br><span class="line">23.public class InitiativeUse &#123;  </span><br><span class="line">24.    public static void main(String[] args) &#123;  </span><br><span class="line">25.        System.out.println(Son.strFather);  </span><br><span class="line">26.    &#125;  </span><br><span class="line">27.&#125;  </span><br><span class="line">28.  </span><br><span class="line">29.运行结果：HelloJVM_Father</span><br></pre></td></tr></table></figure><p>这个题唯一的特点就在于final static ！是的Son.strFather所对应的变量便是final static修饰的，依旧是在本篇文章中归纳的类的主动使用范畴第二点当中：访问某个类或接口的静态变量，或者对该静态变量赋值（凡是被final修饰不不不其实更准确的说是在编译器把结果放入常量池的静态字段除外）</p><p>所以，这个题并不会初始化任何类，当然除了Main方法所在的类！于是仅仅执行了System.out.println(Son.strFather);所以仅仅打印了Son.strFather的字段结果HelloJVM_Father，嗯哼，是不是又突然明白了？</p><p>实际上上面的题目并不能完全说明本篇文章中归纳的类的主动使用范畴第二点！这话怎么说呢？怎么理解呢？再来一个程序各位就更加明了了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.class Test&#123;  </span><br><span class="line">2.    static &#123;  </span><br><span class="line">3.        System.out.println(&quot;static 静态代码块&quot;);  </span><br><span class="line">4.    &#125;  </span><br><span class="line">5.  </span><br><span class="line">6.&#x2F;&#x2F;    public static final String str&#x3D; UUID.randomUUID().toString();  </span><br><span class="line">7.    public static final double str&#x3D;Math.random();  &#x2F;&#x2F;编译期不确定  </span><br><span class="line">8.&#125;  </span><br><span class="line">9.  </span><br><span class="line">10.  </span><br><span class="line">11.public class FinalUUidTest &#123;  </span><br><span class="line">12.    public static void main(String[] args) &#123;  </span><br><span class="line">13.        System.out.println(Test.str);  </span><br><span class="line">14.    &#125;  </span><br><span class="line">15.&#125;  </span><br><span class="line">16.  </span><br><span class="line">17.输出  </span><br><span class="line">18.static 静态代码块  </span><br><span class="line">0.7338688977344875</span><br></pre></td></tr></table></figure><p>上面这个程序完全说明本篇文章中归纳的类的主动使用范畴第二点当中的这句话：凡是被final修饰不不不其实更准确的说是在编译器把结果放入常量池的静态字段除外！</p><p>分析：其实final不是重点，重点是编译器把结果放入常量池！当一个常量的值并非编译期可以确定的，那么这个值就不会被放到调用类的常量池中，这时在程序运行时，会导致主动使用这个常量所在的类，所以这个类会被初始化</p><p>单纯的想巅覆各位对java代码的认知，当然还望大佬轻拍哈哈哈，直接上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.public class ClassAndObjectLnitialize &#123;  </span><br><span class="line">2.         int ZhiShang &#x3D; 250;  </span><br><span class="line">3.        static int QingShang &#x3D; 666;  </span><br><span class="line">4.</span><br><span class="line">5.        &#123;  </span><br><span class="line">6.            System.out.println(&quot;普通代码块&quot;);  </span><br><span class="line">7.        &#125;  </span><br><span class="line">8.  </span><br><span class="line">9.        static&#123;  </span><br><span class="line">10.            System.out.println(&quot;静态代码块&quot;);  </span><br><span class="line">11.        &#125;  </span><br><span class="line">12.  </span><br><span class="line">13.      public ClassAndObjectLnitialize()&#123;  </span><br><span class="line">14.            System.out.println(&quot;构造方法&quot;);  </span><br><span class="line">15.System.out.println(&quot;我是熊孩子我的智商&#x3D;&quot; + ZhiShang +&quot;,情商&#x3D;&quot; + QingShang);  </span><br><span class="line">16.        &#125;          </span><br><span class="line">17.  </span><br><span class="line">18.      public static void main(String[] args) &#123;  </span><br><span class="line">19.            System.out.println(&quot;输出的打印语句&quot;);  </span><br><span class="line">20.        &#125;  </span><br><span class="line">21.&#125;</span><br></pre></td></tr></table></figure><p>建议这个题不要花太多时间思考，否则看了结果你会发现自己想太多了，导致最后可能你看到结果想砸电脑哈哈哈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.运行结果  </span><br><span class="line">2.        静态代码块  </span><br><span class="line">3.        输出的打印语句</span><br></pre></td></tr></table></figure><p>下面我们来简单分析一下，首先根据上面说到的触发初始化的（主动使用）的第六点：Java虚拟机启动时被标明为启动类的类（ JavaTest ），还有就是Main方法的类会首先被初始化</p><p>嗯哼？小白童鞋就有疑问了：不是说好有Main方法的类会被初始化的么？那怎么好多东西都没有执行捏？</p><p>那么类的初始化顺序到底是怎么样的呢？在我们代码中，我们只知道有一个构造方法，但实际上Java代码编译成字节码之后，最开始是没有构造方法的概念的，只有类初始化方法 和 对象初始化方法 。</p><p>这个时候我们就不得不深入理解了！那么这两个方法是怎么来的呢？</p><ul><li>类初始化方法：编译器会按照其出现顺序，收集：类变量（static变量）的赋值语句、静态代码块，最终组成类初始化方法。类初始化方法一般在类初始化的时候执行。</li></ul><p>所以，上面的这个例子，类初始化方法就会执行下面这段代码了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.static int QingShang &#x3D; 666;  &#x2F;&#x2F;类变量（static变量）的赋值语句  </span><br><span class="line">2.  </span><br><span class="line">3. static   &#x2F;&#x2F;静态代码块  </span><br><span class="line">4.  &#123;  </span><br><span class="line">5.      System.out.println(&quot;静态代码块&quot;);  </span><br><span class="line">6.  &#125;</span><br></pre></td></tr></table></figure><ul><li>对象初始化方法：编译器会按照其出现顺序，收集：成员变量的赋值语句、普通代码块，最后收集构造函数的代码，最终组成对象初始化方法，值得特别注意的是，如果没有监测或者收集到构造函数的代码，则将不会执行对象初始化方法。对象初始化方法一般在实例化类对象的时候执行。</li></ul><p>以上面这个例子，其对象初始化方法就是下面这段代码了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.&#123;                          </span><br><span class="line">2.   System.out.println(&quot;普通代码块&quot;);    &#x2F;&#x2F;普通代码块  </span><br><span class="line">3.&#125;  </span><br><span class="line">4.  </span><br><span class="line">5.int ZhiShang &#x3D; 250;   &#x2F;&#x2F;成员变量的赋值语句  </span><br><span class="line">6.  </span><br><span class="line">7.System.out.println(&quot;构造方法&quot;);  &#x2F;&#x2F;最后收集构造函数的代码  </span><br><span class="line">System.out.println(&quot;我是熊孩子我的智商&#x3D;&quot; + ZhiShang +&quot;,情商&#x3D;&quot; + QingShang);</span><br></pre></td></tr></table></figure><p>明白了类初始化方法 和 对象初始化方法 之后，我们再来看这个上面例子！是的！正如上面提到的：如果没有监测或者收集到构造函数的代码，则将不会执行对象初始化方法。上面的这个例子确实没有执行对象初始化方法。忘了吗？我们根本就没有对类ClassAndObjectLnitialize 进行实例化！只是单纯的写了一个输出语句。如果我们给其实例化，验证一下，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1.public class ClassAndObjectLnitialize &#123;  </span><br><span class="line">2.  </span><br><span class="line">3.        public static void main(String[] args) &#123;  </span><br><span class="line">4.            new ClassAndObjectLnitialize();  </span><br><span class="line">5.            System.out.println(&quot;输出的打印语句&quot;);  </span><br><span class="line">6.        &#125;  </span><br><span class="line">7.  </span><br><span class="line">8.      public ClassAndObjectLnitialize()&#123;  </span><br><span class="line">9.  </span><br><span class="line">10.            System.out.println(&quot;构造方法&quot;);  </span><br><span class="line">11.System.out.println(&quot;我是熊孩子我的智商&#x3D;&quot; + ZhiShang +&quot;,情商&#x3D;&quot; + QingShang);  </span><br><span class="line">12.        &#125;  </span><br><span class="line">13.  </span><br><span class="line">14.        &#123;  </span><br><span class="line">15.            System.out.println(&quot;普通代码块&quot;);  </span><br><span class="line">16.        &#125;  </span><br><span class="line">17.  </span><br><span class="line">18.        int ZhiShang &#x3D; 250;  </span><br><span class="line">19.        static int QingShang &#x3D; 666;  </span><br><span class="line">20.          </span><br><span class="line">21.        static  </span><br><span class="line">22.        &#123;  </span><br><span class="line">23.            System.out.println(&quot;静态代码块&quot;);  </span><br><span class="line">24.        &#125;        </span><br><span class="line">25.&#125;  </span><br><span class="line">26.  </span><br><span class="line">27.运行结果：  </span><br><span class="line">28.        静态代码块  </span><br><span class="line">29.        普通代码块  </span><br><span class="line">30.        构造方法  </span><br><span class="line">31.        我是熊孩子我的智商&#x3D;250,情商&#x3D;666  </span><br><span class="line">32.        输出的打印语句</span><br></pre></td></tr></table></figure><h1 id="5-理解首次主动使用"><a href="#5-理解首次主动使用" class="headerlink" title="5. 理解首次主动使用"></a>5. 理解首次主动使用</h1><p>我在上面提到过Java程序对类的使用方式可分为两种:主动使用与被动使用。一般来说只有当对类的首次主动使用的时候才会导致类的初始化，其中首次关键字很重要，因此特地用一小结将其讲解！怎么理解呢？老规矩看个题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.class Father6&#123;  </span><br><span class="line">2.    public static int a &#x3D; 1;  </span><br><span class="line">3.    static &#123;  </span><br><span class="line">4.        System.out.println(&quot;父类粑粑静态代码块&quot;);  </span><br><span class="line">5.    &#125;  </span><br><span class="line">6.&#125;  </span><br><span class="line">7.class Son6&#123;  </span><br><span class="line">8.    public static int b &#x3D; 2;  </span><br><span class="line">9.    static &#123;System.out.println(&quot;子类熊孩子静态代码块&quot;);&#125;  </span><br><span class="line">10.&#125;  </span><br><span class="line">11.  </span><br><span class="line">12.public class OverallTest &#123;  </span><br><span class="line">13.    static &#123; System.out.println(&quot;Main方法静态代码块&quot;); &#125;  </span><br><span class="line">14.  </span><br><span class="line">15.    public static void main(String[] args) &#123;  </span><br><span class="line">16.        Father6 father6;  </span><br><span class="line">17.        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);  </span><br><span class="line">18.  </span><br><span class="line">19.         father6&#x3D;new Father6();  </span><br><span class="line">20.        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);  </span><br><span class="line">21.  </span><br><span class="line">22.        System.out.println(Father6.a);  </span><br><span class="line">23.        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);  </span><br><span class="line">24.  </span><br><span class="line">25.        System.out.println(Son6.b);  </span><br><span class="line">26.  </span><br><span class="line">27.    &#125;  </span><br><span class="line">1.&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2.        Main方法静态代码块  </span><br><span class="line">3.        &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  </span><br><span class="line">4.        父类粑粑静态代码块  </span><br><span class="line">5.        &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  </span><br><span class="line">6.        1  </span><br><span class="line">7.        &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  </span><br><span class="line">8.        子类熊孩子静态代码块  </span><br><span class="line">9.        2</span><br></pre></td></tr></table></figure><p>分析：</p><p>首先根据主动使用概括的第六点：Main方法的类会首先被初始化。 所以最先执行Main方法静态代码块，而 Father6 father6;只是声明了一个引用不会执行什么，当运行到father6=new Father6();的时候，看到关键字new并且将引用father6指向了Father6对象，说明主动使用了，所以父类Father6将被初始化，因此打印了：父类粑粑静态代码块 ，之后执行 System.out.println(Father6.a);属于访问静态变量所以也是主动使用，这个时候注意了，因为在上面执行father6=new Father6();的时候父类已经主动使用并且初始化过一次了，这次不再是首次主动使用了，所以Father6不会在被初始化，自然它的静态代码块就不再执行了，所以直接打印静态变量值1，而后面的System.out.println(Son6.b);同样，也是只初始化自己，不会去初始化父类，只因为父类Father6以及不再是首次主动使用了！</p><h1 id="6-类加载器"><a href="#6-类加载器" class="headerlink" title="6. 类加载器"></a>6. 类加载器</h1><p>类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载入JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。</p><p>关于唯一标识符：</p><p>在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。</p><p>类加载器的任务是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例，在虚拟机提供了3种类加载器，启动（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器），如下：</p><p><img src="jvm-2-ljz.assets/image-20200530000304780.png" alt="image-20200530000304780"></p><p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p><ul><li>启动类加载器： BootstrapClassLoader，启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，负责加载存放在 JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 BootstrapClassLoader加载）。启动类加载器是无法被Java程序直接引用的。总结一句话：启动类加载器加载java运行过程中的核心类库JRE\lib\rt.jar, sunrsasign.jar, charsets.jar, jce.jar, jsse.jar, plugin.jar 以及存放在JRE\classes里的类，也就是JDK提供的类等常见的比如：Object、Stirng、List…</li></ul><ul><li>扩展类加载器： ExtensionClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader实现，它负责加载 JDK\jre\lib\ext目录中，或者由 java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。</li></ul><ul><li>应用程序类加载器： ApplicationClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。总结一句话：应用程序类加载器加载CLASSPATH变量指定路径下的类 即指你自已在项目工程中编写的类</li></ul><ul><li>线程上下文类加载器：除了以上列举的三种类加载器，其实还有一种比较特殊的类型就是线程上下文类加载器。类似Thread.currentThread().getContextClassLoader()获取线程上下文类加载器，线程上下文加载器其实很重要，它违背（破坏）双亲委派模型，很好地打破了双亲委派模型的局限性，尽管我们在开发中很少用到，但是框架组件开发绝对要频繁使用到线程上下文类加载器，如Tomcat等等…</li></ul><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，因为JVM自带的类加载器（ClassLoader）只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><p>1、在执行非置信代码之前，自动验证数字签名。</p><p>2、动态地创建符合用户特定需要的定制化构建类。</p><p>3、从特定的场所取得java class，例如数据库中和网络中。</p><p>需要注意的是，Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，Java虚拟机默认采用的是双亲委派模式即把请求交由父类处理，它一种任务委派模式，下面将会详细讲到！</p><p>下面我们看一个程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ClassloaderTest &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        &#x2F;&#x2F;获取ClassloaderTest类的加载器  </span><br><span class="line">        ClassLoader classLoader&#x3D; ClassloaderTest.class.getClassLoader();   </span><br><span class="line">       </span><br><span class="line">       System.out.println(classLoader);  </span><br><span class="line">       System.out.println(classLoader.getParent()); &#x2F;&#x2F;获取ClassloaderTest类的父类加载器  </span><br><span class="line">       System.out.println(classLoader.getParent().getParent());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2  </span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1b6d3586  </span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>从上面的结果可以看出，并没有获取到ExtClassLoader的父加载器（Loader），原因是Bootstrap Loader（启动类加载器）是用C++语言实现的（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），找不到一个确定的返回父Loader的方式，于是就返回null。至于$符号就是内部类的含义。</p><h1 id="7-java虚拟机入口应用：sun-misc-Launcher"><a href="#7-java虚拟机入口应用：sun-misc-Launcher" class="headerlink" title="7.java虚拟机入口应用：sun.misc.Launcher"></a>7.java虚拟机入口应用：sun.misc.Launcher</h1><p>到这里，我为什么要讲Launcher呢？如果你没有接触过这个Launcher类可能你会特别陌生，但是它却特别重要！为啥说它重要呢，不知道你有没有想过为啥类加载器首先会去到应用程序类加载器 ApplicationClassLoader，是的！我在介绍应用程序类加载器 ApplicationClassLoader和扩展类加载器 ExtensionClassLoader的时候就已经提到过这两个类加载器是由sun.misc.Launcher实现的！为了更好的理解，我们可以查看Launcher源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1.public class Launcher &#123;  </span><br><span class="line">2.    private static Launcher launcher &#x3D; new Launcher();  </span><br><span class="line">3.    private static String bootClassPath &#x3D;  </span><br><span class="line">4.        System.getProperty(&quot;sun.boot.class.path&quot;);  </span><br><span class="line">5.  </span><br><span class="line">6.    public static Launcher getLauncher() &#123;  </span><br><span class="line">7.        return launcher;  </span><br><span class="line">8.    &#125;  </span><br><span class="line">9.  </span><br><span class="line">10.    private ClassLoader loader;  </span><br><span class="line">11.  </span><br><span class="line">12.    public Launcher() &#123;  </span><br><span class="line">13.        &#x2F;&#x2F; Create the extension class loader  </span><br><span class="line">14.        ClassLoader extcl;  </span><br><span class="line">15.        try &#123;  </span><br><span class="line">16.            extcl &#x3D; ExtClassLoader.getExtClassLoader();  </span><br><span class="line">17.        &#125; catch (IOException e) &#123;  </span><br><span class="line">18.            throw new InternalError(  </span><br><span class="line">19.                &quot;Could not create extension class loader&quot;, e);  </span><br><span class="line">20.        &#125;  </span><br><span class="line">21.  </span><br><span class="line">22.        &#x2F;&#x2F; Now create the class loader to use to launch the application  </span><br><span class="line">23.        try &#123;  </span><br><span class="line">24.            loader &#x3D; AppClassLoader.getAppClassLoader(extcl);  </span><br><span class="line">25.        &#125; catch (IOException e) &#123;  </span><br><span class="line">26.            throw new InternalError(  </span><br><span class="line">27.                &quot;Could not create application class loader&quot;, e);  </span><br><span class="line">28.        &#125;  </span><br><span class="line">29.  </span><br><span class="line">30.        &#x2F;&#x2F;设置AppClassLoader为线程上下文类加载器，这个文章后面部分讲解  </span><br><span class="line">31.        Thread.currentThread().setContextClassLoader(loader);  </span><br><span class="line">32.    &#125;  </span><br><span class="line">33.  </span><br><span class="line">34.    &#x2F;* </span><br><span class="line">35.     * Returns the class loader used to launch the main application. </span><br><span class="line">36.     *&#x2F;  </span><br><span class="line">37.    public ClassLoader getClassLoader() &#123;  </span><br><span class="line">38.        return loader;  </span><br><span class="line">39.    &#125;  </span><br><span class="line">40.    &#x2F;* </span><br><span class="line">41.     * The class loader used for loading installed extensions. </span><br><span class="line">42.     *&#x2F;  </span><br><span class="line">43.    static class ExtClassLoader extends URLClassLoader &#123;&#125;  </span><br><span class="line">44.  </span><br><span class="line">45.&#x2F;** </span><br><span class="line">46.     * The class loader used for loading from java.class.path. </span><br><span class="line">47.     * runs in a restricted security context. </span><br><span class="line">48.     *&#x2F;  </span><br><span class="line">49.    static class AppClassLoader extends URLClassLoader &#123;&#125;</span><br></pre></td></tr></table></figure><p>通过以上源码我们可以得到相关的信息：</p><ol><li>Launcher初始化了ExtClassLoader和AppClassLoader，首先是创建了Extcl扩展类加载器</li><li>之后的App应用类【系统类】加载器作为Launcher中的一个成员变量，至于为啥不把Extcl扩展类加载器也做为成员变量的原因，大家可以仔细想一想，是为啥呢？其实很简单，因为没必要，因为直接把App系统加载器.parent()方法即可得到Extcl扩展类加载器！</li><li>Launcher中并没有看见BootstrapClassLoader，但通过System.getProperty(“sun.boot.class.path”)得到了字符串bootClassPath,这个应该就是BootstrapClassLoader加载的jar包路径。我们可以用输出语句代码测试一下sun.boot.class.path是什么内容，其实就是JRE目录下的jar包或者是class文件。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));</span><br></pre></td></tr></table></figure><p>得到的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.C:\Program Files\Java\jre1.8.0_91\lib\resources.jar;  </span><br><span class="line">2.C:\Program Files\Java\jre1.8.0_91\lib\rt.jar;  </span><br><span class="line">3.C:\Program Files\Java\jre1.8.0_91\lib\sunrsasign.jar;  </span><br><span class="line">4.C:\Program Files\Java\jre1.8.0_91\lib\jsse.jar;  </span><br><span class="line">5.C:\Program Files\Java\jre1.8.0_91\lib\jce.jar;  </span><br><span class="line">6.C:\Program Files\Java\jre1.8.0_91\lib\charsets.jar;  </span><br><span class="line">7.C:\Program Files\Java\jre1.8.0_91\lib\jfr.jar;  </span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\classes</span><br></pre></td></tr></table></figure><h1 id="8-ExtClassLoader、AppClassLoader源码"><a href="#8-ExtClassLoader、AppClassLoader源码" class="headerlink" title="8. ExtClassLoader、AppClassLoader源码"></a>8. ExtClassLoader、AppClassLoader源码</h1><h2 id="8-1ExtClassLoader源码"><a href="#8-1ExtClassLoader源码" class="headerlink" title="8.1ExtClassLoader源码"></a>8.1ExtClassLoader源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;* </span><br><span class="line">2.     * The class loader used for loading installed extensions. </span><br><span class="line">3.     *&#x2F;  </span><br><span class="line">4.    static class ExtClassLoader extends URLClassLoader &#123;  </span><br><span class="line">5.  </span><br><span class="line">6.        static &#123;  </span><br><span class="line">7.            ClassLoader.registerAsParallelCapable();  </span><br><span class="line">8.        &#125;  </span><br><span class="line">9.  </span><br><span class="line">10.        &#x2F;** </span><br><span class="line">11.         * create an ExtClassLoader. The ExtClassLoader is created </span><br><span class="line">12.         * within a context that limits which files it can read </span><br><span class="line">13.         *&#x2F;  </span><br><span class="line">14.        public static ExtClassLoader getExtClassLoader() throws IOException  </span><br><span class="line">15.        &#123;  </span><br><span class="line">16.            final File[] dirs &#x3D; getExtDirs();  </span><br><span class="line">17.  </span><br><span class="line">18.            try &#123;  </span><br><span class="line">19.                &#x2F;&#x2F; Prior implementations of this doPrivileged() block supplied  </span><br><span class="line">20.                &#x2F;&#x2F; aa synthesized ACC via a call to the private method  </span><br><span class="line">21.                &#x2F;&#x2F; ExtClassLoader.getContext().  </span><br><span class="line">22.  </span><br><span class="line">23.                return AccessController.doPrivileged(  </span><br><span class="line">24.                    new PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123;  </span><br><span class="line">25.                        public ExtClassLoader run() throws IOException &#123;  </span><br><span class="line">26.                            int len &#x3D; dirs.length;  </span><br><span class="line">27.                            for (int i &#x3D; 0; i &lt; len; i++) &#123;  </span><br><span class="line">28.                                MetaIndex.registerDirectory(dirs[i]);  </span><br><span class="line">29.                            &#125;  </span><br><span class="line">30.                            return new ExtClassLoader(dirs);  </span><br><span class="line">31.                        &#125;  </span><br><span class="line">32.                    &#125;);  </span><br><span class="line">33.            &#125; catch (java.security.PrivilegedActionException e) &#123;  </span><br><span class="line">34.                throw (IOException) e.getException();  </span><br><span class="line">35.            &#125;  </span><br><span class="line">36.        &#125;  </span><br><span class="line">37.  </span><br><span class="line">38.        private static File[] getExtDirs() &#123;  </span><br><span class="line">39.            String s &#x3D; System.getProperty(&quot;java.ext.dirs&quot;);  </span><br><span class="line">40.            File[] dirs;  </span><br><span class="line">41.            if (s !&#x3D; null) &#123;  </span><br><span class="line">42.                StringTokenizer st &#x3D;  </span><br><span class="line">43.                    new StringTokenizer(s, File.pathSeparator);  </span><br><span class="line">44.                int count &#x3D; st.countTokens();  </span><br><span class="line">45.                dirs &#x3D; new File[count];  </span><br><span class="line">46.                for (int i &#x3D; 0; i &lt; count; i++) &#123;  </span><br><span class="line">47.                    dirs[i] &#x3D; new File(st.nextToken());  </span><br><span class="line">48.                &#125;  </span><br><span class="line">49.            &#125; else &#123;  </span><br><span class="line">50.                dirs &#x3D; new File[0];  </span><br><span class="line">51.            &#125;  </span><br><span class="line">52.            return dirs;  </span><br><span class="line">53.        &#125;  </span><br><span class="line">54.  </span><br><span class="line">55.    &#125;</span><br></pre></td></tr></table></figure><p>当然我们可以指定-D java.ext.dirs参数来添加和改变ExtClassLoader的加载路径</p><h2 id="8-2AppClassLoader源码"><a href="#8-2AppClassLoader源码" class="headerlink" title="8.2AppClassLoader源码"></a>8.2AppClassLoader源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.static class AppClassLoader extends URLClassLoader &#123;  </span><br><span class="line">2.  </span><br><span class="line">3.  </span><br><span class="line">4.     public static ClassLoader getAppClassLoader(final ClassLoader extcl)  </span><br><span class="line">5.         throws IOException  </span><br><span class="line">6.     &#123;  </span><br><span class="line">7.         final String s &#x3D; System.getProperty(&quot;java.class.path&quot;);  </span><br><span class="line">8.         final File[] path &#x3D; (s &#x3D;&#x3D; null) ? new File[0] : getClassPath(s);  </span><br><span class="line">9.  </span><br><span class="line">10.    </span><br><span class="line">11.         return AccessController.doPrivileged(  </span><br><span class="line">12.             new PrivilegedAction&lt;AppClassLoader&gt;() &#123;  </span><br><span class="line">13.                 public AppClassLoader run() &#123;  </span><br><span class="line">14.                 URL[] urls &#x3D;  </span><br><span class="line">15.                     (s &#x3D;&#x3D; null) ? new URL[0] : pathToURLs(path);  </span><br><span class="line">16.                 return new AppClassLoader(urls, extcl);  </span><br><span class="line">17.             &#125;  </span><br><span class="line">18.         &#125;);  </span><br><span class="line">19.     &#125;         </span><br><span class="line">20. &#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看到AppClassLoader加载的就是java.class.path下的路径</p><h2 id="8-3-小结"><a href="#8-3-小结" class="headerlink" title="8.3 小结"></a>8.3 小结</h2><p>从上面源码也可以看出，父加载器并不是指其父类，ExtClassLoader和AppClassLoader同样继承自URLClassLoader，这个时候小白童鞋就不耐烦了：那为啥调用AppClassLoader.getParent()方法会得到ExtClassLoader的实例呢？实际上URLClassLoader的源码中也并没有getParent()方法。这个方法在ClassLoader中，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">1.public abstract class ClassLoader &#123;  </span><br><span class="line">2.  </span><br><span class="line">3.&#x2F;&#x2F; The parent class loader for delegation  </span><br><span class="line">4.&#x2F;&#x2F; Note: VM hardcoded the offset of this field, thus all new fields  </span><br><span class="line">5.&#x2F;&#x2F; must be added *after* it.  </span><br><span class="line">6.private final ClassLoader parent;  </span><br><span class="line">7.&#x2F;&#x2F; The class loader for the system  </span><br><span class="line">8.    &#x2F;&#x2F; @GuardedBy(&quot;ClassLoader.class&quot;)  </span><br><span class="line">9.private static ClassLoader scl;  </span><br><span class="line">10.  </span><br><span class="line">11.private ClassLoader(Void unused, ClassLoader parent) &#123;  </span><br><span class="line">12.    this.parent &#x3D; parent;  </span><br><span class="line">13.    ...  </span><br><span class="line">14.&#125;  </span><br><span class="line">15.protected ClassLoader(ClassLoader parent) &#123;  </span><br><span class="line">16.    this(checkCreateClassLoader(), parent);  </span><br><span class="line">17.&#125;  </span><br><span class="line">18.protected ClassLoader() &#123;  </span><br><span class="line">19.    this(checkCreateClassLoader(), getSystemClassLoader());  </span><br><span class="line">20.&#125;  </span><br><span class="line">21.public final ClassLoader getParent() &#123;  </span><br><span class="line">22.    if (parent &#x3D;&#x3D; null)  </span><br><span class="line">23.        return null;  </span><br><span class="line">24.    return parent;  </span><br><span class="line">25.&#125;  </span><br><span class="line">26.public static ClassLoader getSystemClassLoader() &#123;  </span><br><span class="line">27.    initSystemClassLoader();  </span><br><span class="line">28.    if (scl &#x3D;&#x3D; null) &#123;  </span><br><span class="line">29.        return null;  </span><br><span class="line">30.    &#125;  </span><br><span class="line">31.    return scl;  </span><br><span class="line">32.&#125;  </span><br><span class="line">33.  </span><br><span class="line">34.private static synchronized void initSystemClassLoader() &#123;  </span><br><span class="line">35.    if (!sclSet) &#123;  </span><br><span class="line">36.        if (scl !&#x3D; null)  </span><br><span class="line">37.            throw new IllegalStateException(&quot;recursive invocation&quot;);  </span><br><span class="line">38.        sun.misc.Launcher l &#x3D; sun.misc.Launcher.getLauncher();  </span><br><span class="line">39.        if (l !&#x3D; null) &#123;  </span><br><span class="line">40.            Throwable oops &#x3D; null;  </span><br><span class="line">41.            &#x2F;&#x2F;通过Launcher获取ClassLoader  </span><br><span class="line">42.            scl &#x3D; l.getClassLoader();  </span><br><span class="line">43.            try &#123;  </span><br><span class="line">44.                scl &#x3D; AccessController.doPrivileged(  </span><br><span class="line">45.                    new SystemClassLoaderAction(scl));  </span><br><span class="line">46.            &#125; catch (PrivilegedActionException pae) &#123;  </span><br><span class="line">47.                oops &#x3D; pae.getCause();  </span><br><span class="line">48.                if (oops instanceof InvocationTargetException) &#123;  </span><br><span class="line">49.                    oops &#x3D; oops.getCause();  </span><br><span class="line">50.                &#125;  </span><br><span class="line">51.            &#125;  </span><br><span class="line">52.            if (oops !&#x3D; null) &#123;  </span><br><span class="line">53.                if (oops instanceof Error) &#123;  </span><br><span class="line">54.                    throw (Error) oops;  </span><br><span class="line">55.                &#125; else &#123;  </span><br><span class="line">56.                    &#x2F;&#x2F; wrap the exception  </span><br><span class="line">57.                    throw new Error(oops);  </span><br><span class="line">58.                &#125;  </span><br><span class="line">59.            &#125;  </span><br><span class="line">60.        &#125;  </span><br><span class="line">61.        sclSet &#x3D; true;  </span><br><span class="line">62.    &#125;  </span><br><span class="line">63.&#125;  </span><br><span class="line">64.&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码可以看到getParent()实际上返回的就是一个ClassLoader对象parent，parent的赋值是在ClassLoader对象的构造方法中，它有两个情况：</p><p>1、由外部类创建ClassLoader时直接指定一个ClassLoader为parent。</p><p>2、由getSystemClassLoader()方法生成，也就是在sun.misc.Laucher通过getClassLoader()获取，也就是AppClassLoader。简单的说，就是一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。</p><h1 id="9-关于命名空间"><a href="#9-关于命名空间" class="headerlink" title="9. 关于命名空间"></a>9. 关于命名空间</h1><p>命名空间概念：每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成。</p><p>特别注意：</p><ul><li><p>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。</p></li><li><p>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。</p></li><li><p>由子加载器加载的类能看见父加载器的类，由父亲加载器加载的类不能看见子加载器加载的类</p></li></ul><p>我们已经知道每个类只能被加载一次，其实这样说是不够准确的，怎样才算是准确的呢？那就涉及到命名空间的概念了！只有在相同的命名空间中，每个类才只能被加载一次，反过来说就是一个类在不同的命名空间中是可以被加载多次的，而被加载多次的Class对象是互相独立的！</p><h2 id="9-1-如何理解"><a href="#9-1-如何理解" class="headerlink" title="9.1 如何理解"></a>9.1 如何理解</h2><p>出写例子让各位深刻体会一下！当然这些例子涉及自定义加载器的一些知识，建议先对自定义加载器有一定了解在看！</p><p>例子必知前提：</p><p>1、 自己在idea或者eclipse中创建的工程项目中只要编译之后都会有对应的class文件成在classPath目录中</p><p>2、而这些目录是由ApplicationClassLoader应用加载器加载</p><p>3、 我之后会将class文件放到系统桌面地址上，而这些系统地址由自定义加载器指定，所以由自定义加载器加载</p><h2 id="9-2-准备"><a href="#9-2-准备" class="headerlink" title="9.2 准备"></a>9.2 准备</h2><p>事先编译好，然后将项目工程中的两个字节码class文件【File1和File2】拷贝到系统桌面路径上，编译main方法就会出现在项目工程（ClassPath）下，注意以下例子情况中系统桌面路径的class文件一直都存在！</p><ul><li>Main方法情况：</li></ul><ol><li>创建一个自定义加载器classloader2，并声明桌面class文件路径，接着加载File1</li><li>打印File1的加载器</li><li>newInstance出File1的实例</li></ol><ul><li>File1类的方法情况：</li></ul><ol><li>File1的构造方法中存在一行代码：new File2 的new实例代码</li></ol><ul><li>File2类的方法情况：</li></ul><ol><li>打印File2的加载器</li></ol><h2 id="9-3测试代码情景一"><a href="#9-3测试代码情景一" class="headerlink" title="9.3测试代码情景一"></a>9.3测试代码情景一</h2><ul><li><p>删除File1、File2项目工程中的class文件，工程项目的两个class文件都删除（只存在系统桌面路径下的class文件）</p></li><li><p>结果：File1和File2的加载器都是自定义加载器</p></li></ul><h2 id="9-4-测试代码情景二"><a href="#9-4-测试代码情景二" class="headerlink" title="9.4 测试代码情景二"></a>9.4 测试代码情景二</h2><ul><li><p>只删除File1项目工程中的class文件</p></li><li><p>结果：File1的加载器是自定义加载器，而执行到File2实例的加载器是App应用加载器</p></li></ul><h2 id="9-5-测试代码情景三"><a href="#9-5-测试代码情景三" class="headerlink" title="9.5 测试代码情景三"></a>9.5 测试代码情景三</h2><ul><li><p>只删除File2项目工程中的class文件</p></li><li><p>结果：File1的加载器都是APP应用加载器，而执行到File2实例的时候报NoClassDefFoundError异常</p></li></ul><p><strong><em>\</em>得出结论：**</strong>加载一个类（File1）的时候，这个类里面调用了其他的类（File2）或者其他类方法的初始化代码，那么这里面的类也会试着从这个类的加载器开始向上委托加载，如果全都加载不了加载不了就报NoClassDefFoundError异常。</p><p>当然这样理解命名空间和类加载机制还是远远不够的！</p><h2 id="修改条件：File2类中发生改变情况如下："><a href="#修改条件：File2类中发生改变情况如下：" class="headerlink" title="^^修改条件：File2类中发生改变情况如下："></a>^^修改条件：File2类中发生改变情况如下：</h2><ol><li>File1的构造方法中存在一行new File2的实例这没变</li><li>在File2的构造方法中，打印（访问）File1的class文件</li></ol><h2 id="9-6-测试代码情景四"><a href="#9-6-测试代码情景四" class="headerlink" title="9.6 测试代码情景四"></a>9.6 测试代码情景四</h2><p>只删除项目工程中File1的class文件</p><p>结果：File1的加载器都是自定义加载器，而执行到File2实例的加载器是App应用加载器，当运行到File2构造方法中的打印（访问）File1的class文件的时候报NoClassDefFoundError异常</p><p><strong><em>\</em>得出结论：*****</strong>*父亲加载器加载的类（File2）不能看见子加载器加载的类（*<strong>**</strong>*File1*<strong>**</strong>*）****</p><h2 id="修改条件：File1方法发生改变情况如下："><a href="#修改条件：File1方法发生改变情况如下：" class="headerlink" title="^^修改条件：File1方法发生改变情况如下："></a>^^修改条件：File1方法发生改变情况如下：</h2><p>1、Main方法中newInstance出File1的实例，File1的构造方法中存在一行new File2的实例这都没变<br>2、在File1的构造方法中，打印File2的class文件</p><h2 id="9-7测试代码情景五"><a href="#9-7测试代码情景五" class="headerlink" title="9.7测试代码情景五"></a>9.7测试代码情景五</h2><p>只删除File1项目工程中的class文件</p><p>结果：File1的加载器都是自定义加载器，而执行到File2实例的加载器是App应用加载器，当运行到File1构造方法中的打印File2的class文件的时候没问题</p><p><strong><em>\</em>得出结论：由子加载器加载的类（File1）能看见父加载器的类（File2）**</strong></p><p><strong><em>\</em>当然还要注意知道的一点的是：*****</strong>*如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载类相互不可见。****</p><h1 id="10-JVM类加载机制"><a href="#10-JVM类加载机制" class="headerlink" title="10. JVM类加载机制"></a>10. JVM类加载机制</h1><p>JVM的类加载机制主要有如下3种。</p><ul><li>全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li></ul><ul><li>父类委托：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类，通俗讲就是儿子们都他么是懒猪，自己不管能不能做，就算能加载也先不干，先给自己的父亲做，一个一个往上抛，直到抛到启动类加载器也就是最顶级父类，只有父亲做不了的时候再没办法由下一个子类做，直到能某一个子类能做才做，之后的子类就直接返回，实力坑爹！</li></ul><ul><li>缓存机制：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li></ul><h1 id="11-双亲委派模型"><a href="#11-双亲委派模型" class="headerlink" title="11. 双亲委派模型"></a>11. 双亲委派模型</h1><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。也就是实力坑爹！</p><p>双亲委派机制:</p><ol><li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li><li>当 ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li><li>如果 BootStrapClassLoader加载失败（例如在 $JAVA_HOME/jre/lib里未查找到该class），会使用 ExtClassLoader来尝试加载；</li><li>若ExtClassLoader也加载失败，则会使用 AppClassLoader来加载，如果 AppClassLoader也加载失败，则会报出异常 ClassNotFoundException。</li></ol><p><img src="jvm-2-ljz.assets/image-20200530001844284.png" alt="image-20200530001844284"></p><p>从代码层面了解几个Java中定义的类加载器及其双亲委派模式的实现，它们类图关系如下：</p><p><img src="jvm-2-ljz.assets/image-20200530001857810.png" alt="image-20200530001857810"></p><p>从图可以看出顶层的类加载器是抽象类ClassLoader类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器），为了更好理解双亲委派模型，ClassLoader源码中的loadClass(String)方法该方法加载指定名称（包括包名）的二进制类型，该方法在JDK1.2之后不再建议用户重写但用户可以直接调用该方法，loadClass()方法是ClassLoader类自己实现的，该方法中的逻辑就是双亲委派模式的实现，loadClass(String name, boolean resolve)是一个重载方法，resolve参数代表是否生成class对象的同时进行解析相关操作。源码分析如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1.public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line">2.       return loadClass(name, false);  </span><br><span class="line">3.   &#125;  </span><br><span class="line">4.  </span><br><span class="line">5.rotected Class&lt;?&gt; loadClass(String name, boolean resolve)  </span><br><span class="line">6.     throws ClassNotFoundException  </span><br><span class="line">7. &#123;  </span><br><span class="line">8.     synchronized (getClassLoadingLock(name)) &#123;  </span><br><span class="line">9.         &#x2F;&#x2F; 先从缓存查找该class对象，找到就不用重新加载  </span><br><span class="line">10.         Class&lt;?&gt; c &#x3D; findLoadedClass(name);  </span><br><span class="line">11.         if (c &#x3D;&#x3D; null) &#123;  </span><br><span class="line">12.             long t0 &#x3D; System.nanoTime();  </span><br><span class="line">13.             try &#123;  </span><br><span class="line">14.                 if (parent !&#x3D; null) &#123;  </span><br><span class="line">15.                     &#x2F;&#x2F;如果找不到，则委托给父类加载器去加载  </span><br><span class="line">16.                     c &#x3D; parent.loadClass(name, false);  </span><br><span class="line">17.                 &#125; else &#123;  </span><br><span class="line">18.                 &#x2F;&#x2F;如果没有父类，则委托给启动加载器去加载  </span><br><span class="line">19.                     c &#x3D; findBootstrapClassOrNull(name);  </span><br><span class="line">20.                 &#125;  </span><br><span class="line">21.             &#125; catch (ClassNotFoundException e) &#123;  </span><br><span class="line">22.                 &#x2F;&#x2F; ClassNotFoundException thrown if class not found  </span><br><span class="line">23.                 &#x2F;&#x2F; from the non-null parent class loader  </span><br><span class="line">24.             &#125;  </span><br><span class="line">25.  </span><br><span class="line">26.             if (c &#x3D;&#x3D; null) &#123;  </span><br><span class="line">27.                 &#x2F;&#x2F; If still not found, then invoke findClass in order  </span><br><span class="line">28.                 &#x2F;&#x2F; 如果都没有找到，则通过自定义实现的findClass去查找并加载  </span><br><span class="line">29.                 c &#x3D; findClass(name);  </span><br><span class="line">30.  </span><br><span class="line">31.                 &#x2F;&#x2F; this is the defining class loader; record the stats  </span><br><span class="line">32.                 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);  </span><br><span class="line">33.                 sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);  </span><br><span class="line">34.                 sun.misc.PerfCounter.getFindClasses().increment();  </span><br><span class="line">35.             &#125;  </span><br><span class="line">36.         &#125;  </span><br><span class="line">37.         if (resolve) &#123;&#x2F;&#x2F;是否需要在加载时进行解析  </span><br><span class="line">38.             resolveClass(c);  </span><br><span class="line">39.         &#125;  </span><br><span class="line">40.         return c;  </span><br><span class="line">41.     &#125;  </span><br><span class="line">42. &#125;</span><br></pre></td></tr></table></figure><p>双亲委派模型的意义主要是：Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p><p>双亲委派模型意义总结来讲就是：<br>1、系统类防止内存中出现多份同样的字节码<br>2、保证Java程序安全稳定运行</p><h1 id="12-ClassLoader源码分析"><a href="#12-ClassLoader源码分析" class="headerlink" title="12.ClassLoader源码分析"></a>12.ClassLoader源码分析</h1><p>ClassLoader类是一个抽象类，所有的类加载器都继承自ClassLoader（不包括启动类加载器），因此它显得格外重要，分析ClassLoader抽象类也是非常重要的！</p><p>简单小结一下ClassLoader抽象类中一些概念：</p><p>二进制概念（Binary name）：格式如下</p><p><img src="jvm-2-ljz.assets/image-20200530001954466.png" alt="image-20200530001954466"></p><p>把二进制名字转换成文件名字，然后在文件系统中磁盘上读取其二进制文件（class文件），每一个class对象都包含了定义了这个类的classload对象，class类都是由类加载器加载的只有数组类型是由JVM根据需要动态生成。</p><p>特别注意数组类型：</p><ul><li><p>数组类的类对象不是由类加载器创建的，而是根据Java运行时的需要自动创建的。</p></li><li><p>数组类的类加载器getClassLoader()与它的元素类型的类加载器相同;如果元素类型是基本类型，则数组类没有类加载器也就是null，而这个null不同于根类加载器返回的null，它是单纯的null。</p></li></ul><p>到这里，下面就主要分析ClassLoader抽象类中几个比较重要的方法。</p><h2 id="12-1-loadClass"><a href="#12-1-loadClass" class="headerlink" title="12.1 loadClass"></a>12.1 loadClass</h2><p>该方法加载指定名称（包括包名）的二进制类型，该方法在JDK1.2之后不再建议用户重写但用户可以直接调用该方法，loadClass()方法是ClassLoader类自己实现的，该方法中的逻辑就是双亲委派模式的实现，其源码如下，loadClass(String name, boolean resolve)是一个重载方法，resolve参数代表是否生成class对象的同时进行解析相关操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line">       return loadClass(name, false);  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">rotected Class&lt;?&gt; loadClass(String name, boolean resolve)  </span><br><span class="line">     throws ClassNotFoundException  </span><br><span class="line"> &#123;  </span><br><span class="line">     synchronized (getClassLoadingLock(name)) &#123;  </span><br><span class="line">         &#x2F;&#x2F; 先从缓存查找该class对象，找到就不用重新加载  </span><br><span class="line">         Class&lt;?&gt; c &#x3D; findLoadedClass(name);  </span><br><span class="line">         if (c &#x3D;&#x3D; null) &#123;  </span><br><span class="line">             long t0 &#x3D; System.nanoTime();  </span><br><span class="line">             try &#123;  </span><br><span class="line">                 if (parent !&#x3D; null) &#123;  </span><br><span class="line">                     &#x2F;&#x2F;如果找不到，则委托给父类加载器去加载  </span><br><span class="line">                     c &#x3D; parent.loadClass(name, false);  </span><br><span class="line">                 &#125; else &#123;  </span><br><span class="line">                 &#x2F;&#x2F;如果没有父类，则委托给启动加载器去加载  </span><br><span class="line">                     c &#x3D; findBootstrapClassOrNull(name);  </span><br><span class="line">                 &#125;  </span><br><span class="line">             &#125; catch (ClassNotFoundException e) &#123;  </span><br><span class="line">                 &#x2F;&#x2F; ClassNotFoundException thrown if class not found  </span><br><span class="line">                 &#x2F;&#x2F; from the non-null parent class loader  </span><br><span class="line">             &#125;  </span><br><span class="line">  </span><br><span class="line">             if (c &#x3D;&#x3D; null) &#123;  </span><br><span class="line">                 &#x2F;&#x2F; If still not found, then invoke findClass in order  </span><br><span class="line">                 &#x2F;&#x2F; 如果都没有找到，则通过自定义实现的findClass去查找并加载  </span><br><span class="line">                 c &#x3D; findClass(name);  </span><br><span class="line">  </span><br><span class="line">                 &#x2F;&#x2F; this is the defining class loader; record the stats  </span><br><span class="line">                 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);  </span><br><span class="line">                 sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);  </span><br><span class="line">                 sun.misc.PerfCounter.getFindClasses().increment();  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">         if (resolve) &#123;&#x2F;&#x2F;是否需要在加载时进行解析  </span><br><span class="line">             resolveClass(c);  </span><br><span class="line">         &#125;  </span><br><span class="line">         return c;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>正如loadClass方法所展示的，当类加载请求到来时，先从缓存中查找该类对象，如果存在直接返回，如果不存在则交给该类加载去的父加载器去加载，倘若没有父加载则交给顶级启动类加载器去加载，最后倘若仍没有找到，则使用findClass()方法去加载（关于findClass()稍后会进一步介绍）。从loadClass实现也可以知道如果不想重新定义加载类的规则，也没有复杂的逻辑，只想在运行时加载自己指定的类，那么我们可以直接使用this.getClass().getClassLoder.loadClass(“className”)，这样就可以直接调用ClassLoader的loadClass方法获取到class对象。</p><h2 id="12-2-findClass"><a href="#12-2-findClass" class="headerlink" title="12.2 findClass"></a>12.2 findClass</h2><p>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛出ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的(稍后会分析)，ClassLoader类中findClass()方法源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;&#x2F;直接抛出异常  </span><br><span class="line">2.protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line">3.        throw new ClassNotFoundException(name);  </span><br><span class="line">4.&#125;</span><br></pre></td></tr></table></figure><h2 id="12-3-defineClass-byte-b-int-off-int-len"><a href="#12-3-defineClass-byte-b-int-off-int-len" class="headerlink" title="12.3 defineClass(byte[] b, int off, int len)"></a>12.3 defineClass(byte[] b, int off, int len)</h2><p>defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象(ClassLoader中已实现该方法逻辑)，通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象，defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象，简单例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line">2.      &#x2F;&#x2F; 获取类的字节数组  </span><br><span class="line">3.      byte[] classData &#x3D; getClassData(name);    </span><br><span class="line">4.      if (classData &#x3D;&#x3D; null) &#123;  </span><br><span class="line">5.          throw new ClassNotFoundException();  </span><br><span class="line">6.      &#125; else &#123;  </span><br><span class="line">7.          &#x2F;&#x2F;使用defineClass生成class对象  </span><br><span class="line">8.          return defineClass(name, classData, 0, classData.length);  </span><br><span class="line">9.      &#125;  </span><br><span class="line">10.  &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果直接调用defineClass()方法生成类的Class对象，这个类的Class对象并没有解析(也可以理解为链接阶段，毕竟解析是链接的最后一步)，其解析操作需要等待初始化阶段进行。</p><h2 id="12-4resolveClass-Class-lt-gt-c"><a href="#12-4resolveClass-Class-lt-gt-c" class="headerlink" title="12.4resolveClass (Class&lt;?&gt;c)"></a>12.4resolveClass (Class&lt;?&gt;c)</h2><p>使用该方法可以使用类的Class对象创建完成也同时被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p><h2 id="12-5-ClassLoader小结"><a href="#12-5-ClassLoader小结" class="headerlink" title="12.5 ClassLoader小结"></a>12.5 ClassLoader小结</h2><p>以上上述4个方法是ClassLoader类中的比较重要的方法，也是我们可能会经常用到的方法。接看SercureClassLoader扩展了 ClassLoader，新增了几个与使用相关的代码源(对代码源的位置及其证书的验证)和权限定义类验证(主要指对class源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联，前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如 findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现，并新增了URLClassPath类协助取得Class字节码流等功能，在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p><p>检查完父类加载器之后loadClass会去默认调用findClass方法，父类（ClassLoader）中的findClass方法主要是抛出一个异常。</p><p>findClass根据二进制名字找到对应的class文件，返回值为Class对象Class&lt;?&gt;</p><p>defineClass这个方法主要是将一个字节数组转换成Class实例，会抛三个异常，但只是threws一个，因为其他两个是运行时异常。</p><p>loadClass方法是一个加载一个指定名字的class文件，调用findLoadedClass (String)检查类是否已经加载…如果已经加装就不再加载而是直接返回第一次加载结果 所以一个类只会加载一次</p><h1 id="13-自定义类加载器"><a href="#13-自定义类加载器" class="headerlink" title="13 自定义类加载器"></a>13 自定义类加载器</h1><p>自定义核心目的是扩展java虚拟机的动态加载类的机制，JVM默认情况是使用双亲委托机制，虽然双亲委托机制很安全极高但是有些情况我们需要自己的一种方式加载，比如应用是通过网络来传输 Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。因此自定义类加载器也是很有必要的。</p><p>自定义类加载器一般都是继承自 ClassLoader类，从上面对 loadClass方法来分析来看，我们只需要重写 findClass 方法即可。自定义加载器中点：重写findClass，下面直接看自定义类加载器代码的流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class MyClassLoader extends ClassLoader &#123;  </span><br><span class="line">    private String root;  </span><br><span class="line">  </span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line">        byte[] classData &#x3D; loadClassData(name);  </span><br><span class="line">        if (classData &#x3D;&#x3D; null) &#123;  </span><br><span class="line">            throw new ClassNotFoundException();  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            return defineClass(name, classData, 0, classData.length);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F;自定义解析流方法</span><br><span class="line">    private byte[] loadClassData(String className) &#123;  </span><br><span class="line">        String fileName &#x3D; root + File.separatorChar  </span><br><span class="line">                + className.replace(&#39;.&#39;, File.separatorChar) + &quot;.class&quot;;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            InputStream ins &#x3D; new FileInputStream(fileName);  </span><br><span class="line">            ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();  </span><br><span class="line">            int bufferSize &#x3D; 1024;  </span><br><span class="line">            byte[] buffer &#x3D; new byte[bufferSize];  </span><br><span class="line">            int length &#x3D; 0;  </span><br><span class="line">            while ((length &#x3D; ins.read(buffer)) !&#x3D; -1) &#123;  </span><br><span class="line">                baos.write(buffer, 0, length);  </span><br><span class="line">            &#125;  </span><br><span class="line">            return baos.toByteArray();  </span><br><span class="line">        &#125; catch (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return null;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public String getRoot() &#123;  </span><br><span class="line">        return root;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void setRoot(String root) &#123;  </span><br><span class="line">        this.root &#x3D; root;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args)  &#123;  </span><br><span class="line">  </span><br><span class="line">        MyClassLoader classLoader &#x3D; new MyClassLoader();  </span><br><span class="line">        classLoader.setRoot(&quot;D:\\dirtemp&quot;);  </span><br><span class="line">  </span><br><span class="line">        Class&lt;?&gt; testClass &#x3D; null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">&#x2F;&#x2F;loadClass方法中会调用  重写的findClass方法</span><br><span class="line">            testClass &#x3D; classLoader.loadClass(&quot;com.yichun.classloader.Demo1&quot;);  </span><br><span class="line">            Object object &#x3D; testClass.newInstance();  </span><br><span class="line">            System.out.println(object.getClass().getClassLoader());  </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; catch (InstantiationException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。上面代码程序只是简单Demo，并未对class文件进行加密，因此省略了解密的过程。这里有几点需要注意：</p><ol><li>这里传递的文件名需要是类的全限定性名称，即com.yichun.test.classloading.Test格式的，因为defineClass 方法是按这种格式进行处理的。</li><li>最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</li><li>这类Test 类本身可以被 AppClassLoader类加载，因此我们不能把com/yichun/test/classloading/Test.class放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由AppClassLoader加载，而不会通过我们自定义类加载器来加载。</li></ol><h1 id="14-加载类的三种方式"><a href="#14-加载类的三种方式" class="headerlink" title="14. 加载类的三种方式"></a>14. 加载类的三种方式</h1><p>到这里，相信大家已经对类的加载以及加载器有一定的了解了，那么你知道吗，其实加载类常见的有三种方式，如下：</p><ol><li>静态加载，也就是通过new关键字来创建实例对象。</li><li>动态加载，也就是通过Class.forName()方法动态加载（反射加载类型），然后调用类的newInstance()方法实例化对象。</li><li>动态加载，通过类加载器的loadClass()方法来加载类，然后调用类的newInstance()方法实例化对象</li></ol><h2 id="14-1-三种方式的区别"><a href="#14-1-三种方式的区别" class="headerlink" title="14.1 三种方式的区别"></a>14.1 三种方式的区别</h2><ol><li>第一种和第二种方式使用的类加载器是相同的，都是当前类加载器。（this.getClass.getClassLoader）。而3由用户指定类加载器。</li><li>如果需要在当前类路径以外寻找类，则只能采用第3种方式。第3种方式加载的类与当前类分属不同的命名空间。</li><li>第一种是静态加载，而第二、三种是动态加载。</li></ol><h2 id="14-2-两种异常"><a href="#14-2-两种异常" class="headerlink" title="14.2 两种异常"></a>14.2 两种异常</h2><ol><li>1静态加载的时候如果在运行环境中找不到要初始化的类,抛出的是NoClassDefFoundError,它在JAVA的异常体系中是一个Error</li><li>动态态加载的时候如果在运行环境中找不到要初始化的类,抛出的是ClassNotFoundException,它在JAVA的异常体系中是一个checked异常</li></ol><h2 id="14-3理解Class-forName"><a href="#14-3理解Class-forName" class="headerlink" title="14.3理解Class.forName"></a>14.3理解Class.forName</h2><p>Class.forName()是一种获取Class对象的方法，而且是静态方法。</p><p>Class.forName()是一个静态方法，同样可以用来加载类，Class.forName()返回与给定的字符串名称相关联类或接口的Class对象。注意这是一种获取Class对象的方法</p><p>官方给出的API文档如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">publicstatic Class&lt;?&gt; forName(String className)  </span><br><span class="line">  </span><br><span class="line">Returns the Class object associated withthe class or interface with the given string name. Invokingthis method is equivalent to:  </span><br><span class="line">  </span><br><span class="line">Class.forName(className,true, currentLoader)  </span><br><span class="line">  </span><br><span class="line">where currentLoader denotes the definingclass loader of the current class.  </span><br><span class="line">  </span><br><span class="line">For example, thefollowing code fragment returns the runtime Class descriptor for theclass named java.lang.Thread:  </span><br><span class="line">  </span><br><span class="line">Class t &#x3D;Class.forName(&quot;java.lang.Thread&quot;)  </span><br><span class="line">  </span><br><span class="line">A call to forName(&quot;X&quot;) causes theclass named X to beinitialized.  </span><br><span class="line">  </span><br><span class="line">Parameters:  </span><br><span class="line">  </span><br><span class="line">className - the fully qualifiedname of the desired class.  </span><br><span class="line">  </span><br><span class="line">Returns:  </span><br><span class="line">  </span><br><span class="line">the Class object for the classwith the specified name.</span><br></pre></td></tr></table></figure><p>可以看出，Class.forName(className)实际上是调用Class.forName(className,true, this.getClass().getClassLoader())。第二个参数，是指Class被loading后是不是必须被初始化。可以看出，使用Class.forName（className）加载类时则已初始化。所以Class.forName()方法可以简单的理解为：获得字符串参数中指定的类，并初始化该类。</p><p>这个时候，我们再来看一个程序：‘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.jvm.classloader;  </span><br><span class="line">  </span><br><span class="line">class Demo&#123;  </span><br><span class="line">    static &#123;  </span><br><span class="line">        System.out.println(&quot;static 静态代码块&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public class ClassLoaderDemo &#123;  </span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;  </span><br><span class="line">        ClassLoader classLoader&#x3D;ClassLoaderDemo.class.getClassLoader();  </span><br><span class="line">        &#x2F;&#x2F;1、使用ClassLoader.loadClass()来加载类，不会执行初始化块  </span><br><span class="line">        classLoader.loadClass(&quot;com.jvm.classloader.Demo&quot;);  </span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;2、使用Class.forName()来加载类，默认会执行初始化块  </span><br><span class="line">        Class.forName(&quot;com.jvm.classloader.Demo&quot;);  </span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;3、使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块   </span><br><span class="line">        Class.forName(&quot;com.jvm.classloader.Demo&quot;,false,classLoader);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-总结"><a href="#15-总结" class="headerlink" title="15. 总结"></a>15. 总结</h1><h2 id="15-1-类的加载、连接与初始化"><a href="#15-1-类的加载、连接与初始化" class="headerlink" title="15.1 类的加载、连接与初始化"></a>15.1 类的加载、连接与初始化</h2><p>1、加载：查找并加载类的二进制数据到java虚拟机中<br>2、 连接：</p><ul><li>(1) 验证： 确保被加载的类的正确性</li><li>(2) 准备：为类的静态变量分配内存，并将其初始化为默认值，但是到达初始化之前类变量都没有初始化为真正的初始值（如果是被 final 修饰的类变量，则直接会被初始成用户想要的值。）</li><li>(3) 解析：把类中的符号引用转换为直接引用，就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程</li></ul><p>3、 初始化：为类的静态变量赋予正确的初始值<br>类从磁盘上加载到内存中要经历五个阶段：加载、连接、初始化、使用、卸载</p><h2 id="15-2-Java程序对类的使用方式可分为两种"><a href="#15-2-Java程序对类的使用方式可分为两种" class="headerlink" title="15.2 Java程序对类的使用方式可分为两种"></a>15.2 Java程序对类的使用方式可分为两种</h2><p>主动使用、被动使用</p><p>所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才能初始化他们</p><p><strong><em>\</em>主动使用**</strong></p><p>(1) 创建类的实例</p><p>(2) 访问某个类或接口的静态变量 getstatic（助记符），或者对该静态变量赋值 putstatic</p><p>(3) 调用类的静态方法 invokestatic</p><p>(4) 反射（Class.forName(“com.test.Test”)）</p><p>(5) 初始化一个类的子类</p><p>(6) Java虚拟机启动时被标明启动类的类以及包含Main方法的类</p><p>(7) JDK1.7开始提供的动态语言支持（了解）</p><p><strong><em>\</em>被动使用**</strong><br>除了上面七种情况外，其他使用java类的方式都被看做是对类的被动使用，都不会导致类的初始化</p><h1 id="16-特别注意"><a href="#16-特别注意" class="headerlink" title="16. 特别注意"></a>16. 特别注意</h1><p>初始化入口方法。当进入类加载的初始化阶段后，JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。当需要对一个类进行初始化时，会首先初始化类构造器（），之后初始化对象构造器（）。</p><ul><li><p>初始化类构造器：JVM 会按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器由 JVM 执行。</p></li><li><p>初始化对象构造器：JVM 会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终由 JVM 执行。值得特别注意的是，如果没有监测或者收集到构造函数的代码，则将不会执行对象初始化方法。对象初始化方法一般在实例化类对象的时候执行。</p></li></ul><p>如果在初始化 main 方法所在类的时候遇到了其他类的初始化，那么就先加载对应的类，加载完成之后返回。如此反复循环，最终返回 main 方法所在类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h1&gt;&lt;p&gt;你是否真的理解java的类加载机制？点进文章的盆友不如先来做一道非常常见的面试题，如果你能做出来，可能你早已掌握并理解了
      
    
    </summary>
    
    
    
      <category term="JVM" scheme="https://dcghx.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>IO————1</title>
    <link href="https://dcghx.github.io/2020/05/09/IO-1/"/>
    <id>https://dcghx.github.io/2020/05/09/IO-1/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-30T15:41:34.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-IO流的概念"><a href="#1-IO流的概念" class="headerlink" title="1. IO流的概念"></a>1. IO流的概念</h1><p>流存在的意义：</p><ol><li><p>数据的传输量很大</p></li><li><p>内存有限</p></li><li><p>带宽有限<a id="more"></a></p></li></ol><p>而Stream可以1点1点地逐步传输所有数据, 这就是Stream存在的根本意义。想想我们是怎样下载1个大文件的, 下载软件(例如x雷)并不会占用你内存很大的空间, 而只是在内存划分1个缓冲区, 一点一点地下载到自己的内存(缓冲区满了再写到硬盘), 这也是流的1个例子。</p><p>java的io是实现输入和输出的基础，可以方便的实现数据的输入和输出操作。在java中把不同的输入/输出源（键盘，文件，网络连接等）抽象表述为“流”(stream)。通过流的形式允许java程序使用相同的方式来访问不同的输入/输出源。stram是从起源（source）到接收的（sink）的有序数据。</p><p>Stream是java的1个类, 这个类专门用于程序和外部设备的输入输出(IO). 基本上所有流都在 java.io这个包中.实际上Stream就是数据在程序和外部设备的单向管道, 流的各种方法相当于管道上的各种按钮. 所谓的外部设备可以包括硬盘文件, 网络设备, 另个程序等. 也就是当前程序之外的数据设备</p><p>Java将所有传统的流类型都放在Java.io包下，用于实现输入和输出功能。</p><h1 id="2-Io-流的分类（详解）"><a href="#2-Io-流的分类（详解）" class="headerlink" title="2. Io 流的分类（详解）"></a>2. Io 流的分类（详解）</h1><p>按照流的不同的分类方式，可以把流分为不同的类型，流常见的分类有3种：按照流的流向分、按照操作单元划分、按照流的角色划分</p><p>java的输入流主要是InputStream和Reader作为基类，而输出流则是主要由outputStream和Writer作为基类</p><h2 id="2-1按照流的流向分：输入流和输出流"><a href="#2-1按照流的流向分：输入流和输出流" class="headerlink" title="2.1按照流的流向分：输入流和输出流"></a>2.1按照流的流向分：输入流和输出流</h2><ul><li><p>输入流： 只能从中读取数据，而不能向其写入数据。</p></li><li><p>输出流：只能向其写入数据，而不能向其读取数据。</p></li></ul><p>此处的输入,输出涉及一个方向的问题，也就是说，这里的输入，输出都是以程序运行所在的内存为参照点的。</p><h2 id="2-2按照操作单元划分：字节流和字符流"><a href="#2-2按照操作单元划分：字节流和字符流" class="headerlink" title="2.2按照操作单元划分：字节流和字符流"></a>2.2按照操作单元划分：字节流和字符流</h2><p>字节流主要用于读写二进制文件；字符流主要用于读写文本性文件</p><p>字节流和字符流的用法几乎完成全一样，区别在于字节流和字符流所操作的数据单元不同，字节流操作的单元是数据单元是8位的字节，字符流操作的是数据单元为16位的字符。</p><p>字节流读取单个字节，字符流读取单个字符（一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码是 3 个字节，中文编码是 2 个字节。）字节流用来处理二进制文件（图片、MP3、视频文件），字符流用来处理文本文件（可以看做是特殊的二进制文件，使用了某种编码，人可以阅读）。简而言之，字节是个计算机看的，字符才是给人看的。<br> 字节流主要是由InputStream和outPutStream作为基类，而字符流则主要有Reader和Writer作为基类。</p><p>字节流和字符流的划分可以看下面这张图。</p><p><img src="IO-1.assets/image-20200530233315099.png" alt="image-20200530233315099"></p><h2 id="2-3-按照流的角色：节点流和处理流"><a href="#2-3-按照流的角色：节点流和处理流" class="headerlink" title="2.3 按照流的角色：节点流和处理流"></a>2.3 按照流的角色：节点流和处理流</h2><p><img src="IO-1.assets/image-20200530233427685.png" alt="image-20200530233427685"></p><p>可以从/向一个特定的IO设备（如磁盘，网络）读/写数据的流，称为节点流。节点流也被称为低级流。图15.3显示了节点流的示意图。 当使用节点流进行输入和输出时，程序直接连接到实际的数据源，和实际的输入/输出节点连接。 </p><p>处理流则用于对一个已存在的流进行连接和封装，通过封装后的流来实现数据的读/写功能。处理流也被称为高级流。</p><h3 id="2-3-1节点流"><a href="#2-3-1节点流" class="headerlink" title="2.3.1节点流"></a>2.3.1节点流</h3><p><img src="IO-1.assets/image-20200530233455644.png" alt="image-20200530233455644"></p><ul><li><p>File文件流(对文件进行读/写操作)：FileReader、FileWriter、FileInputStream、FileOutputStream</p></li><li><p>Memory (数组)：从/向内存数组读写数据: CharArrayReader与 CharArrayWriter、ByteArrayInputStream与ByteArrayOutputStream。 </p></li><li><p>Pipe管道流(实现管道的输入和输出(进程间通信)): PipedReader与PipedWriter、PipedInputStream与PipedOutputStream</p></li></ul><p>节点流执行图示：</p><p><img src="IO-1.assets/image-20200530233537958.png" alt="image-20200530233537958"></p><h3 id="2-3-2-处理流"><a href="#2-3-2-处理流" class="headerlink" title="2.3.2  处理流"></a>2.3.2  处理流</h3><p><img src="IO-1.assets/image-20200530233556630.png" alt="image-20200530233556630"></p><ul><li><p>Buffering缓冲流：在读入或写出时，对数据进行缓存，以减少I/O的次数：BufferedReader与BufferedWriter、BufferedInputStream与BufferedOutputStream。 </p></li><li><p>Filtering 滤流：在数据进行读或写时进行过滤：FilterReader与FilterWriter、FilterInputStream与FilterOutputStream。 </p></li><li><p>Converting between Bytes and Characters 转换流：按照一定的编码/解码标准将字节流转换为字符流，或进行反向转换（Stream到Reader）：InputStreamReader、OutputStreamWriter。 </p></li><li><p>Object Serialization对象流 (序列化)：ObjectInputStream、ObjectOutputStream。 </p></li><li><p>DataConversion数据流： 按基本数据类型读、写（处理的数据是Java的基本类型（如布尔型，字节，整数和浮点数））：DataInputStream、DataOutputStream 。 </p></li><li><p>Counting计数流：在读入数据时对行记数 ：LineNumberReader、LineNumberInputStream。 </p></li><li><p>Peeking Ahead预读流,(通过缓存机制进行预读)：PushbackReader、PushbackInputStream。 </p></li><li><p>Printing打印流(包含方便的打印方法)：PrintWriter、PrintStream。</p></li></ul><p>处理流的执行图示</p><p><img src="IO-1.assets/image-20200530233646985.png" alt="image-20200530233646985"></p><h4 id="2-3-2-1-缓冲流"><a href="#2-3-2-1-缓冲流" class="headerlink" title="2.3.2.1 缓冲流"></a>2.3.2.1 缓冲流</h4><p>缓冲流（buffering）是处理流的一种，对I/O进行缓冲是一种常见的性能优化，缓冲流为I/O流增加了内存缓冲区，增加缓冲区的两个目的： </p><ul><li><p>允许Java的I/O一次不只操作一个字符，这样提高整个系统的性能</p></li><li><p>由于有缓冲区，使得在流上执行skip、mark和reset方法都成为可能</p></li></ul><p><strong><em>\</em>JAVA中mark()和reset()用法的通俗理解**</strong></p><p><strong><em>\</em>mark就像书签一样，在这个BufferedReader对应的buffer里作个标记，以后再调用reset时就可以再回到这个mark过的地方。mark方法有个参数，通过这个整型参数，你告诉系统，希望在读出这么多个字符之前，这个mark保持有效。读过这么多字符之后，系统可以使mark不再有效，而你不能觉得奇怪或怪罪它。这跟buffer有关，如果你需要很长的距离，那么系统就必须分配很大的buffer来保持你的mark。**</strong>  </p><p><strong><em>\</em>skip()方法用于跳过前面n个元素，然后再返回新的流**</strong></p><p>缓冲流：它是要“套接”在相应的节点流之上，对读写的数据提供了缓冲的功能，<br>提高了读写的效率，同时增加了一些新的方法。例如：BufferedReader中的readLine方法，<br>BufferedWriter中的newLine方法。</p><p>j2sdk提供了4种缓冲流，重用的构造方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;&#x2F;字符输入流  </span><br><span class="line">2.BufferedReader(Reader in)&#x2F;&#x2F;创建一个32字节的缓冲区  </span><br><span class="line">3.BufferedReader(Reader in, int size)&#x2F;&#x2F;size为自定义缓存区的大小  </span><br><span class="line">4.   </span><br><span class="line">5.&#x2F;&#x2F;字符输出流  </span><br><span class="line">6.BufferedWriter(Writer out)  </span><br><span class="line">7.BufferedWriter(Writer out, int size)  </span><br><span class="line">8.   </span><br><span class="line">9.&#x2F;&#x2F;字节输入流  </span><br><span class="line">10.BufferedInputStream(InputStream in)  </span><br><span class="line">11.BufferedInputStream(InputStream in, int size)  </span><br><span class="line">12.   </span><br><span class="line">13.&#x2F;&#x2F;字节输出流  </span><br><span class="line">14.BufferedOutputStream(OutputStream in)  </span><br><span class="line">15.BufferedOutputStream(OutputStream in, int size)</span><br></pre></td></tr></table></figure><p>备注：</p><ul><li><p>缓冲输入流BufferedInputSTream除了支持read和skip方法意外，还支持其父类的mark和reset方法; </p></li><li><p>BufferedReader提供了一种新的ReadLine方法用于读取一行字符串（以\r或\n分隔）; </p></li><li><p>BufferedWriter提供了一种新的newLine方法用于写入一个行分隔符; </p></li><li><p>对于输出的缓冲流，BufferedWriter和BufferedOutputStream，写出的数据会先在内存中缓存， </p></li></ul><p>使用flush方法将会使内存的数据立刻写出。</p><h1 id="3-Io-流的分类（图示）"><a href="#3-Io-流的分类（图示）" class="headerlink" title="3.Io 流的分类（图示）"></a>3.Io 流的分类（图示）</h1><p>java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java Io流的40多个类都是从如下4个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><img src="IO-1.assets/image-20200530233908792.png" alt="image-20200530233908792" style="zoom:200%;" /><p>java输入/输出流体系中常用的流的分类表</p><p><img src="IO-1.assets/image-20200530234106977.png" alt="image-20200530234106977"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-IO流的概念&quot;&gt;&lt;a href=&quot;#1-IO流的概念&quot; class=&quot;headerlink&quot; title=&quot;1. IO流的概念&quot;&gt;&lt;/a&gt;1. IO流的概念&lt;/h1&gt;&lt;p&gt;流存在的意义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;数据的传输量很大&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存有限&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;带宽有限
    
    </summary>
    
    
    
      <category term="IO" scheme="https://dcghx.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>spring-1</title>
    <link href="https://dcghx.github.io/2020/05/09/spring-1/"/>
    <id>https://dcghx.github.io/2020/05/09/spring-1/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-30T16:18:32.281Z</updated>
    
    <content type="html"><![CDATA[<p>简单认识一下spring<a id="more"></a></p><h1 id="1-Spring-Framework-模块"><a href="#1-Spring-Framework-模块" class="headerlink" title="1.Spring Framework 模块"></a>1.Spring Framework 模块</h1><p><img src="spring-1.assets/image-20200530234642332.png" alt="image-20200530234642332"></p><h2 id="1-1-spring核心容器"><a href="#1-1-spring核心容器" class="headerlink" title="1.1 spring核心容器"></a>1.1 spring核心容器</h2><p>该层基本上是 Spring Framework 的核心。它包含以下模块：</p><ul><li>Spring Core</li><li>Spring Bean</li><li>SpEl (Spring Expression language)</li><li>Spring Context</li></ul><h2 id="1-2数据访问-集成"><a href="#1-2数据访问-集成" class="headerlink" title="1.2数据访问/集成"></a>1.2数据访问/集成</h2><p>该层提供与数据库交互的支持。它包含以下模块：</p><ul><li><p>JDBC (Java DataBase Connectivity)</p></li><li><p>ORM (Object Re<em>ationa</em> Mapping)</p></li><li><p>OXM (Object XMl Mappers)</p></li><li><p>JMS (Java Messaging Service)</p></li><li><p>Transaction</p></li></ul><h2 id="1-3-web"><a href="#1-3-web" class="headerlink" title="1.3 web"></a>1.3 web</h2><p>该层提供了创建 Web 应用程序的支持。它包含以下模块：</p><ul><li><p>Web</p></li><li><p>Web – Servlet</p></li><li><p>Web – Socket</p></li><li><p>Web – Portlet</p></li></ul><h2 id="1-4AOP"><a href="#1-4AOP" class="headerlink" title="1.4AOP"></a>1.4AOP</h2><p>该层支持面向切面编程</p><h2 id="1-5Instrumentation"><a href="#1-5Instrumentation" class="headerlink" title="1.5Instrumentation"></a>1.5Instrumentation</h2><p>该层为类检测和类加载器实现提供支持。</p><h2 id="1-6Test"><a href="#1-6Test" class="headerlink" title="1.6Test"></a>1.6Test</h2><p>该层为使用 JUnit 和 TestNG 进行测试提供支持。</p><h2 id="1-7-Messaging"><a href="#1-7-Messaging" class="headerlink" title="1.7 Messaging"></a>1.7 Messaging</h2><p>该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</p><h2 id="1-8-Aspect"><a href="#1-8-Aspect" class="headerlink" title="1.8 Aspect"></a>1.8 Aspect</h2><p>该模块为与 AspectJ 的集成提供支持。</p><h1 id="2-IOC"><a href="#2-IOC" class="headerlink" title="2. IOC"></a>2. IOC</h1><p>Spring拥有两大特性：IoC和AOP。</p><p>Spring核心容器的主要组件是Bean工厂（BeanFactory），Bean工厂使用控制反转（IoC）模式来降低程序代码之间的耦合度，并提供了面向切面编程（AOP）的实现。</p><h2 id="2-1什么是IOC-DI"><a href="#2-1什么是IOC-DI" class="headerlink" title="2.1什么是IOC/DI"></a>2.1什么是IOC/DI</h2><ul><li><p>IOC(Inversion of Control)控制反转：所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们可配置的文件。</p></li><li><p>DI(Dependency Injection)依赖注入：就是指对象是被动接受依赖类而不是自己主动去找，换句话说就是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。Spring依赖注入的方式主要有四个，基于注解注入方式、set注入方式、构造器注入方式、静态工厂注入方式。推荐使用基于注解注入方式，配置较少，比较方便。</p></li></ul><ul><li>IoC容器：具有依赖注入功能的容器，可以创建对象的容器。IoC容器负责实例化、定位、配置应用程序中的对象并建立这些对象之间的依赖。IoC的主要实现方式有两种：依赖查找、依赖注入。依赖注入是一种更可取的方式,以来查找已经配抛弃</li></ul><p>那么依赖查找和依赖注入有什么区别呢？</p><ul><li><p>依赖查找，主要是容器为组件提供一个回调接口和上下文环境。这样一来，组件就必须自己使用容器提供的API来查找资源和协作对象，控制反转仅体现在那些回调方法上，容器调用这些回调方法，从而应用代码获取到资源。</p></li><li><p>依赖注入，组件不做定位查询，只提供标准的Java方法让容器去决定依赖关系。容器全权负责组件的装配，把符合依赖关系的对象通过Java Bean属性或构造方法传递给需要的对象。</p></li></ul><h2 id="2-2-spring-IOC"><a href="#2-2-spring-IOC" class="headerlink" title="2.2 spring IOC"></a>2.2 spring IOC</h2><p>控制反转，简单点说，就是创建对象的控制权，由原本自己代码new被反转到了Spring框架上</p><p>Spring 的 IoC 设计支持以下功能：·</p><ul><li><p>依赖注入·</p></li><li><p>依赖检查·</p></li><li><p>自动装配</p></li><li><p>支持集合</p></li><li><p>指定初始化方法和销毁方法</p></li><li><p>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）</p></li></ul><p>其中，最重要的就是依赖注入，从 XML 的配置上说， 即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p><p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</p><p>那么， Spring 如何设计容器的呢？</p><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器：BeanFactory、ApplicationContext</p><p>l BeanFactory 粗暴简单，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p><p>l ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口的一个实现类ConfigurableApplicationContext定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p><p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，我这里通过常用的 ClassPathXmlApplicationContext 类（我们常用的还有ClassPathweblApplicationContext ），来展示整个容器的层级 UML 关系。</p><p><img src="spring-1.assets/image-20200530235332029.png" alt="image-20200530235332029"></p><p>最上面的 BeanFactory 知道吧？我就不讲了。</p><p>下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p><p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p><p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p><p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置。生命周期事件回调等。</p><p>好，解释了低级容器和高级容器，我们可以看看一个 IoC 启动过程是什么样子的。说白了，就是 ClassPathXmlApplicationContext 这个类，在启动时，都做了啥。（由于我这是 interface21 的代码，肯定和你的 Spring 4.x 系列不同）。</p><p>下图是 ClassPathXmlApplicationContext 的构造过程，实际就是 Spring IoC 的初始化过程。</p><p><img src="spring-1.assets/image-20200530235345604.png" alt="image-20200530235345604"></p><p>这里再用文字来描述这个过程：</p><ol><li>用户构造 ClassPathXmlApplicationContext（简称 CPAC）</li><li>CPAC 首先访问了 “抽象高级容器” 的 final 的 refresh 方法，这个方法是模板方法。所以要回调子类（低级容器）的 refreshBeanFactory 方法，这个方法的作用是使用低级容器加载所有 BeanDefinition 和 Properties 到容器中。</li><li>低级容器加载成功后，高级容器开始处理一些回调，例如 Bean 后置处理器。回调 setBeanFactory 方法。或者注册监听器等，发布事件，实例化单例 Bean 等等功能，这些功能，随着 Spring 的不断升级，功能越来越多，很多人在这里迷失了方向 ：）。</li></ol><p>简单说就是：</p><ol><li>低级容器 加载配置文件（从 XML，数据库，Applet），并解析成 BeanDefinition 到低级容器中。</li><li>加载成功后，高级容器启动高级功能，例如接口回调，监听器，自动实例化单例，发布事件等等功能。</li></ol><p>所以，一定要把 “低级容器” 和“高级容器” 的区别弄清楚。不能一叶障目不见泰山。</p><p>好，当我们创建好容器，就会使用 getBean 方法，获取 Bean，而 getBean 的流程如下：</p><p><img src="spring-1.assets/image-20200530235428020.png" alt="image-20200530235428020"></p><p>从图中可以看出，getBean 的操作都是在低级容器里操作的。其中有个递归操作，这个是什么意思呢？</p><p>假设 ： 当 Bean_A 依赖着 Bean_B，而这个 Bean_A 在加载的时候，其配置的 ref = “Bean_B” 在解析的时候只是一个占位符，被放入了 Bean_A 的属性集合中，当调用 getBean 时，需要真正 Bean_B 注入到 Bean_A 内部时，就需要从容器中获取这个 Bean_B，因此产生了递归。</p><p>为什么不是在加载的时候，就直接注入呢？因为加载的顺序不同，很可能 Bean_A 依赖的 Bean_B 还没有加载好，也就无法从容器中获取，你不能要求用户把 Bean 的加载顺序排列好，这是不人道的。</p><p>所以，Spring 将getBean分为了 2 个步骤：</p><ol><li>加载所有的 Bean 配置成 BeanDefinition 到容器中，如果 Bean 有依赖关系，则使用占位符暂时代替。</li><li>然后，在调用 getBean 的时候，进行真正的依赖注入，即如果碰到了属性是 ref 的（占位符），那么就从容器里获取这个 Bean，然后注入到实例中 —— 称之为依赖注入。</li></ol><p>可以看到，依赖注入实际上，只需要 “低级容器” 就可以实现。</p><p>这就是 IoC。</p><p>所以 ApplicationContext refresh 方法里面的操作不只是 IoC，是高级容器的所有功能（包括 IoC），IoC 的功能在低级容器里就可以实现。</p><h2 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h2><p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p><p>1) 加载配置文件，解析成 BeanDefinition 放在 Map 里。</p><p>2) 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</p><p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p><p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p><h1 id="3-面向切面编程AOP"><a href="#3-面向切面编程AOP" class="headerlink" title="3. 面向切面编程AOP"></a>3. 面向切面编程AOP</h1><p>AOP的定义：面向切面编程，核心原理是使用动态代理模式在方法执行前后或出现异常时加入相关逻辑。</p><ol><li>AOP是基于动态代理模式。</li><li>AOP是方法级别的（要测试的方法不能为static修饰，因为接口中不能存在静态方法，编译就会报错）。</li><li>AOP可以分离业务代码和关注点代码（重复代码），在执行业务代码时，动态的注入关注点代码。切面就是关注点代码形成的类</li></ol><p>我们知道java是一个面向对象(OOP)的语言，但它有一些弊端,比如当我们需要为多个不具有继承关系的对象引入一个公共行为，只能在在每个对象里引用公共行为，这样做不便于维护，而且有大量重复代码。AOP的出现弥补了OOP的这点不足。</p><p>面向切面编程（AOP）就是纵向的编程。比如业务A和业务B现在需要一个相同的操作，传统方法我们可能需要在A、B中都加入相关操作代码，而应用AOP就可以只写一遍代码，A、B共用这段代码。并且，当A、B需要增加新的操作时，可以在不改动原代码的情况下，灵活添加新的业务逻辑实现。</p><p>在实际开发中，比如商品查询、促销查询等业务，都需要记录日志、异常处理等操作，AOP把所有共用代码都剥离出来，单独放置到某个类中进行集中管理，在具体运行时，由容器进行动态织入这些公共代码。</p><p>AOP主要一般应用于签名验签、参数校验、日志记录、事务控制、权限控制、性能统计、异常处理等。</p><h2 id="3-1-AOP名词"><a href="#3-1-AOP名词" class="headerlink" title="3.1 AOP名词"></a>3.1 AOP名词</h2><ul><li><p>切面（Aspect）：共有功能的实现。如日志切面、权限切面、验签切面等。在实际开发中通常是一个存放共有功能实现的标准Java类。当Java类使用了@Aspect注解修饰时，就能被AOP容器识别为切面。</p></li><li><p>通知（Advice）：切面的具体实现。就是要给目标对象织入的事情。以目标方法为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际开发中通常是切面类中的一个方法，具体属于哪类通知，通过方法上的注解区分。</p></li><li><p>连接点（JoinPoint）：程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出等。Spring只支持方法级的连接点。一个类的所有方法前、后、抛出异常时等都是连接点。</p></li></ul><ul><li>切入点（Pointcut）：用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。</li></ul><p>比如，在上面所说的连接点的基础上，来定义切入点。我们有一个类，类里有10个方法，那就产生了几十个连接点。但是我们并不想在所有方法上都织入通知，我们只想让其中的几个方法，在调用之前检验下入参是否合法，那么就用切点来定义这几个方法，让切点来筛选连接点，选中我们想要的方法。切入点就是来定义哪些类里面的哪些方法会得到通知。</p><ul><li><p>目标对象（Target）：那些即将切入切面的对象，也就是那些被通知的对象。这些对象专注业务本身的逻辑，所有的共有功能等待AOP容器的切入。</p></li><li><p>代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象本身业务逻辑加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。目标对象被织入共有功能后产生的对象。</p></li><li><p>织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译时、类加载时、运行时。Spring是在运行时完成织入，运行时织入通过Java语言的反射机制与动态代理机制来动态实现。</p></li></ul><h2 id="3-2-pointcut用法"><a href="#3-2-pointcut用法" class="headerlink" title="3.2 pointcut用法"></a>3.2 pointcut用法</h2><p><img src="spring-1.assets/image-20200530235925884.png" alt="image-20200530235925884"></p><ul><li><p>修饰符匹配 modifier-pattern? 例：public private</p></li><li><p>返回值匹配 ret-type-pattern 可以用 * 表示任意返回值</p></li><li><p>类路径匹配 declaring-type-pattern? 全路径的类名</p></li><li><p>方法名匹配 name-pattern 可以指定方法名或者用 * 表示所有方法；set* 表示所有以set开头的方法</p></li><li><p>参数匹配 (param-pattern) 可以指定具体的参数类型，多个参数用“,”分隔；可以用 * 表示匹配任意类型的参数；可以用 (..) 表示零个或多个任意参数</p></li><li><p>异常类型匹配throws-pattern? 例：throws Exception</p></li></ul><p>其中后面跟着 ? 表示可选项</p><p><img src="spring-1.assets/image-20200530235955265.png" alt="image-20200530235955265"></p><h2 id="3-3-一个例子"><a href="#3-3-一个例子" class="headerlink" title="3.3 一个例子"></a>3.3 一个例子</h2><p>以 <a href="https://blog.csdn.net/dkbnull/article/details/82847647" target="_blank" rel="noopener">Spring Boot入门：使用AOP实现拦截器</a> 中的AOP为例</p><p><img src="spring-1.assets/image-20200531000026341.png" alt="image-20200531000026341"></p><p>SignAop类使用了@Aspect注解，则该类可以被AOP容器识别为切面</p><img src="spring-1.assets/image-20200531000038057.png" alt="image-20200531000038057" style="zoom:150%;" /><p>@Pointcut声明一个切入点，范围为controller包下所有的类的所有方法。注：作为切入点签名的方法必须返回void类型</p><img src="spring-1.assets/image-20200531000104386.png" alt="image-20200531000104386" style="zoom:150%;" /><p>doBefore()方法使用@Before(“signAop()”)注解，表示前置通知（在某连接点之前执行的通知），但这个通知不能阻止连接点之前的执行流程，除非它抛出一个异常。</p><p>doAfterReturning()方法使用@AfterReturning(value = “signAop()”, returning = “params”)注解，表示后置通知（在某连接点正常完成后执行的通知），通常在一个匹配的方法返回的时候执行。</p><p>实际运行时，在进入controller包下所有方法前，都会进入doBefore()方法，在controller包下方法执行完成后，都会进入doAfterReturning()方法。</p><h2 id="3-4-动态代理-静待代理"><a href="#3-4-动态代理-静待代理" class="headerlink" title="3.4 动态代理/静待代理"></a>3.4 动态代理/静待代理</h2><p>AOP有两种实现方式：静态代理、动态代理</p><p>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</p><ul><li><p>编译时编织（特殊编译器实现）</p></li><li><p>类加载时编织（特殊的类加载器实现）。</p></li></ul><p>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</p><ul><li><p>JDK 动态代理</p></li><li><p>CGLIB</p></li></ul><h3 id="3-4-1-静态代理"><a href="#3-4-1-静态代理" class="headerlink" title="3.4.1 静态代理"></a>3.4.1 静态代理</h3><p>静态代理模式：静态代理说白了就是在程序运行前就已经存在代理类的字节码文件，代理类和原始类的关系在运行前就已经确定。</p><p><img src="spring-1.assets/image-20200531000307922.png" alt="image-20200531000307922"></p><p>测试结果</p><img src="spring-1.assets/image-20200531000332393.png" alt="image-20200531000332393" style="zoom:150%;" /><p>静态代理虽然保证了业务类只需关注逻辑本身，代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理。再者，如果增加一个方法，除了实现类需要实现这个方法外，所有的代理类也要实现此方法。增加了代码的维护成本。那么要如何解决呢?答案是使用动态代理。</p><h3 id="3-4-2-动态代理"><a href="#3-4-2-动态代理" class="headerlink" title="3.4.2 动态代理"></a>3.4.2 动态代理</h3><p>动态代理模式：动态代理类的源码是在程序运行期间通过JVM反射等机制动态生成，代理类和委托类的关系是运行时才确定的。实例如下:</p><h4 id="3-4-2-1-JDK动态代理"><a href="#3-4-2-1-JDK动态代理" class="headerlink" title="3.4.2.1 JDK动态代理"></a>3.4.2.1 JDK动态代理</h4><p><img src="spring-1.assets/image-20200531000437033.png" alt="image-20200531000437033"></p><p>测试结果如下：</p><p><img src="spring-1.assets/image-20200531000450599.png" alt="image-20200531000450599"></p><p>在运行测试类中创建测试类对象代码中</p><p><img src="spring-1.assets/wps1.jpg" alt="img"> </p><p>其实是jdk动态生成了一个类去实现接口,隐藏了这个过程:</p><p><img src="spring-1.assets/wps2.jpg" alt="img"> </p><p>使用jdk生成的动态代理的前提是目标类必须有实现的接口。</p><h4 id="3-4-2-2-CGLB动态代理"><a href="#3-4-2-2-CGLB动态代理" class="headerlink" title="3.4.2.2 CGLB动态代理"></a>3.4.2.2 CGLB动态代理</h4><p>使用jdk生成的动态代理的前提是目标类必须有实现的接口。但这里又引入一个问题,如果某个类没有实现接口,就不能使用jdk动态代理,所以Cglib代理就是解决这个问题的。</p><p>Cglib是以动态生成的子类继承目标的方式实现，在运行期动态的在内存中构建一个子类，如下:</p><p><img src="spring-1.assets/image-20200531000540009.png" alt="image-20200531000540009"></p><p>Cglib使用的前提是目标类不能为final修饰。因为final修饰的类不能被继承。</p><p>首先，导入 CGLIB 的 Maven 依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">  &lt;groupId&gt;cglib&lt;&#x2F;groupId&gt;  </span><br><span class="line">  &lt;artifactId&gt;cglib&lt;&#x2F;artifactId&gt;  </span><br><span class="line">  &lt;version&gt;3.2.11&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;  </span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>Spring AOP 的 org.springframework.cglib 包中包含了 CGLIB 的相关代码(和 CGLIB Maven 依赖中代码的一样，版本可能不同)，所以也可以选择导入 Spring AOP 的 Maven 依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;  </span><br><span class="line">  &lt;artifactId&gt;spring-aop&lt;&#x2F;artifactId&gt;  </span><br><span class="line">  &lt;version&gt;5.1.6.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;  </span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>然后，定义一个 Service 类，其有两个方法并且其中一个方法用 final 来修饰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.public class Service &#123;  </span><br><span class="line">2.    &#x2F;** </span><br><span class="line">3.     *  final 方法不能被子类覆盖 </span><br><span class="line">4.     *&#x2F;  </span><br><span class="line">5.    public final void finalMethod() &#123;  </span><br><span class="line">6.        System.out.println(&quot;Service.finalMethod 执行了&quot;);  </span><br><span class="line">7.    &#125;  </span><br><span class="line">8.  </span><br><span class="line">9.    public void publicMethod() &#123;  </span><br><span class="line">10.        System.out.println(&quot;Service.publicMethod 执行了&quot;);  </span><br><span class="line">11.    &#125;  </span><br><span class="line">12.&#125;</span><br></pre></td></tr></table></figure><p>接下来，定义一个 MethodInterceptor 的实现类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class CglibDynamicProxy implements MethodInterceptor &#123;  </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;目标对象（也被称为被代理对象）  </span><br><span class="line">    private Object target;  </span><br><span class="line">  </span><br><span class="line">    public CglibDynamicProxy(Object target) &#123;  </span><br><span class="line">        this.target &#x3D; target;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;** </span><br><span class="line">     * @param obj       CGLIB 生成的代理对象 </span><br><span class="line">     * @param method    被代理对象方法 </span><br><span class="line">     * @param args      方法入参 </span><br><span class="line">     * @param proxy     方法代理 </span><br><span class="line">     * @return </span><br><span class="line">     * @throws Throwable </span><br><span class="line">     *&#x2F;  </span><br><span class="line">    @Override  </span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;  </span><br><span class="line">        System.out.println(&quot;CglibDynamicProxy intercept 方法执行前--&quot;);  </span><br><span class="line">  </span><br><span class="line">        System.out.println(&quot;obj &#x3D; &quot; + obj.getClass());  </span><br><span class="line">        System.out.println(&quot;method &#x3D; &quot; + method);  </span><br><span class="line">        System.out.println(&quot;proxy &#x3D; &quot; + proxy);  </span><br><span class="line">  </span><br><span class="line">        Object object &#x3D; proxy.invoke(target, args);  </span><br><span class="line">        System.out.println(&quot;CglibDynamicProxy intercept 方法执行后--&quot;);  </span><br><span class="line">        return object;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    &#x2F;** </span><br><span class="line">     * 获取被代理接口实例对象 </span><br><span class="line">     * 通过 enhancer.create 可以获得一个代理对象，它继承了 target.getClass() 类 </span><br><span class="line">     * @param &lt;T&gt; </span><br><span class="line">     * @return </span><br><span class="line">     *&#x2F;  </span><br><span class="line">    public &lt;T&gt; T getProxy() &#123;  </span><br><span class="line">        Enhancer enhancer &#x3D; new Enhancer();  </span><br><span class="line">        enhancer.setSuperclass(target.getClass());  </span><br><span class="line">        enhancer.setCallback(this);  </span><br><span class="line">        return (T) enhancer.create();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        &#x2F;&#x2F; 1. 构造目标对象  </span><br><span class="line">        Service target &#x3D; new Service();  </span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 2. 根据目标对象生成代理对象  </span><br><span class="line">        CglibDynamicProxy proxy &#x3D; new CglibDynamicProxy(target);  </span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 获取 CGLIB 代理类  </span><br><span class="line">        Service proxyObject &#x3D; proxy.getProxy();  </span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 调用代理对象的方法  </span><br><span class="line">        proxyObject.finalMethod();  </span><br><span class="line">        proxyObject.publicMethod();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下所示：</p><p><img src="spring-1.assets/image-20200531000715166.png" alt="image-20200531000715166"></p><p>原理</p><p><a href="https://www.jianshu.com/p/7700a48811e0" target="_blank" rel="noopener">https://www.jianshu.com/p/7700a48811e0</a></p><h1 id="4-spring原理概述"><a href="#4-spring原理概述" class="headerlink" title="4. spring原理概述"></a>4. spring原理概述</h1><p><img src="spring-1.assets/image-20200531000823596.png" alt="image-20200531000823596"></p><ol><li>用户发送请求至前端控制器DispatcherServlet(也叫中央处理器).</li><li>DispatcherServlet调用HandlerMappering处理器映射器，处理器映射器找到具体的处理器（可以根据xml配置、注解进行查找），生成处理器对象及处理器拦截器（如果有则生成）一并返回给DispatcherServlet.</li><li>DispatcherServlet调用HandlerAdapter处理器适配器。</li><li>HandlerAdapter经过适配调用具体的处理器（Controller,也叫后端控制器）。</li><li>Controller执行完成返回ModelAndView.</li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet.</li><li>DisPatcherServlet将ModelAndView传给ViewReslover视图解析器。</li><li>ViewReslover解析后返回具体View.</li><li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet响应用户。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单认识一下spring
    
    </summary>
    
    
    
      <category term="spring" scheme="https://dcghx.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>经验积累————API接口防刷限流</title>
    <link href="https://dcghx.github.io/2020/05/09/ywjy-api%20%E9%98%B2%E5%88%B7%E9%99%90%E6%B5%81/"/>
    <id>https://dcghx.github.io/2020/05/09/ywjy-api%20%E9%98%B2%E5%88%B7%E9%99%90%E6%B5%81/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-31T03:46:40.658Z</updated>
    
    <content type="html"><![CDATA[<p>在开发分布式高并发系统时有三把利器用来保护系统：缓存、降级、限流<a id="more"></a></p><ul><li><p>缓存：缓存的目的是提升系统访问速度和增大系统处理容量</p></li><li><p>降级：降级是当服务出现问题或者影响到核心流程时，需要暂时屏蔽掉，待高峰或者问题解决后再打开</p></li><li><p>限流：限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理</p></li></ul><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ul><li><p>PV：page view 页面总访问量，每刷新一次记录一次。</p></li><li><p>UV：unique view 客户端主机访问，指一天内相同IP的访问记为1次。</p></li><li><p>QPS:</p></li></ul><p>query per second,即每秒访问量。qps很大程度上代表了系统的繁忙度，没次请求可能存在多次的磁盘io，网络请求，多个cpu时间片，一旦qps超过了预先设置的阀值，可以考量扩容增加服务器，避免访问量过大导致的宕机。</p><ul><li>RT：response time,每次请求的响应时间,直接决定用户体验性。</li></ul><p>本文主要介绍应用级限流方法，分布式限流、流量入口限流（接入层如NGINX limitconn和limitreq 模块）。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><ol><li>某天A君突然发现自己的接口请求量突然涨到之前的10倍，没多久该接口几乎不可使用，并引发连锁反应导致整个系统崩溃。如何应对这种情况呢？生活给了我们答案：比如老式电闸都安装了保险丝，一旦有人使用超大功率的设备，保险丝就会烧断以保护各个电器不被强电流给烧坏。同理我们的接口也需要安装上“保险丝”，以防止非预期的请求对系统压力过大而引起的系统瘫痪，当流量过大时，可以采取拒绝或者引流等机制。整编：微信公众号，搜云库技术团队，ID：souyunku</li><li>缓存的目的是提升系统访问速度和增大系统能处理的容量，可谓是抗高并发流量的银弹；而降级是当服务出问题或者影响到核心流程的性能则需要暂时屏蔽掉，待高峰或者问题解决后再打开；而有些场景并不能用缓存和降级来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（评论的最后几页），因此需有一种手段来限制这些场景的并发/请求量，即限流。</li><li>系统在设计之初就会有一个预估容量，长时间超过系统能承受的TPS/QPS阈值，系统可能会被压垮，最终导致整个服务不够用。为了避免这种情况，我们就需要对接口请求进行限流。</li><li>限流的目的是通过对并发访问请求进行限速或者一个时间窗口内的的请求数量进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待。</li><li>一般开发高并发系统常见的限流模式有控制并发和控制速率，一个是限制并发的总数量（比如数据库连接池、线程池），一个是限制并发访问的速率（如nginx的limitconn模块，用来限制瞬时并发连接数），另外还可以限制单位时间窗口内的请求数量（如Guava的RateLimiter、nginx的limitreq模块，限制每秒的平均速率）。其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。</li></ol><h1 id="3-应用级限流"><a href="#3-应用级限流" class="headerlink" title="3. 应用级限流"></a>3. 应用级限流</h1><h2 id="3-1-控制并发数据量"><a href="#3-1-控制并发数据量" class="headerlink" title="3.1 控制并发数据量"></a>3.1 控制并发数据量</h2><p>属于一种较常见的限流手段，在实际应用中可以通过信号量机制（如Java中的Semaphore）来实现。操作系统的信号量是个很重要的概念，Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p><p>举个例子，我们对外提供一个服务接口，允许最大并发数为10，代码实现如下：</p><p>![image-20200531113217111](ywjy-api 防刷限流.assets/image-20200531113217111.png)</p><p>在以上代码中，虽然有30个线程在执行，但是只允许10个并发的执行。Semaphore的构造方法Semaphore(int permits) 接受一个整型的数字，表示可用的许可证数量。Semaphore(10)表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()获取一个许可证，使用完之后调用release()归还许可证，还可以用tryAcquire()方法尝试获取许可证，信号量的本质是控制某个资源可被同时访问的个数，在一定程度上可以控制某资源的访问频率，但不能精确控制，控制访问频率的模式见下文描述。</p><h3 id="3-1-1-控制访问速率"><a href="#3-1-1-控制访问速率" class="headerlink" title="3.1.1 控制访问速率"></a>3.1.1 控制访问速率</h3><p>在工程实践中，常见的是使用令牌桶算法来实现这种模式，常用的限流算法有两种：漏桶算法和令牌桶算法。</p><h4 id="3-1-1-1-漏桶算法"><a href="#3-1-1-1-漏桶算法" class="headerlink" title="3.1.1.1 漏桶算法"></a>3.1.1.1 漏桶算法</h4><p>漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。</p><p>![image-20200531113310495](ywjy-api 防刷限流.assets/image-20200531113310495.png)</p><p>对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。</p><h4 id="3-1-1-2-令牌桶算法"><a href="#3-1-1-2-令牌桶算法" class="headerlink" title="3.1.1.2 令牌桶算法"></a>3.1.1.2 令牌桶算法</h4><p>如图所示，令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务，令牌桶算法通过发放令牌，根据令牌的rate频率做请求频率限制，容量限制等。</p><p>![image-20200531113345988](ywjy-api 防刷限流.assets/image-20200531113345988.png)</p><p><strong><em>\</em>1、**</strong>每过1/r秒桶中增加一个令牌。</p><p><strong><em>\</em>2、**</strong>桶中最多存放b个令牌，如果桶满了，新放入的令牌会被丢弃。</p><p><strong><em>\</em>3、**</strong>当一个n字节的数据包到达时，消耗n个令牌，然后发送该数据包。</p><p><strong><em>\</em>4、**</strong>如果桶中可用令牌小于n，则该数据包将被缓存或丢弃。</p><p>令牌桶控制的是一个时间窗口内通过的数据量，在API层面我们常说的QPS、TPS，正好是一个时间窗口内的请求量或者事务量，只不过时间窗口限定在1s罢了。以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。令牌桶的另外一个好处是可以方便的改变速度，一旦需要提高速率，则按需提高放入桶中的令牌的速率。</p><p>在我们的工程实践中，通常使用Google开源工具包Guava提供的限流工具类RateLimiter来实现控制速率，该类基于令牌桶算法来完成限流，非常易于使用，而且非常高效。如我们不希望每秒的任务提交超过1个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">    String start &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());      &#x2F;&#x2F; 这里的1表示每秒允许处理的量为1个  </span><br><span class="line">    RateLimiter limiter &#x3D; RateLimiter.create(1.0); </span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;   </span><br><span class="line">        limiter.acquire();&#x2F;&#x2F; 请求RateLimiter, 超过permits会被阻塞  </span><br><span class="line">        System.out.println(&quot;call execute..&quot; + i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    String end &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());  </span><br><span class="line">    System.out.println(&quot;start time:&quot; + start);  </span><br><span class="line">    System.out.println(&quot;end time:&quot; + end);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过RateLimiter.create(1.0);创建一个限流器，参数代表每秒生成的令牌数，通过limiter.acquire(i);来以阻塞的方式获取令牌，令牌桶算法允许一定程度的突发（允许消费未来的令牌），所以可以一次性消费i个令牌；当然也可以通过tryAcquire(int permits, long timeout, TimeUnit unit)来设置等待超时时间的方式获取令牌，如果超timeout为0，则代表非阻塞，获取不到立即返回，支持阻塞或可超时的令牌消费。</p><p>从输出来看，RateLimiter支持预消费，比如在acquire(5)时，等待时间是4秒，是上一个获取令牌时预消费了3个两排，固需要等待3*1秒，然后又预消费了5个令牌，以此类推。</p><p><strong><em>\</em>RateLimiter通过限制后面请求的等待时间，来支持一定程度的突发请求(预消费**</strong>)，在使用过程中需要注意这一点，Guava有两种限流模式，一种为稳定模式(SmoothBursty:令牌生成速度恒定，平滑突发限流)，一种为渐进模式(SmoothWarmingUp:令牌生成速度缓慢提升直到维持在一个稳定值，平滑预热限流) 两种模式实现思路类似，主要区别在等待时间的计算上。</p><p><strong><em>\</em>SmoothBursty 模式：**</strong></p><p>RateLimiter limiter = RateLimiter.create(5); RateLimiter.create(5)表示桶容量为5且每秒新增5个令牌，即每隔200毫秒新增一个令牌；limiter.acquire()表示消费一个令牌，如果当前桶中有足够令牌则成功（返回值为0），如果桶中没有令牌则暂停一段时间，比如发令牌间隔是200毫秒，则等待200毫秒后再去消费令牌，这种实现将突发请求速率平均为了固定请求速率。</p><p><strong><em>\</em>SmoothWarmingUp模式：**</strong></p><p>RateLimiter limiter = RateLimiter.create(5,1000, TimeUnit.MILLISECONDS);</p><p><strong><em>\</em>创建方式：**</strong></p><p><strong><em>\</em>RateLimiter.create(doublepermitsPerSecond, long warmupPeriod, TimeUnit unit)*****</strong>*，permitsPerSecond表示每秒新增的令牌数，****</p><p>warmupPeriod表示在从冷启动速率过渡到平均速率的时间间隔。速率是梯形上升速率的，也就是说冷启动时会以一个比较大的速率慢慢到平均速率；然后趋于平均速率（梯形下降到平均速率）。可以通过调节warmupPeriod参数实现一开始就是平滑固定速率。</p><p>注：RateLimiter控制的是速率，Samephore控制的是并发量。RateLimiter的原理就是令牌桶，它主要由许可发出的速率来定义，如果没有额外的配置，许可证将按每秒许可证规定的固定速度分配，许可将被平滑地分发，若请求超过permitsPerSecond则RateLimiter按照每秒 1/permitsPerSecond 的速率释放许可。注意:RateLimiter适用于单体应用，且RateLimiter不保证公平性访问。</p><h5 id="3-1-1-2-1-结合自定义注解方式使用"><a href="#3-1-1-2-1-结合自定义注解方式使用" class="headerlink" title="3.1.1.2.1 结合自定义注解方式使用"></a>3.1.1.2.1 结合自定义注解方式使用</h5><p>使用上述方式使用RateLimiter的方式不够优雅，自定义注解+AOP的方式实现(适用于单体应用)，详细见下面代码：</p><ul><li>自定义注解：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.*;  </span><br><span class="line">   </span><br><span class="line">&#x2F;** </span><br><span class="line"> * 自定义注解可以不包含属性，成为一个标识注解 </span><br><span class="line"> *&#x2F;  </span><br><span class="line">@Inherited  </span><br><span class="line">@Documented  </span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.TYPE&#125;)  </span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)  </span><br><span class="line">public @interface RateLimitAspect &#123;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义切面类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Component  </span><br><span class="line">@Scope  </span><br><span class="line">@Aspect  </span><br><span class="line">public class RateLimitAop &#123;  </span><br><span class="line">   </span><br><span class="line">    @Autowired  </span><br><span class="line">    private HttpServletResponse response;  </span><br><span class="line">   &#x2F;&#x2F;比如说，我这里设置&quot;并发数&quot;为5  </span><br><span class="line">    private RateLimiter rateLimiter &#x3D; RateLimiter.create(5.0); </span><br><span class="line">   </span><br><span class="line"> @Pointcut(&quot;@annotation(com.simons.cn.springbootdemo.aspect.RateLimitAspect)&quot;)  </span><br><span class="line">    public void serviceLimit() &#123;  </span><br><span class="line">   </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    @Around(&quot;serviceLimit()&quot;)  </span><br><span class="line">    public Object around(ProceedingJoinPoint joinPoint) &#123;  </span><br><span class="line">        Boolean flag &#x3D; rateLimiter.tryAcquire();  </span><br><span class="line">        Object obj &#x3D; null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            if (flag) &#123;  </span><br><span class="line">                obj &#x3D; joinPoint.proceed();  </span><br><span class="line">            &#125;else&#123;  </span><br><span class="line">String result &#x3D; JSONObject.fromObject(ResultUtil.success1(100, &quot;failure&quot;)).toString();  </span><br><span class="line">                output(response, result);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; catch (Throwable e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(&quot;flag&#x3D;&quot; + flag + &quot;,obj&#x3D;&quot; + obj);  </span><br><span class="line">        return obj;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">public void output(HttpServletResponse response, String msg) throws IOException &#123;  </span><br><span class="line">        response.setContentType(&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);  </span><br><span class="line">        ServletOutputStream outputStream &#x3D; null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            outputStream &#x3D; response.getOutputStream();  </span><br><span class="line">            outputStream.write(msg.getBytes(&quot;UTF-8&quot;));  </span><br><span class="line">        &#125; catch (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; finally &#123;  </span><br><span class="line">            outputStream.flush();  </span><br><span class="line">            outputStream.close();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试controller</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody  </span><br><span class="line">@RateLimitAspect  </span><br><span class="line">@RequestMapping(&quot;&#x2F;test&quot;)  </span><br><span class="line">public String test()&#123;  </span><br><span class="line">  return ResultUtil.success1(1001, &quot;success&quot;).toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样通过自定义注解@RateLimiterAspect来动态的加到需要限流的接口上，个人认为是比较优雅的实现吧。</p><h2 id="3-2-控制单位时间窗口内请求书"><a href="#3-2-控制单位时间窗口内请求书" class="headerlink" title="3.2 控制单位时间窗口内请求书"></a>3.2 控制单位时间窗口内请求书</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private LoadingCache&lt;Long, AtomicLong&gt; counter &#x3D; CacheBuilder.newBuilder().expireAfterWrite(2, TimeUnit.SECONDS)  </span><br><span class="line">                    .build(new CacheLoader&lt;Long, AtomicLong&gt;() &#123;  </span><br><span class="line">                        @Override  </span><br><span class="line">                        public AtomicLong load(Long seconds) throws Exception &#123;  </span><br><span class="line">                            return new AtomicLong(0);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;);  </span><br><span class="line">  </span><br><span class="line">public static long permit &#x3D; 50;  </span><br><span class="line">  </span><br><span class="line">public ResponseEntity getData() throws ExecutionException &#123;  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;得到当前秒  </span><br><span class="line">    long currentSeconds &#x3D; System.currentTimeMillis() &#x2F; 1000;  </span><br><span class="line">    if(counter.get(currentSeconds).incrementAndGet() &gt; permit) &#123;  </span><br><span class="line">        return ResponseEntity.builder().code(404).msg(&quot;访问速率过快&quot;).build();  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F;业务处理  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此应用级限流的一些方法就介绍完了。假设将应用部署到多台机器，应用级限流方式只是单应用内的请求限流，不能进行全局限流。因此我们需要分布式限流和接入层限流来解决这个问题。</p><h1 id="4-分布式限流"><a href="#4-分布式限流" class="headerlink" title="4. 分布式限流"></a>4. 分布式限流</h1><p>自定义注解+拦截器+Redis实现限流 (单体和分布式均适用，全局限流)</p><ul><li>自定义注解：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Inherited  </span><br><span class="line">@Documented  </span><br><span class="line">@Target(&#123;ElementType.FIELD,ElementType.TYPE,ElementType.METHOD&#125;)  </span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)  </span><br><span class="line">public @interface AccessLimit &#123;  </span><br><span class="line">    &#x2F;&#x2F;标识 指定sec时间段内的访问次数限制  </span><br><span class="line">    int limit() default 5;    </span><br><span class="line">    &#x2F;&#x2F;标识 时间段  </span><br><span class="line">    int sec() default 5;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>拦截器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class AccessLimitInterceptor implements HandlerInterceptor &#123;  </span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F;使用RedisTemplate操作redis  </span><br><span class="line">    @Autowired  </span><br><span class="line">    private RedisTemplate&lt;String, Integer&gt; redisTemplate;    </span><br><span class="line">   </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;  </span><br><span class="line">        if (handler instanceof HandlerMethod) &#123;  </span><br><span class="line">            HandlerMethod handlerMethod &#x3D; (HandlerMethod) handler;  </span><br><span class="line">            Method method &#x3D; handlerMethod.getMethod();  </span><br><span class="line">            if (!method.isAnnotationPresent(AccessLimit.class)) &#123;  </span><br><span class="line">                return true;  </span><br><span class="line">            &#125;  </span><br><span class="line">            AccessLimit accessLimit &#x3D; method.getAnnotation(AccessLimit.class);  </span><br><span class="line">            if (accessLimit &#x3D;&#x3D; null) &#123;  </span><br><span class="line">                return true;  </span><br><span class="line">            &#125;  </span><br><span class="line">            int limit &#x3D; accessLimit.limit();  </span><br><span class="line">            int sec &#x3D; accessLimit.sec();  </span><br><span class="line">            String key &#x3D; IPUtil.getIpAddr(request) + request.getRequestURI();  </span><br><span class="line">            Integer maxLimit &#x3D; redisTemplate.opsForValue().get(key);  </span><br><span class="line">            if (maxLimit &#x3D;&#x3D; null) &#123;  </span><br><span class="line">                &#x2F;&#x2F;set时一定要加过期时间  </span><br><span class="line">                redisTemplate.opsForValue().set(key, 1, sec, TimeUnit.SECONDS);    </span><br><span class="line">            &#125; else if (maxLimit &lt; limit) &#123;  </span><br><span class="line">                redisTemplate.opsForValue().set(key, maxLimit + 1, sec, TimeUnit.SECONDS);  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                output(response, &quot;请求太频繁!&quot;);  </span><br><span class="line">                return false;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">  public void output(HttpServletResponse response, String msg) throws IOException &#123;   response.setContentType(&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);  </span><br><span class="line">        ServletOutputStream outputStream &#x3D; null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            outputStream &#x3D; response.getOutputStream();  </span><br><span class="line">            outputStream.write(msg.getBytes(&quot;UTF-8&quot;));  </span><br><span class="line">        &#125; catch (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; finally &#123;  </span><br><span class="line">            outputStream.flush();  </span><br><span class="line">            outputStream.close();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    @Override  </span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;  </span><br><span class="line">   </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    @Override  </span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;  </span><br><span class="line">   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>controller</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.@Controller  </span><br><span class="line">2.@RequestMapping(&quot;&#x2F;activity&quot;)  </span><br><span class="line">3.public class AopController &#123;  </span><br><span class="line">4.    @ResponseBody  </span><br><span class="line">5.    @RequestMapping(&quot;&#x2F;seckill&quot;)  </span><br><span class="line">6.    @AccessLimit(limit &#x3D; 4,sec &#x3D; 10)  &#x2F;&#x2F;加上自定义注解即可  </span><br><span class="line">7.    public String test (HttpServletRequest request,String userName)&#123;  </span><br><span class="line">8.        &#x2F;&#x2F;TODO somethings……  </span><br><span class="line">9.        return   &quot;hello world !&quot;;  </span><br><span class="line">10.    &#125;  </span><br><span class="line">11.&#125;</span><br></pre></td></tr></table></figure><ul><li>配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*springmvc的配置文件中加入自定义拦截器*&#x2F;  </span><br><span class="line">&lt;mvc:interceptors&gt;  </span><br><span class="line">   &lt;mvc:interceptor&gt;  </span><br><span class="line">      &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;  </span><br><span class="line">&lt;bean class&#x3D;&quot;com.pptv.activityapi.controller.pointsmall.AccessLimitInterceptor&quot;&#x2F;&gt;  </span><br><span class="line">   &lt;&#x2F;mvc:interceptor&gt;  </span><br><span class="line">&lt;&#x2F;mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><h1 id="5-接入层限流"><a href="#5-接入层限流" class="headerlink" title="5. 接入层限流"></a>5. 接入层限流</h1><h2 id="5-1-negix-限流"><a href="#5-1-negix-限流" class="headerlink" title="5.1 negix 限流"></a>5.1 negix 限流</h2><p>限制原理:可一句话概括为：“根据客户端特征，限制其访问频率”，客户端特征主要指IP、UserAgent等。使用IP比UserAgent更可靠，因为IP无法造假，UserAgent可随意伪造。</p><p>Nginx为我们提供了两种限流方式：</p><ul><li><p>请求限制模块（ngx_http_limit_req_module）</p></li><li><p>基于令牌桶算法的流量限制模块（ngx_stream_limit_conn_module），可以方便的控制令牌速率，自定义调节限流，实现基本的限流控制</p></li></ul><h3 id="5-1-1-请求限制"><a href="#5-1-1-请求限制" class="headerlink" title="5.1.1 请求限制"></a>5.1.1 请求限制</h3><p>请求限制的功能来自于 ngx_http_limit_req_module 模块。使用它需要首先在 http 配置段中定义限制的参照标准和状态缓存区大小。</p><ul><li><p>limit_req_zone 只能配置在 http 范围内；</p></li><li><p>$binary_remote_addr 表示客户端请求的IP地址；</p></li><li><p>mylimit 自己定义的变量名；</p></li><li><p>rate 请求频率，每秒允许多少请求；</p></li><li><p>limit_req 与 limit_req_zone 对应</p></li><li><p>burst 表示缓存住的请求数，也就是任务队列。</p></li></ul><p>下面的配置就是定义了使用客户端的 IP 作为参照依据，并使用一个 10M 大小的状态缓存区。结尾的 rate=1r/s 表示针对每个 IP 的请求每秒只接受一次。</p><p>10M 的状态缓存空间够不够用呢？官方给出的答案是 1M 的缓存空间可以在 32 位的系统中服务 3.2 万 IP 地址，在 64 位的系统中可以服务 1.6 万 IP 地址，所以需要自己看情况调整。如果状态缓存耗光，后面所有的请求都会收到 503(Service Temporarily Unavailable) 错误。</p><p>脚本代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 定义了一个 mylimit 缓冲区（容器），请求频率为每秒 1 个请求（nr&#x2F;s）  </span><br><span class="line">limit_req_zone $binary_remote_addr zone&#x3D;mylimit:10m rate&#x3D;1r&#x2F;s;  </span><br><span class="line">server &#123;  </span><br><span class="line">    listen  70;  </span><br><span class="line">    location &#x2F; &#123;  </span><br><span class="line">        # nodelay 不延迟处理  </span><br><span class="line">        # burst 是配置超额处理,可简单理解为队列机制  </span><br><span class="line">        # 上面配置同一个 IP 没秒只能发送一次请求（1r&#x2F;s），这里配置了缓存3个请求，就意味着同一秒内只能允许 4 个任务响应成功，其它任务请求则失败（503错误）  </span><br><span class="line">        limit_req zone&#x3D;mylimit burst&#x3D;3 nodelay;  </span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:7070;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便此处提供 JAVA、AB 两种测试代码：</p><p>AB:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.# -n 即指定压力测试总共的执行次数  </span><br><span class="line">2.# -c 即指定的并发数  </span><br><span class="line">ab -n 5 -c 5 http:&#x2F;&#x2F;192.168.0.133:70&#x2F;index</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.public static void main(String[] args) throws ExecutionException, InterruptedException &#123;  </span><br><span class="line">2.        ExecutorService service &#x3D; Executors.newFixedThreadPool(5);  </span><br><span class="line">3.        for (int i &#x3D; 0; i &lt; 6; i++) &#123;  </span><br><span class="line">4.            CompletableFuture.supplyAsync(() -&gt; &#123;  </span><br><span class="line">5.                final ResponseEntity&lt;String&gt; entity &#x3D; new RestTemplate().getForEntity(&quot;http:&#x2F;&#x2F;192.168.0.133:70&#x2F;index&quot;, String.class);  </span><br><span class="line">6.                return entity.getBody();  </span><br><span class="line">7.            &#125;, service).thenAccept(System.out::println);  </span><br><span class="line">8.        &#125;  </span><br><span class="line">9.        service.shutdown();  </span><br><span class="line">10.    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-2-流量限制"><a href="#5-1-2-流量限制" class="headerlink" title="5.1.2 流量限制"></a>5.1.2 流量限制</h3><p>Nginx 并发限制的功能来自于 ngx_http_limit_conn_module 模块，跟请求配置一样，使用它之前，需要先定义参照标准和状态缓存区。</p><ul><li><p>imit_conn_zone 只能配置在 http 范围内；</p></li><li><p>$binary_remote_addr 表示客户端请求的IP地址；</p></li><li><p>myconn 自己定义的变量名（缓冲区）；</p></li><li><p>limit_rate 限制传输速度</p></li><li><p>limit_conn 与 limit_conn_zone 对应，限制网络连接数</p></li></ul><p>下面的配置就是定义了使用客户端的 IP 作为参照依据，并使用一个 10M 大小的状态缓存区。限定了每个IP只允许建立一个请求连接，同时传输的速度最大为 1024KB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.# 定义了一个 myconn 缓冲区（容器）  </span><br><span class="line">2.limit_conn_zone $binary_remote_addr zone&#x3D;myconn:10m;  </span><br><span class="line">3.server &#123;  </span><br><span class="line">4.    listen  70;  </span><br><span class="line">5.    location &#x2F; &#123;  </span><br><span class="line">6.        # 每个 IP 只允许一个连接  </span><br><span class="line">7.        limit_conn myconn 1;  </span><br><span class="line">8.        # 限制传输速度（如果有N个并发连接，则是 N * limit_rate）  </span><br><span class="line">9.        limit_rate 1024k;  </span><br><span class="line">10.        proxy_pass http:&#x2F;&#x2F;localhost:7070;  </span><br><span class="line">11.    &#125;  </span><br><span class="line">12.&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-网关限流（抽时间填坑）"><a href="#5-3-网关限流（抽时间填坑）" class="headerlink" title="5.3 网关限流（抽时间填坑）"></a>5.3 网关限流（抽时间填坑）</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发分布式高并发系统时有三把利器用来保护系统：缓存、降级、限流
    
    </summary>
    
    
    
      <category term="经验积累" scheme="https://dcghx.github.io/tags/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>经验积累————单点登录</title>
    <link href="https://dcghx.github.io/2020/05/09/ywjy-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>https://dcghx.github.io/2020/05/09/ywjy-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-31T04:43:27.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-单系统登陆机制"><a href="#1-单系统登陆机制" class="headerlink" title="1.单系统登陆机制"></a>1.单系统登陆机制</h1><h2 id="1-1-http无状态协议"><a href="#1-1-http无状态协议" class="headerlink" title="1.1 http无状态协议"></a>1.1 http无状态协议</h2><p>web应用采用browser/server架构，http作为通信协议。http是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程用下图说明，三次请求/响应对之间没有任何联系<a id="more"></a></p><p><img src="ywjy-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.assets/image-20200531122729711.png" alt="image-20200531122729711"></p><p>但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然http协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制</p><h2 id="1-2-会话机制"><a href="#1-2-会话机制" class="headerlink" title="1.2 会话机制"></a>1.2 会话机制</h2><p>浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器，浏览器存储会话id，并在后续第二次和第三次请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了，这个过程用下图说明，后续请求与第一次请求产生了关联</p><p><img src="ywjy-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.assets/image-20200531122757124.png" alt="image-20200531122757124"></p><p>服务器在内存中保存会话对象，浏览器怎么保存会话id呢？你可能会想到两种方式</p><ul><li><p>请求参数</p></li><li><p>cookie</p></li></ul><p>将会话id作为每一个请求的参数，服务器接收请求自然能解析参数获得会话id，并借此判断是否来自同一会话，很明显，这种方式不靠谱。那就浏览器自己来维护这个会话id吧，每次发送http请求时浏览器自动发送会话id，cookie机制正好用来做这件事。cookie是浏览器用来存储少量数据的一种机制，数据以”key/value“形式存储，浏览器发送http请求时自动附带cookie信息</p><p>　　tomcat会话机制当然也实现了cookie，访问tomcat服务器时，浏览器中可以看到一个名为“JSESSIONID”的cookie，这就是tomcat会话机制维护的会话id，使用了cookie的请求响应过程如下图</p><p><img src="ywjy-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.assets/image-20200531122831396.png" alt="image-20200531122831396"></p><h2 id="1-3-登陆状态"><a href="#1-3-登陆状态" class="headerlink" title="1.3 登陆状态"></a>1.3 登陆状态</h2><p>有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat在会话对象中设置登录状态如下<br>用户再次访问时，tomcat在会话对象中查看登录状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.HttpSession session &#x3D; request.getSession();  </span><br><span class="line">2.session.setAttribute(&quot;isLogin&quot;, true);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.HttpSession session &#x3D; request.getSession();  </span><br><span class="line">2.session.getAttribute(&quot;isLogin&quot;);</span><br></pre></td></tr></table></figure><p>每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。</p><h1 id="2-多系统的复杂性"><a href="#2-多系统的复杂性" class="headerlink" title="2. 多系统的复杂性"></a>2. 多系统的复杂性</h1><p>web系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样</p><p><img src="ywjy-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.assets/image-20200531123120279.png" alt="image-20200531123120279"></p><p>web系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了</p><p><img src="ywjy-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.assets/image-20200531123136520.png" alt="image-20200531123136520"></p><p>虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？</p><p>单系统登录解决方案的核心是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie的域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie</p><p><img src="ywjy-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.assets/image-20200531123156087.png" alt="image-20200531123156087"></p><p>既然这样，为什么不将web应用群中所有子系统的域名统一在一个顶级域名下，例如“*.baidu.com”，然后将它们的cookie域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享cookie的方式。</p><p>然而，可行并不代表好，共享cookie的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法实现跨语言技术平台登录的，比如java、php、.net系统之间；第三，cookie本身不安全。</p><p>因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录</p><h1 id="3-单点登录"><a href="#3-单点登录" class="headerlink" title="3 单点登录"></a>3 单点登录</h1><p>什么是单点登录？单点登录全称Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分</p><h2 id="3-1-登录"><a href="#3-1-登录" class="headerlink" title="3.1 登录"></a>3.1 登录</h2><p>相比于单系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明</p><p><img src="ywjy-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.assets/image-20200531123244348.png" alt="image-20200531123244348"></p><p>下面对上图简要描述</p><p>1) 用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</p><p>2) sso认证中心发现用户未登录，将用户引导至登录页面</p><p>3) 用户输入用户名密码提交登录申请</p><p>4) sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌</p><p>5) sso认证中心带着令牌跳转会最初的请求地址（系统1）</p><p>6) 系统1拿到令牌，去sso认证中心校验令牌是否有效</p><p>7) sso认证中心校验令牌，返回有效，注册系统1</p><p>8) 系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</p><p>9) 用户访问系统2的受保护资源</p><p>10) 系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</p><p>11) sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</p><p>12) 系统2拿到令牌，去sso认证中心校验令牌是否有效</p><p>13) sso认证中心校验令牌，返回有效，注册系统2</p><p>14) 系统2使用该令牌创建与用户的局部会话，返回受保护资源</p><p>用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系</p><ul><li><p>局部会话存在，全局会话一定存在</p></li><li><p>全局会话存在，局部会话不一定存在</p></li><li><p>全局会话销毁，局部会话必须销毁</p></li></ul><h2 id="3-2-注销"><a href="#3-2-注销" class="headerlink" title="3.2 注销"></a>3.2 注销</h2><p>单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明</p><p><img src="ywjy-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.assets/image-20200531123357439.png" alt="image-20200531123357439"></p><p>sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作</p><ol><li><p>用户向系统1发起注销请求</p></li><li><p>系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求</p></li><li><p>sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址</p></li><li><p>sso认证中心向所有注册系统发起注销请求</p></li><li><p>各注册系统接收sso认证中心的注销请求，销毁局部会话</p></li><li><p>sso认证中心引导用户至登录页面</p></li></ol><h1 id="4-部署图"><a href="#4-部署图" class="headerlink" title="4 部署图"></a>4 部署图</h1><p>单点登录涉及sso认证中心与众子系统，子系统与sso认证中心需要通信以交换令牌、校验令牌及发起注销请求，因而子系统必须集成sso的客户端，sso认证中心则是sso服务端，整个单点登录过程实质是sso客户端与服务端通信的过程，用下图描述</p><p><img src="ywjy-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.assets/image-20200531123438569.png" alt="image-20200531123438569"></p><p>sso认证中心与sso客户端通信方式有多种，这里以简单好用的httpClient为例，web service、rpc、restful api都可以</p><h1 id="5-逻辑实现（基于session的认证）"><a href="#5-逻辑实现（基于session的认证）" class="headerlink" title="5 逻辑实现（基于session的认证）"></a>5 逻辑实现（基于session的认证）</h1><p>只是一个思路，设计还是有问题</p><p>只是简要介绍下基于java的实现过程，不提供完整源码，明白了原理，我相信你们可以自己实现。sso采用客户端/服务端架构，我们先看sso-client与sso-server要实现的功能（下面：sso认证中心=sso-server）</p><ul><li>sso-client</li></ul><p>1) 拦截子系统未登录用户请求，跳转至sso认证中心</p><p>2) 接收并存储sso认证中心发送的令牌</p><p>3) 与sso-server通信，校验令牌的有效性</p><p>4) 建立局部会话</p><p>5) 拦截用户注销请求，向sso认证中心发送注销请求</p><p>6) 接收sso认证中心发出的注销请求，销毁局部会话</p><ul><li>sso-server</li></ul><p>1) 验证用户的登录信息</p><p>2) 创建全局会话</p><p>3) 创建授权令牌</p><p>4) 与sso-client通信发送令牌</p><p>5) 校验sso-client令牌有效性</p><p>6) 系统注册</p><p>7) 接收sso-client注销请求，注销所有会话</p><h2 id="5-1sso-client拦截未登录请求"><a href="#5-1sso-client拦截未登录请求" class="headerlink" title="5.1sso-client拦截未登录请求"></a>5.1sso-client拦截未登录请求</h2><p>　java拦截请求的方式有servlet、filter、listener三种方式，我们采用filter。在sso-client中新建LoginFilter.java类并实现Filter接口，在doFilter()方法中加入对未登录用户的拦截</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;  </span><br><span class="line">2.</span><br><span class="line">3.    HttpServletRequest req &#x3D; (HttpServletRequest) request;  </span><br><span class="line">4.    HttpServletResponse res &#x3D; (HttpServletResponse) response;  </span><br><span class="line">5.    HttpSession session &#x3D; req.getSession();  </span><br><span class="line">6.  </span><br><span class="line">7.    if (session.getAttribute(&quot;isLogin&quot;)) &#123;  </span><br><span class="line">8.        chain.doFilter(request, response);  </span><br><span class="line">9.        return;  </span><br><span class="line">10.    &#125;  </span><br><span class="line">11.  </span><br><span class="line">12.    &#x2F;&#x2F;跳转至sso认证中心  </span><br><span class="line">13.  </span><br><span class="line">14.    res.sendRedirect(&quot;sso-server-url-with-system-url&quot;);  </span><br><span class="line">15.  </span><br><span class="line">16.&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2sso-server拦截未登录请求"><a href="#5-2sso-server拦截未登录请求" class="headerlink" title="5.2sso-server拦截未登录请求"></a>5.2sso-server拦截未登录请求</h2><p>拦截从sso-client跳转至sso认证中心的未登录请求，跳转至登录页面，这个过程与sso-client完全一样</p><h2 id="5-3sso-server验证用户登录信息"><a href="#5-3sso-server验证用户登录信息" class="headerlink" title="5.3sso-server验证用户登录信息"></a>5.3sso-server验证用户登录信息</h2><p>用户在登录页面输入用户名密码，请求登录，sso认证中心校验用户信息，校验成功，将会话状态标记为“已登录”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.@RequestMapping(&quot;&#x2F;login&quot;)  </span><br><span class="line">2.  </span><br><span class="line">3.public String login(String username, String password, HttpServletRequest req) &#123;  </span><br><span class="line">4.  </span><br><span class="line">5.    this.checkLoginInfo(username, password);  </span><br><span class="line">6.  </span><br><span class="line">7.    req.getSession().setAttribute(&quot;isLogin&quot;, true);  </span><br><span class="line">8.  </span><br><span class="line">9.    return &quot;success&quot;;  </span><br><span class="line">10.  </span><br><span class="line">11.&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4sso-server创建授权令牌"><a href="#5-4sso-server创建授权令牌" class="headerlink" title="5.4sso-server创建授权令牌"></a>5.4sso-server创建授权令牌</h2><p>授权令牌是一串随机字符，以什么样的方式生成都没有关系，只要不重复、不易伪造即可，下面是一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String token &#x3D; UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure><h2 id="5-5-sso-client取得令牌并校验"><a href="#5-5-sso-client取得令牌并校验" class="headerlink" title="5.5 sso-client取得令牌并校验"></a>5.5 sso-client取得令牌并校验</h2><p>sso认证中心登录后，跳转回子系统并附上令牌，子系统（sso-client）取得令牌，然后去sso认证中心校验，在LoginFilter.java的doFilter()中添加几行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;&#x2F; 请求附带token参数  </span><br><span class="line">2.String token &#x3D; req.getParameter(&quot;token&quot;);    </span><br><span class="line">3.if (token !&#x3D; null) &#123;  </span><br><span class="line">4.    &#x2F;&#x2F; 去sso认证中心校验token  </span><br><span class="line">5.    boolean verifyResult &#x3D; this.verify(&quot;sso-server-verify-url&quot;, token);  </span><br><span class="line">6.    if (!verifyResult) &#123;  </span><br><span class="line">7.        res.sendRedirect(&quot;sso-server-url&quot;);  </span><br><span class="line">8.        return;  </span><br><span class="line">9.    &#125;  </span><br><span class="line">10.    chain.doFilter(request, response);  </span><br><span class="line">11.&#125;</span><br></pre></td></tr></table></figure><p>verify()方法使用httpClient实现，这里仅简略介绍，httpClient详细使用方法请参考官方文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.HttpPost httpPost &#x3D; new HttpPost(&quot;sso-server-verify-url-with-token&quot;);  </span><br><span class="line">2.HttpResponse httpResponse &#x3D; httpClient.execute(httpPost);</span><br></pre></td></tr></table></figure><h2 id="5-6sso-server接收并处理校验令牌请求"><a href="#5-6sso-server接收并处理校验令牌请求" class="headerlink" title="5.6sso-server接收并处理校验令牌请求"></a>5.6sso-server接收并处理校验令牌请求</h2><p>用户在sso认证中心登录成功后，sso-server创建授权令牌并存储该令牌，所以，sso-server对令牌的校验就是去查找这个令牌是否存在以及是否过期，令牌校验成功后sso-server将发送校验请求的系统注册到sso认证中心（就是存储起来的意思）</p><p>令牌与注册系统地址通常存储在key-value数据库（如redis）中，redis可以为key设置有效时间也就是令牌的有效期。redis运行在内存中，速度非常快，正好sso-server不需要持久化任何数据。</p><p>令牌与注册系统地址可以用下图描述的结构存储在redis中，可能你会问，为什么要存储这些系统的地址？如果不存储，注销的时候就麻烦了，用户向sso认证中心提交注销请求，sso认证中心注销全局会话，但不知道哪些系统用此全局会话建立了自己的局部会话，也不知道要向哪些子系统发送注销请求注销局部会话</p><p><img src="ywjy-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.assets/image-20200531123920961.png" alt="image-20200531123920961"></p><h2 id="5-7sso-client校验令牌成功创建局部会话"><a href="#5-7sso-client校验令牌成功创建局部会话" class="headerlink" title="5.7sso-client校验令牌成功创建局部会话"></a>5.7sso-client校验令牌成功创建局部会话</h2><p>令牌校验成功后，sso-client将当前局部会话标记为“已登录”，修改LoginFilter.java，添加几行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.if (verifyResult) &#123;  </span><br><span class="line">2.    session.setAttribute(&quot;isLogin&quot;, true);  </span><br><span class="line">3.&#125;</span><br></pre></td></tr></table></figure><p>sso-client还需将当前会话id与令牌绑定，表示这个会话的登录状态与令牌相关，此关系可以用java的hashmap保存，保存的数据用来处理sso认证中心发来的注销请求</p><h2 id="5-8注销过程"><a href="#5-8注销过程" class="headerlink" title="5.8注销过程"></a>5.8注销过程</h2><p>用户向子系统发送带有“logout”参数的请求（注销请求），sso-client拦截器拦截该请求，向sso认证中心发起注销请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.String logout &#x3D; req.getParameter(&quot;logout&quot;);  </span><br><span class="line">2.if (logout !&#x3D; null) &#123;  </span><br><span class="line">3.    this.ssoServer.logout(token);  </span><br><span class="line">4.&#125;</span><br></pre></td></tr></table></figure><p>sso认证中心也用同样的方式识别出sso-client的请求是注销请求（带有“logout”参数），sso认证中心注销全局会话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.@RequestMapping(&quot;&#x2F;logout&quot;)  </span><br><span class="line">2.public String logout(HttpServletRequest req) &#123;  </span><br><span class="line">3.    HttpSession session &#x3D; req.getSession();  </span><br><span class="line">4.    if (session !&#x3D; null) &#123;  </span><br><span class="line">5.        session.invalidate();&#x2F;&#x2F;触发LogoutListener  </span><br><span class="line">6.    &#125;  </span><br><span class="line">7.    return &quot;redirect:&#x2F;&quot;;  </span><br><span class="line">8.&#125;</span><br></pre></td></tr></table></figure><p>sso认证中心有一个全局会话的监听器，一旦全局会话注销，将通知所有注册系统注销</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.public class LogoutListener implements HttpSessionListener &#123;  </span><br><span class="line">2.  </span><br><span class="line">3.    @Override  </span><br><span class="line">4.    public void sessionCreated(HttpSessionEvent event) &#123;&#125;  </span><br><span class="line">5.    @Override  </span><br><span class="line">6.    public void sessionDestroyed(HttpSessionEvent event) &#123;  </span><br><span class="line">7.        &#x2F;&#x2F;通过httpClient向所有注册系统发送注销请求  </span><br><span class="line">8.    &#125;  </span><br><span class="line">9.&#125;</span><br></pre></td></tr></table></figure><h1 id="6-实现逻辑-基于网关-token的认证"><a href="#6-实现逻辑-基于网关-token的认证" class="headerlink" title="6.实现逻辑(基于网关+token的认证)"></a>6.实现逻辑(基于网关+token的认证)</h1><p>基于session存储认证信息本身对于程序来说也是消耗性能的，而且如果程序集群化部署又涉及到session共享的问题，我们放弃这种方式直接基于token令牌来做（session、cokie、token的区别参考前边的文章）</p><p>在之前的架构逻辑上，在所有的子项目前端添加网关，网关+认证程序（基于token）来实现单点登录更为安全方便</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-单系统登陆机制&quot;&gt;&lt;a href=&quot;#1-单系统登陆机制&quot; class=&quot;headerlink&quot; title=&quot;1.单系统登陆机制&quot;&gt;&lt;/a&gt;1.单系统登陆机制&lt;/h1&gt;&lt;h2 id=&quot;1-1-http无状态协议&quot;&gt;&lt;a href=&quot;#1-1-http无状态协议&quot; class=&quot;headerlink&quot; title=&quot;1.1 http无状态协议&quot;&gt;&lt;/a&gt;1.1 http无状态协议&lt;/h2&gt;&lt;p&gt;web应用采用browser/server架构，http作为通信协议。http是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程用下图说明，三次请求/响应对之间没有任何联系
    
    </summary>
    
    
    
      <category term="经验积累" scheme="https://dcghx.github.io/tags/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>MQ————理解、区别、选型、安全</title>
    <link href="https://dcghx.github.io/2020/05/09/mq-%E7%90%86%E8%A7%A3%E3%80%81%E5%8C%BA%E5%88%AB%E3%80%81%E9%80%89%E5%9E%8B%E3%80%81%E5%AE%89%E5%85%A8/"/>
    <id>https://dcghx.github.io/2020/05/09/mq-%E7%90%86%E8%A7%A3%E3%80%81%E5%8C%BA%E5%88%AB%E3%80%81%E9%80%89%E5%9E%8B%E3%80%81%E5%AE%89%E5%85%A8/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-31T04:07:11.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么要使用消息队列"><a href="#1-为什么要使用消息队列" class="headerlink" title="1. 为什么要使用消息队列"></a>1. 为什么要使用消息队列</h1><p>解耦、异步、削峰<a id="more"></a></p><h2 id="1-1-解耦"><a href="#1-1-解耦" class="headerlink" title="1.1 解耦"></a>1.1 解耦</h2><p>传统模式:</p><p><img src="mq-%E7%90%86%E8%A7%A3%E3%80%81%E5%8C%BA%E5%88%AB%E3%80%81%E9%80%89%E5%9E%8B%E3%80%81%E5%AE%89%E5%85%A8.assets/wps3.jpg" alt="img"></p><p>传统模式的缺点：系统间耦合性太强，如上图所示，系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦！</p><p>中间件模式:</p><p><img src="mq-%E7%90%86%E8%A7%A3%E3%80%81%E5%8C%BA%E5%88%AB%E3%80%81%E9%80%89%E5%9E%8B%E3%80%81%E5%AE%89%E5%85%A8.assets/wps4.jpg" alt="img"></p><p>中间件模式的的优点：将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改。</p><h2 id="1-2-异步"><a href="#1-2-异步" class="headerlink" title="1.2 异步"></a>1.2 异步</h2><p>传统模式:</p><p><img src="mq-%E7%90%86%E8%A7%A3%E3%80%81%E5%8C%BA%E5%88%AB%E3%80%81%E9%80%89%E5%9E%8B%E3%80%81%E5%AE%89%E5%85%A8.assets/wps5.jpg" alt="img"></p><p>中间件模式</p><p><img src="mq-%E7%90%86%E8%A7%A3%E3%80%81%E5%8C%BA%E5%88%AB%E3%80%81%E9%80%89%E5%9E%8B%E3%80%81%E5%AE%89%E5%85%A8.assets/wps6.jpg" alt="img"></p><ul><li><p>传统模式缺点：一些非必要的业务逻辑以同步的方式运行，太耗费时间。</p></li><li><p>中间件模式优点:将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度</p></li></ul><h2 id="1-3-削峰"><a href="#1-3-削峰" class="headerlink" title="1.3 削峰"></a>1.3 削峰</h2><p>传统模式</p><p><img src="mq-%E7%90%86%E8%A7%A3%E3%80%81%E5%8C%BA%E5%88%AB%E3%80%81%E9%80%89%E5%9E%8B%E3%80%81%E5%AE%89%E5%85%A8.assets/wps7.jpg" alt="img"></p><p>中间件模式</p><p><img src="mq-%E7%90%86%E8%A7%A3%E3%80%81%E5%8C%BA%E5%88%AB%E3%80%81%E9%80%89%E5%9E%8B%E3%80%81%E5%AE%89%E5%85%A8.assets/wps8.jpg" alt="img"></p><ul><li><p>传统模式的缺点：并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常</p></li><li><p>中间件模式的的优点：系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。</p></li></ul><h1 id="2-使用了消息队列会有什么缺点"><a href="#2-使用了消息队列会有什么缺点" class="headerlink" title="2. 使用了消息队列会有什么缺点"></a>2. 使用了消息队列会有什么缺点</h1><p>分析:一个使用了MQ的项目，如果连这个问题都没有考虑过，就把MQ引进去了，那就给自己的项目带来了风险。我们引入一个技术，要对这个技术的弊端有充分的认识，才能做好预防。要记住，不要给公司挖坑！<br>回答:回答也很容易，从以下两个个角度来答</p><ul><li><p>系统可用性降低:你想啊，本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性降低</p></li><li><p>系统复杂性增加:要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大。</p></li></ul><h1 id="3-消息队列选型"><a href="#3-消息队列选型" class="headerlink" title="3. 消息队列选型"></a>3. 消息队列选型</h1><table><thead><tr><th><strong><em>\</em>特性**</strong></th><th><strong><em>\</em>ActiveMQ**</strong></th><th><strong><em>\</em>RabbitMQ**</strong></th><th><strong><em>\</em>RocketMQ**</strong></th><th><strong><em>\</em>kafka**</strong></th></tr></thead><tbody><tr><td>开发语言</td><td>java</td><td>erlang</td><td>java</td><td>scala</td></tr><tr><td>单机吞吐量</td><td>万级</td><td>万级</td><td>10万级</td><td>10万级</td></tr><tr><td>时效性</td><td>ms级</td><td>us级</td><td>ms级</td><td>ms级以内</td></tr><tr><td>可用性</td><td>高(主从架构)</td><td>高(主从架构)</td><td>非常高(分布式架构)</td><td>非常高(分布式架构)</td></tr><tr><td>功能特性</td><td>成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好</td><td>基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富</td><td>MQ功能比较完备，扩展性佳</td><td>只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。</td></tr></tbody></table><p>综合上面的材料得出以下两点:<br>(1)中小型软件公司，建议选RabbitMQ.一方面，erlang语言天生具备高并发的特性，而且他的管理界面用起来十分方便。正所谓，成也萧何，败也萧何！他的弊端也在这里，虽然RabbitMQ是开源的，然而国内有几个能定制化开发erlang的程序员呢？所幸，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug，这点对于中小型公司来说十分重要。不考虑rocketmq和kafka的原因是，一方面中小型软件公司不如互联网公司，数据量没那么大，选消息中间件，应首选功能比较完备的，所以kafka排除。不考虑rocketmq的原因是，rocketmq是阿里出品，如果阿里放弃维护rocketmq，中小型公司一般抽不出人来进行rocketmq的定制化开发，因此不推荐。<br>(2)大型软件公司，根据具体使用在rocketMq和kafka之间二选一。一方面，大型软件公司，具备足够的资金搭建分布式环境，也具备足够大的数据量。针对rocketMQ,大型软件公司也可以抽出人手对rocketMQ进行定制化开发，毕竟国内有能力改JAVA源码的人，还是相当多的。至于kafka，根据业务场景选择，如果有日志采集功能，肯定是首选kafka了。具体该选哪个，看使用场景。</p><h1 id="4-如何保证消息队列高可用"><a href="#4-如何保证消息队列高可用" class="headerlink" title="4. 如何保证消息队列高可用"></a>4. 如何保证消息队列高可用</h1><p>分析:在第二点说过了，引入消息队列后，系统的可用性下降。在生产中，没人使用单机模式的消息队列。因此，作为一个合格的程序员，应该对消息队列的高可用有很深刻的了解。如果面试的时候，面试官问，你们的消息中间件如何保证高可用的？你的回答只是表明自己只会订阅和发布消息，面试官就会怀疑你是不是只是自己搭着玩，压根没在生产用过。请做一个爱思考，会思考，懂思考的程序员。<br>回答:这问题，其实要对消息队列的集群模式要有深刻了解，才好回答。<br>以rcoketMQ为例，他的集群就有多master 模式、多master多slave异步复制模式、多 master多slave同步双写模式。多master多slave模式部署架构图</p><p><img src="mq-%E7%90%86%E8%A7%A3%E3%80%81%E5%8C%BA%E5%88%AB%E3%80%81%E9%80%89%E5%9E%8B%E3%80%81%E5%AE%89%E5%85%A8.assets/wps9.jpg" alt="img"></p><p>第一眼看到这个图，就觉得和kafka好像，只是NameServer集群，在kafka中是用zookeeper代替，都是用来保存和发现master和slave用的。通信过程如下:<br>Producer 与 NameServer集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Broker Master 建立长连接，且定时向 Broker 发送心跳。Producer 只能将消息发送到 Broker master，但是 Consumer 则不一样，它同时和提供 Topic 服务的 Master 和 Slave建立长连接，既可以从 Broker Master 订阅消息，也可以从 Broker Slave 订阅消息。</p><p>那么kafka呢,为了对比说明直接上kafka的拓补架构图</p><p><img src="mq-%E7%90%86%E8%A7%A3%E3%80%81%E5%8C%BA%E5%88%AB%E3%80%81%E9%80%89%E5%9E%8B%E3%80%81%E5%AE%89%E5%85%A8.assets/wps10.jpg" alt="img"></p><p>如上图所示，一个典型的Kafka集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。<br>至于rabbitMQ,也有普通集群和镜像集群模式，自行去了解，比较简单，两小时即懂。<br>要求，在回答高可用的问题时，应该能逻辑清晰的画出自己的MQ集群架构或清晰的叙述出来。</p><h1 id="5-如何保证消息不会重复消费"><a href="#5-如何保证消息不会重复消费" class="headerlink" title="5. 如何保证消息不会重复消费"></a>5. 如何保证消息不会重复消费</h1><p>分析:这个问题其实换一种问法就是，如何保证消息队列的幂等性?这个问题可以认为是消息队列领域的基本问题。换句话来说，是在考察你的设计能力，这个问题的回答可以根据具体的业务场景来答，没有固定的答案。<br>回答:先来说一下为什么会造成重复消费?<br>  其实无论是那种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发送的确认信息形式不同,例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offset的概念，简单说一下(如果还不懂，出门找一个kafka入门到精通教程),就是每一个消息都有一个offset，kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了。那造成重复消费的原因?，就是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。</p><p>如何解决?这个问题针对业务场景来答分以下几点</p><ol><li>比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。</li><li>再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。</li><li>如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt;以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。</li></ol><h1 id="6-如何保证消息的可靠性传输"><a href="#6-如何保证消息的可靠性传输" class="headerlink" title="6. 如何保证消息的可靠性传输"></a>6. 如何保证消息的可靠性传输</h1><p>分析:我们在使用消息队列的过程中，应该做到消息不能多消费，也不能少消费。如果无法做到可靠性传输，可能给公司带来千万级别的财产损失。同样的，如果可靠性传输在使用过程中，没有考虑到，这不是给公司挖坑么，你可以拍拍屁股走了，公司损失的钱，谁承担。还是那句话，认真对待每一个项目，不要给公司挖坑。<br>回答:其实这个可靠性传输，每种MQ都要从三个角度来分析:生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据</p><ul><li>RabbitMQ</li></ul><p>(1)生产者丢数据<br>从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。<br>transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。<br>然而缺点就是吞吐量下降了。因此，按照博主的经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了.如果rabiitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。处理Ack和Nack的代码如下所示:</p><p><img src="mq-%E7%90%86%E8%A7%A3%E3%80%81%E5%8C%BA%E5%88%AB%E3%80%81%E9%80%89%E5%9E%8B%E3%80%81%E5%AE%89%E5%85%A8.assets/wps11.jpg" alt="img"></p><p>(2) 消息队列丢数据<br>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。<br>那么如何持久化呢，这里顺便说一下吧，其实也很容易，就下面两步<br>1、将queue的持久化标识durable设置为true,则代表是一个持久的队列<br>2、发送消息的时候将deliveryMode=2<br>这样设置以后，rabbitMQ就算挂了，重启后也能恢复数据</p><p>(3) 消费者丢数据<br>消费者丢数据一般是因为采用了自动确认消息模式。这种模式下，消费者会自动确认收到信息。这时rahbitMQ会立即将消息删除，这种情况下如果消费者出现异常而没能处理该消息，就会丢失该消息。<br>至于解决方案，采用手动确认消息即可。</p><ul><li>kafka</li></ul><p>这里先引一张kafka Replication的<a href="http://www.infoq.com/cn/articles/kafka-analysis-part-2/" target="_blank" rel="noopener">数据流向图</a></p><p><img src="mq-%E7%90%86%E8%A7%A3%E3%80%81%E5%8C%BA%E5%88%AB%E3%80%81%E9%80%89%E5%9E%8B%E3%80%81%E5%AE%89%E5%85%A8.assets/wps12.jpg" alt="img"></p><p>Producer在发布消息到某个Partition时，先通过ZooKeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少（也即该Partition有多少个Replica），Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader中pull数据。<br>针对上述情况，得出如下分析</p><p>(1)生产者丢数据<br>在kafka生产中，基本都有一个leader和多个follwer。follwer会去同步leader的信息。因此，为了避免生产者丢数据，做如下两点配置</p><ol><li>第一个配置要在producer端设置acks=all。这个配置保证了，follwer同步完成后，才认为消息发送成功。</li><li>在producer端设置retries=MAX，一旦写入失败，这无限重试</li></ol><p>(2)消息队列丢数据<br>针对消息队列丢数据的情况，无外乎就是，数据还没同步，leader就挂了，这时zookpeer会将其他的follwer切换为leader,那数据就丢失了。针对这种情况，应该做两个配置。</p><ol><li>replication.factor参数，这个值必须大于1，即要求每个partition必须有至少2个副本</li><li>min.insync.replicas参数，这个值必须大于1，这个是要求一个leader至少感知到有至少一个follower还跟自己保持联系</li></ol><p>这两个配置加上上面生产者的配置联合起来用，基本可确保kafka不丢数据</p><p>(2) 消费者丢数据<br>这种情况一般是自动提交了offset，然后你处理程序过程中挂了。kafka以为你处理好了。再强调一次offset是干嘛的<br>offset：指的是kafka的topic中的每个消费组消费的下标。简单的来说就是一条消息对应一个offset下标，每次消费数据的时候如果提交offset，那么下次消费就会从提交的offset加一那里开始消费。<br>比如一个topic中有100条数据，我消费了50条并且提交了，那么此时的kafka服务端记录提交的offset就是49(offset从0开始)，那么下次消费的时候offset就从50开始消费。<br>解决方案也很简单，改成手动提交即可。</p><p>ActiveMQ和RocketMQ–自行查阅</p><h1 id="7-如何保证消息的顺序性"><a href="#7-如何保证消息的顺序性" class="headerlink" title="7. 如何保证消息的顺序性"></a>7. 如何保证消息的顺序性</h1><p>分析:其实并非所有的公司都有这种业务需求，但是还是对这个问题要有所复习。<br>回答:针对这个问题，通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中(kafka中就是partition,rabbitMq中就是queue)。然后只用一个消费者去消费该队列。<br>有的人会问:那如果为了吞吐量，有多个消费者去消费怎么办？<br>这个问题，没有固定回答的套路。比如我们有一个微博的操作，发微博、写评论、删除微博，这三个异步操作。如果是这样一个业务场景，那只要重试就行。比如你一个消费者先执行了写评论的操作，但是这时候，微博都还没发，写评论一定是失败的，等一段时间。等另一个消费者，先执行写评论的操作后，再执行，就可以成功。<br>总之，针对这个问题，我的观点是保证入队有序就行，出队以后的顺序交给消费者自己去保证，没有固定套路。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-为什么要使用消息队列&quot;&gt;&lt;a href=&quot;#1-为什么要使用消息队列&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么要使用消息队列&quot;&gt;&lt;/a&gt;1. 为什么要使用消息队列&lt;/h1&gt;&lt;p&gt;解耦、异步、削峰
    
    </summary>
    
    
    
      <category term="MQ" scheme="https://dcghx.github.io/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>经验积累————分布式锁</title>
    <link href="https://dcghx.github.io/2020/05/09/ywjy-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>https://dcghx.github.io/2020/05/09/ywjy-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-31T05:09:45.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要通过一些互斥手段来防止彼此之间的干扰，以保证一致性，在这种情况下，就需要使用分布式锁了。<a id="more"></a></p><p>简而言之，分布式锁就是指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。</p><p>分布式锁要满足哪些要求呢？</p><p>1、互斥性–在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；<br>2、高可用的获取锁与释放锁；<br>3、高性能的获取锁与释放锁；<br>4、具备可重入特性–当一个客户端获取锁之后，这个客户端可以再次获取锁。<br>5、具备锁失效机制，防止死锁；<br>6、具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。<br>7、持锁人解锁–加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</p><p>一般有三种实现方案</p><ul><li><p>数据库(乐观锁/悲观锁)</p></li><li><p>Redis缓存——&gt;Redission</p></li><li><p>Zookeeper</p></li></ul><p>三种方案比较</p><ul><li><p>从性能角度：缓存&gt;Zookeeper&gt;MySQL</p></li><li><p>从实现角度：MySQL&gt;缓存&gt;Zookeeper</p></li><li><p>从可靠性角度：Zookeeper&gt;缓存&gt;MySQL</p></li></ul><h1 id="1-基于数据库的分布式锁"><a href="#1-基于数据库的分布式锁" class="headerlink" title="1.基于数据库的分布式锁"></a>1.基于数据库的分布式锁</h1><p>基于数据库来做分布式锁的话，通常有两种做法：</p><ul><li><p>基于数据库的悲观锁</p></li><li><p>基于数据库的乐观锁</p></li></ul><h2 id="1-1-悲观锁机制"><a href="#1-1-悲观锁机制" class="headerlink" title="1.1 悲观锁机制"></a>1.1 悲观锁机制</h2><p>在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁 （需要注意的是，在InnoDB中只有字段加了索引的，才会是行级锁，否者是表级锁，所以就要给要执行的方法字段名添加索引），当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。我们可以认为获得排他锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后释放锁。</p><h2 id="1-2-乐观锁机制"><a href="#1-2-乐观锁机制" class="headerlink" title="1.2 乐观锁机制"></a>1.2 乐观锁机制</h2><p>乐观锁机制其实就是在数据库表中引入一个版本号（version）字段来实现的。</p><p>当我们要从数据库中读取数据的时候，同时把这个version字段也读出来，如果要对读出来的数据进行更新后写回数据库，则需要将version加1，同时将新的数据与新的version更新到数据表中，且必须在更新的时候同时检查目前数据库里version值是不是之前的那个version，如果是，则正常更新。如果不是，则更新失败，说明在这个过程中有其它的进程去更新过数据了。</p><h2 id="1-3-使用数据库实现分布式锁的问题"><a href="#1-3-使用数据库实现分布式锁的问题" class="headerlink" title="1.3 使用数据库实现分布式锁的问题"></a>1.3 使用数据库实现分布式锁的问题</h2><p>1.因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换。</p><p>2.不具备可重入的特性。在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁。</p><p>3.没有锁失效机制。在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据。</p><p>4.不具备阻塞锁特性。获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。</p><p>5.非公平的。再建一张中间表，将等待锁的线程全记录下来，并根据创建时间排序，只有最先创建的允许获取锁。</p><h1 id="2-Redis"><a href="#2-Redis" class="headerlink" title="2. Redis"></a>2. Redis</h1><h2 id="2-1-redistemplate"><a href="#2-1-redistemplate" class="headerlink" title="2.1 redistemplate"></a>2.1 redistemplate</h2><p>分布式锁实现的关键是在分布式的应用服务器外，搭建一个存储服务器，存储锁信息，这时候我们很容易就想到了Redis。首先我们要搭建一个Redis服务器，用Redis服务器来存储锁信息。</p><p>在实现的时候要注意的几个关键点：</p><p>1、锁信息必须是会过期超时的，不能让一个线程长期占有一个锁而导致死锁；</p><p>2、同一时刻只能有一个线程获取到锁。</p><p>RedisTemplate中定义了5种数据结构操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue();　　&#x2F;&#x2F;操作字符串  </span><br><span class="line">redisTemplate.opsForHash();　　 &#x2F;&#x2F;操作hash  </span><br><span class="line">redisTemplate.opsForList();　　 &#x2F;&#x2F;操作list  </span><br><span class="line">redisTemplate.opsForSet();　　  &#x2F;&#x2F;操作set  </span><br><span class="line">redisTemplate.opsForZSet();　 　&#x2F;&#x2F;操作有序set</span><br></pre></td></tr></table></figure><p>StringRedisTemplate常用操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;向redis里存入数据和设置缓存时间  </span><br><span class="line">stringRedisTemplate.opsForValue().set(&quot;test&quot;, &quot;100&quot;,60*10,TimeUnit.SECONDS);    </span><br><span class="line">stringRedisTemplate.boundValueOps(&quot;test&quot;).increment(-1);&#x2F;&#x2F;val做-1操作  </span><br><span class="line">stringRedisTemplate.opsForValue().get(&quot;test&quot;)&#x2F;&#x2F;根据key获取缓存中的val  </span><br><span class="line">stringRedisTemplate.boundValueOps(&quot;test&quot;).increment(1);&#x2F;&#x2F;val +1   </span><br><span class="line">stringRedisTemplate.getExpire(&quot;test&quot;)&#x2F;&#x2F;根据key获取过期时间  </span><br><span class="line">&#x2F;&#x2F;根据key获取过期时间并换算成指定单位   </span><br><span class="line">stringRedisTemplate.getExpire(&quot;test&quot;,TimeUnit.SECONDS)   </span><br><span class="line">stringRedisTemplate.delete(&quot;test&quot;);&#x2F;&#x2F;根据key删除缓存  </span><br><span class="line">tringRedisTemplate.hasKey(&quot;546545&quot;);&#x2F;&#x2F;检查key是否存在，返回boolean值    </span><br><span class="line">&#x2F;&#x2F;向指定key中存放set集合  </span><br><span class="line">stringRedisTemplate.opsForSet().add(&quot;red_123&quot;, &quot;1&quot;,&quot;2&quot;,&quot;3&quot;);  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;设置过期时间  </span><br><span class="line">stringRedisTemplate.expire(&quot;red_123&quot;,1000 , TimeUnit.MILLISECONDS);  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;根据key查看集合中是否存在指定数据  </span><br><span class="line">stringRedisTemplate.opsForSet().isMember(&quot;red_123&quot;, &quot;1&quot;)  </span><br><span class="line">  </span><br><span class="line">stringRedisTemplate.opsForSet().members(&quot;red_123&quot;);&#x2F;&#x2F;根据key获取set集合</span><br></pre></td></tr></table></figure><p>利用redis实现一套简单的加锁解锁流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.log.info(Thread.currentThread()+&quot;开始尝试加锁！&quot;);  </span><br><span class="line">2.&#x2F;&#x2F;尝试加锁，加锁成功则返回true，否则则返回false，设置锁的有效时间  </span><br><span class="line">3.boolean b &#x3D; stringRedisTemplate.opsForValue().setIfAbsent(&quot;k1&quot;,null,60, TimeUnit.SECONDS);  </span><br><span class="line">4.&#x2F;&#x2F;返回true，该线程争取到锁  </span><br><span class="line">5.if(b)&#123;  </span><br><span class="line">6.    &#x2F;&#x2F;执行逻辑  </span><br><span class="line">7.    log.info(Thread.currentThread()+&quot;加锁成功，执行业务逻辑！&quot;);  </span><br><span class="line">8.    &#x2F;&#x2F;执行无异常，释放锁  </span><br><span class="line">9.    stringRedisTemplate.delete(&quot;k1&quot;);  </span><br><span class="line">10.&#125;  </span><br><span class="line">11.&#x2F;&#x2F;没有争取到锁：策略1——直接失败  策略2——循环一段时间长获取锁  </span><br><span class="line">12.else &#123;  </span><br><span class="line">13.      </span><br><span class="line">14.&#125;</span><br></pre></td></tr></table></figure><p>从上边代码我们可以看到整个流程是可以简单地实现分布式锁的要求的：锁有超时自毁机制、同时只能有一个客户端线程拿到锁。看着是没什么毛病，但是有一个很大的问题存在：如果执行业务逻辑需要时间超过了锁的的有效时间怎么办？种种原因不可能知道业务需要多久执行完毕，这就可能导致多个客户端线程拿到锁，产生异常。如何解决呢？就需要一种机制可以在锁的有效时间内检查锁是否仍然没有被释放，自动延长有效时间，Ression就可以做到。</p><h2 id="2-1-分布式redis的原理"><a href="#2-1-分布式redis的原理" class="headerlink" title="2.1 分布式redis的原理"></a>2.1 分布式redis的原理</h2><p>由上文可知，Redis是以哈希槽的形式对集群进行划分的，整个集群的哈希槽一共有16384个，在有3个Redis实例的情况下，节点A包含从0到5500的哈希槽，节点B包含从5501到11000 的哈希槽，节点C包含从11001到16384的哈希槽。当有新的节点添加进来的时候，会从当前的各个节点中选取一定的槽分配给新添加的节点，当有节点从集群中被删除时，则会将当前节点的槽分配给集群中其他正在运行的节点。每当有新的key添加到Redis中时，会根据算法算出相应的哈希槽来找到对应的集群节点。</p><h2 id="2-3-redission"><a href="#2-3-redission" class="headerlink" title="2.3 redission"></a>2.3 redission</h2><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><p>简单理解Redisson是一个工具集，封装了多个调用redis的api方法，功能强大。我们回到上节中提到的问题：业务没有执行完，锁超时释放了怎么办？Ression是如何解决的呢？</p><h3 id="2-3-1看门狗watch-dog自动延期机制"><a href="#2-3-1看门狗watch-dog自动延期机制" class="headerlink" title="2.3.1看门狗watch dog自动延期机制"></a>2.3.1看门狗watch dog自动延期机制</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="ywjy-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.assets/image-20200531125537691.png" alt="image-20200531125537691"></h3><p>我们来已一段代码demo来看看aip的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Config config &#x3D; new Config(); </span><br><span class="line">2.config.useSingleServer().setAddress(&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;);  </span><br><span class="line">3.RedissonClient redisson &#x3D; Redisson.create(config);  </span><br><span class="line">4.RLock lock &#x3D; redisson.getLock(&quot;anyLock&quot;);  </span><br><span class="line">5.  </span><br><span class="line">6.lock.lock(); </span><br><span class="line">7.&#x2F;&#x2F;lock.unlock();</span><br></pre></td></tr></table></figure><p>我们来看看getLoack方法的源码：</p><p><img src="ywjy-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.assets/image-20200531125607556.png" alt="image-20200531125607556"></p><p>从这里我们知道,internalLockLeaseTime 和 lockWatchdogTimeout这两个参数是相等的.<br>lockWatchdogTimeout默认值如下（Config类）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.public class Config &#123;  </span><br><span class="line">2.  </span><br><span class="line">3.private long lockWatchdogTimeout &#x3D; 30 * 1000;  </span><br><span class="line">4.  </span><br><span class="line">5.public long getLockWatchdogTimeout() &#123;  </span><br><span class="line">6.  </span><br><span class="line">7.return lockWatchdogTimeout;  </span><br><span class="line">8.  </span><br><span class="line">9.&#125;  </span><br><span class="line">10.  </span><br><span class="line">11.&#x2F;&#x2F;省略无关代码  </span><br><span class="line">12.  </span><br><span class="line">13.&#125;</span><br></pre></td></tr></table></figure><p>从internalLockLeaseTime这个单词也可以看出,这个加的分布式锁的超时时间默认是30秒.但是还有一个问题,那就是这个看门狗,多久来延长一次有效期呢?我们往下看Lock方法</p><p><img src="ywjy-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.assets/image-20200531125648876.png" alt="image-20200531125648876"></p><p>从我图中框起来的地方我们就知道了,获取锁成功就会开启一个定时任务,也就是watchdog,定时任务会定期检查去续期renewExpirationAsync(threadId).这里定时用的是netty-common包中的HashedWheelTimer,从图中我们明白,该定时调度每次调用的时间差是internalLockLeaseTime / 3.也就10秒.</p><p>通过源码分析我们知道,默认情况下,加锁的时间是30秒.如果加锁的业务没有执行完,那么到 30-10 = 20秒的时候,就会进行一次续期,把锁重置成30秒.那这个时候可能又有同学问了,那业务的机器万一宕机了呢?宕机了定时任务跑不了,就续不了期,那自然30秒之后锁就解开了呗.</p><p>原理图：</p><p><img src="ywjy-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.assets/image-20200531130005949.png" alt="image-20200531130005949"></p><h3 id="2-3-2-锁的原理"><a href="#2-3-2-锁的原理" class="headerlink" title="2.3.2 锁的原理"></a>2.3.2 锁的原理</h3><p>在Redisson中，使用key来作为是否上锁的标志，当通过getLock(String key)方法获得相应的锁之后，这个key即作为一个锁存储到Redis集群中，在接下来如果有其他的线程尝试获取名为key的锁时，便会向集群中进行查询，如果能够查到这个锁并发现相应的value的值不为0，则表示已经有其他线程申请了这个锁同时还没有释放，则当前线程进入阻塞，否则由当前线程获取这个锁并将value值加一，如果是可重入锁的话，则当前线程每获得一个自身线程的锁，就将value的值加一，而每释放一个锁则将value值减一，直到减至0，完全释放这个锁。因为底层是基于分布式的Redis集群，所以Redisson实现了分布式的锁机制。</p><h4 id="2-3-2-1-加锁"><a href="#2-3-2-1-加锁" class="headerlink" title="2.3.2.1 加锁"></a>2.3.2.1 加锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Future tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId) &#123;  </span><br><span class="line">    internalLockLeaseTime &#x3D; unit.toMillis(leaseTime);  </span><br><span class="line">    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_LONG,  </span><br><span class="line">        &#x2F;&#x2F; 检查是否key已经被占用，如果没有则设置超时时间和唯一标识，初始化value&#x3D;1  </span><br><span class="line">        &quot;if (redis.call(&#39;exists&#39;, KEYS[1]) &#x3D;&#x3D; 0) then &quot; +  </span><br><span class="line">            &quot;redis.call(&#39;hset&#39;, KEYS[1], ARGV[2], 1); &quot; +  </span><br><span class="line">            &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot; +  </span><br><span class="line">            &quot;return nil; &quot; +  </span><br><span class="line">        &quot;end; &quot; +  </span><br><span class="line">        &#x2F;&#x2F; 如果锁重入,需要判断锁的key field 都一直情况下 value 加一  </span><br><span class="line">        &quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) &#x3D;&#x3D; 1) then &quot; +  </span><br><span class="line">            &quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot; +  </span><br><span class="line">            &#x2F;&#x2F;锁重入重新设置超时时间  </span><br><span class="line">            &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot; +  </span><br><span class="line">            &quot;return nil; &quot; +  </span><br><span class="line">        &quot;end; &quot; +  </span><br><span class="line">        &#x2F;&#x2F; 返回剩余的过期时间  </span><br><span class="line">        &quot;return redis.call(&#39;pttl&#39;, KEYS[1]);&quot;,  </span><br><span class="line">        Collections.singletonList(getName()), internalLockLeaseTime, getLockName(threadId));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Redisson中，加锁需要以下三个参数：</p><ul><li><p>KEYS[1] ：需要加锁的key，这里需要是字符串类型。</p></li><li><p>ARGV[1] ：锁的超时时间，防止死锁</p></li><li><p>ARGV[2] ：锁的唯一标识，id（UUID.randomUUID()） + “:” + threadId</p></li></ul><h4 id="2-3-2-2-解锁"><a href="#2-3-2-2-解锁" class="headerlink" title="2.3.2.2 解锁"></a>2.3.2.2 解锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;  </span><br><span class="line">        Boolean opStatus &#x3D; commandExecutor.evalWrite(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,  </span><br><span class="line">        &#x2F;&#x2F; 如果key已经不存在，说明已经被解锁，直接发布（publihs）redis消息  </span><br><span class="line">        &quot;if (redis.call(&#39;exists&#39;, KEYS[1]) &#x3D;&#x3D; 0) then &quot; +  </span><br><span class="line">        &quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &quot; +  </span><br><span class="line">        &quot;return 1; &quot; +  </span><br><span class="line">        &quot;end;&quot; +  </span><br><span class="line">        &#x2F;&#x2F; key和field不匹配，说明当前客户端线程没有持有锁，不能主动解锁。  </span><br><span class="line">        &quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[3]) &#x3D;&#x3D; 0) then &quot; +  </span><br><span class="line">        &quot;return nil;&quot; +  </span><br><span class="line">        &quot;end; &quot; +  </span><br><span class="line">        &quot;local counter &#x3D; redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[3], -1); &quot; +  </span><br><span class="line">        &#x2F;&#x2F; 如果counter&gt;0说明锁在重入，不能删除key  </span><br><span class="line">        &quot;if (counter &gt; 0) then &quot; +  </span><br><span class="line">        &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[2]); &quot; +  </span><br><span class="line">        &quot;return 0; &quot; +  </span><br><span class="line">        &quot;else &quot; +  </span><br><span class="line">        &#x2F;&#x2F; 删除key并且publish 解锁消息  </span><br><span class="line">        &quot;redis.call(&#39;del&#39;, KEYS[1]); &quot; +  </span><br><span class="line">        &quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &quot; +  </span><br><span class="line">        &quot;return 1; &quot;+  </span><br><span class="line">        &quot;end; &quot; +  </span><br><span class="line">        &quot;return nil;&quot;,  </span><br><span class="line">        Arrays.asList(getName(), getChannelName()), LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(Thread.currentThread().getId()));  </span><br><span class="line">        if (opStatus &#x3D;&#x3D; null) &#123;  </span><br><span class="line">                throw new IllegalMonitorStateException(&quot;attempt to unlock lock, not locked by current thread by node id: &quot;  </span><br><span class="line">                        + id + &quot; thread-id: &quot; + Thread.currentThread().getId());  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#x2F;&#x2F; 解锁成功之后取消更新锁expire的时间任务  </span><br><span class="line">        if (opStatus) &#123;  </span><br><span class="line">                cancelExpirationRenewal();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在Redisson中解锁需要以下五个参数：</p><ul><li><p>KEYS[1] ：需要加锁的key，这里需要是字符串类型。</p></li><li><p>KEYS[2] ：redis消息的ChannelName,一个分布式锁对应唯一的一个channelName:“redisson_lock__channel__{” + getName() + “}”</p></li><li><p>ARGV[1] ：reids消息体，这里只需要一个字节的标记就可以，主要标记redis的key已经解锁，再结合redis的Subscribe，能唤醒其他订阅解锁消息的客户端线程申请锁。</p></li><li><p>ARGV[2] ：锁的超时时间，防止死锁</p></li><li><p>ARGV[3] ：锁的唯一标识，也就是刚才介绍的 id（UUID.randomUUID()） + “:” + threadId</p></li></ul><h3 id="2-3-3-锁的种类"><a href="#2-3-3-锁的种类" class="headerlink" title="2.3.3 锁的种类"></a>2.3.3 锁的种类</h3><h4 id="2-3-3-1-可重入锁"><a href="#2-3-3-1-可重入锁" class="headerlink" title="2.3.3.1 可重入锁"></a>2.3.3.1 可重入锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.RLock lock &#x3D; redisson.getLock(&quot;anyLock&quot;);  </span><br><span class="line">2.&#x2F;&#x2F; 最常见的使用方法  </span><br><span class="line">3.lock.lock();  </span><br><span class="line">4....  </span><br><span class="line">5.lock.unlock()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;&#x2F; 加锁以后10秒钟自动解锁 </span><br><span class="line">2.lock.lock(10, TimeUnit.SECONDS);    </span><br><span class="line">3.&#x2F;&#x2F; 尝试加锁，最多等待100秒，上锁以后10秒自动解锁  </span><br><span class="line">4.boolean res &#x3D; lock.tryLock(100, 10, TimeUnit.SECONDS);  </span><br><span class="line">5....  </span><br><span class="line">6.lock.unlock();</span><br></pre></td></tr></table></figure><h4 id="2-3-3-2-公平锁"><a href="#2-3-3-2-公平锁" class="headerlink" title="2.3.3.2 公平锁"></a>2.3.3.2 公平锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.RLock fairLock &#x3D; redisson.getFairLock(&quot;anyLock&quot;);  </span><br><span class="line">2.&#x2F;&#x2F; 最常见的使用方法  </span><br><span class="line">3.fairLock.lock();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;&#x2F; 10秒钟以后自动解锁  </span><br><span class="line">2.fairLock.lock(10, TimeUnit.SECONDS);    </span><br><span class="line">3.&#x2F;&#x2F; 尝试加锁，最多等待100秒，上锁以后10秒自动解锁  </span><br><span class="line">4.boolean res &#x3D; fairLock.tryLock(100, 10, TimeUnit.SECONDS);  </span><br><span class="line">5....  </span><br><span class="line">6.fairLock.unlock();</span><br></pre></td></tr></table></figure><p>Redisson同时还为分布式可重入公平锁提供了异步执行的相关方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.RLock fairLock &#x3D; redisson.getFairLock(&quot;anyLock&quot;);  </span><br><span class="line">2.fairLock.lockAsync();  </span><br><span class="line">3.fairLock.lockAsync(10, TimeUnit.SECONDS);  </span><br><span class="line">Future&lt;Boolean&gt; res &#x3D; fairLock.tryLockAsync(100, 10, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h4 id="2-3-3-3-联锁"><a href="#2-3-3-3-联锁" class="headerlink" title="2.3.3.3 联锁"></a>2.3.3.3 联锁</h4><p>基于Redis的Redisson分布式联锁RedissonMultiLock对象可以将多个RLock对象关联为一个联锁，每个RLock对象实例可以来自于不同的Redisson实例。所有的锁都上锁成功才算成功。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.RLock lock1 &#x3D; redissonInstance1.getLock(&quot;lock1&quot;);  </span><br><span class="line">2.RLock lock2 &#x3D; redissonInstance2.getLock(&quot;lock2&quot;);  </span><br><span class="line">3.RLock lock3 &#x3D; redissonInstance3.getLock(&quot;lock3&quot;);  </span><br><span class="line">4.  </span><br><span class="line">5.RedissonMultiLock lock &#x3D; new RedissonMultiLock(lock1, lock2, lock3);  </span><br><span class="line">6.&#x2F;&#x2F; 同时加锁：lock1 lock2 lock3，所有的锁都上锁成功才算成功。  </span><br><span class="line">7.lock.lock();  </span><br><span class="line">8....  </span><br><span class="line">9.lock.unlock();</span><br></pre></td></tr></table></figure><h4 id="2-3-3-4-红锁"><a href="#2-3-3-4-红锁" class="headerlink" title="2.3.3.4 红锁"></a>2.3.3.4 红锁</h4><p>基于Redis的Redisson红锁RedissonRedLock对象实现了Redlock介绍的加锁算法。该对象也可以用来将多个RLock对象关联为一个红锁，每个RLock对象实例可以来自于不同的Redisson实例。红锁在大部分节点上加锁成功就算成功。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.RLock lock1 &#x3D; redissonInstance1.getLock(&quot;lock1&quot;);  </span><br><span class="line">2.RLock lock2 &#x3D; redissonInstance2.getLock(&quot;lock2&quot;);  </span><br><span class="line">3.RLock lock3 &#x3D; redissonInstance3.getLock(&quot;lock3&quot;);  </span><br><span class="line">4.  </span><br><span class="line">5.RedissonRedLock lock &#x3D; new RedissonRedLock(lock1, lock2, lock3);  </span><br><span class="line">6.&#x2F;&#x2F; 同时加锁：lock1 lock2 lock3，红锁在大部分节点上加锁成功就算成功。  </span><br><span class="line">7.lock.lock();  </span><br><span class="line">8....  </span><br><span class="line">9.lock.unlock();</span><br></pre></td></tr></table></figure><p>另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.RedissonRedLock lock &#x3D; new RedissonRedLock(lock1, lock2, lock3);  </span><br><span class="line">2.&#x2F;&#x2F; 给lock1，lock2，lock3加锁，如果没有手动解开的话，10秒钟后将会自动解开  </span><br><span class="line">3.lock.lock(10, TimeUnit.SECONDS);    </span><br><span class="line">4.&#x2F;&#x2F; 为加锁等待100秒时间，并在加锁成功10秒钟后自动解开  </span><br><span class="line">5.boolean res &#x3D; lock.tryLock(100, 10, TimeUnit.SECONDS);  </span><br><span class="line">6....  </span><br><span class="line">7.lock.unlock();</span><br></pre></td></tr></table></figure><h4 id="2-3-3-5-读写锁"><a href="#2-3-3-5-读写锁" class="headerlink" title="2.3.3.5 读写锁"></a>2.3.3.5 读写锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.RReadWriteLock rwlock &#x3D; redisson.getLock(&quot;anyRWLock&quot;);  </span><br><span class="line">2.&#x2F;&#x2F; 最常见的使用方法  </span><br><span class="line">3.rwlock.readLock().lock();  </span><br><span class="line">4.&#x2F;&#x2F; 或  </span><br><span class="line">5.rwlock.writeLock().lock();</span><br></pre></td></tr></table></figure><h4 id="2-3-3-6-信号量"><a href="#2-3-3-6-信号量" class="headerlink" title="2.3.3.6 信号量"></a>2.3.3.6 信号量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.RSemaphore semaphore &#x3D; redisson.getSemaphore(&quot;semaphore&quot;);  </span><br><span class="line">2.semaphore.acquire();  </span><br><span class="line">3.&#x2F;&#x2F;或  </span><br><span class="line">4.semaphore.acquireAsync();  </span><br><span class="line">5.semaphore.acquire(23);  </span><br><span class="line">6.semaphore.tryAcquire();  </span><br><span class="line">7.&#x2F;&#x2F;或  </span><br><span class="line">8.semaphore.tryAcquireAsync();  </span><br><span class="line">9.semaphore.tryAcquire(23, TimeUnit.SECONDS);  </span><br><span class="line">10.&#x2F;&#x2F;或  </span><br><span class="line">11.semaphore.tryAcquireAsync(23, TimeUnit.SECONDS);  </span><br><span class="line">12.semaphore.release(10);  </span><br><span class="line">13.semaphore.release();  </span><br><span class="line">14.&#x2F;&#x2F;或  </span><br><span class="line">15.semaphore.releaseAsync();</span><br></pre></td></tr></table></figure><h4 id="2-3-3-7-可过期信号量"><a href="#2-3-3-7-可过期信号量" class="headerlink" title="2.3.3.7 可过期信号量"></a>2.3.3.7 可过期信号量</h4><p>基于Redis的Redisson可过期性信号量（PermitExpirableSemaphore）是在RSemaphore对象的基础上，为每个信号增加了一个过期时间。每个信号可以通过独立的ID来辨识，释放时只能通过提交这个ID才能释放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RPermitExpirableSemaphore semaphore &#x3D; redisson.getPermitExpirableSemaphore(&quot;mySemaphore&quot;);  </span><br><span class="line">String permitId &#x3D; semaphore.acquire();  </span><br><span class="line">&#x2F;&#x2F; 获取一个信号，有效期只有2秒钟。  </span><br><span class="line">String permitId &#x3D; semaphore.acquire(2, TimeUnit.SECONDS);  </span><br><span class="line">&#x2F;&#x2F; ...  </span><br><span class="line">semaphore.release(permitId);</span><br></pre></td></tr></table></figure><h4 id="2-3-3-8-闭锁"><a href="#2-3-3-8-闭锁" class="headerlink" title="2.3.3.8 闭锁"></a>2.3.3.8 闭锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.RCountDownLatch latch &#x3D; redisson.getCountDownLatch(&quot;anyCountDownLatch&quot;);  </span><br><span class="line">2.latch.trySetCount(1);  </span><br><span class="line">3.latch.await();  </span><br><span class="line">4.  </span><br><span class="line">5.&#x2F;&#x2F; 在其他线程或其他JVM里  </span><br><span class="line">6.RCountDownLatch latch &#x3D; redisson.getCountDownLatch(&quot;anyCountDownLatch&quot;);  </span><br><span class="line">7.latch.countDown();</span><br></pre></td></tr></table></figure><h3 id="2-3-4Spring项目集成配置"><a href="#2-3-4Spring项目集成配置" class="headerlink" title="2.3.4Spring项目集成配置"></a>2.3.4Spring项目集成配置</h3><ul><li>pom</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.&lt;dependency&gt;  </span><br><span class="line">2.    &lt;groupId&gt;org.redisson&lt;&#x2F;groupId&gt;  </span><br><span class="line">3.    &lt;artifactId&gt;redisson&lt;&#x2F;artifactId&gt;  </span><br><span class="line">4.    &lt;version&gt;2.2.12&lt;&#x2F;version&gt;  </span><br><span class="line">5.&lt;&#x2F;dependency&gt;  </span><br><span class="line">6.&lt;dependency&gt;  </span><br><span class="line">7.    &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;  </span><br><span class="line">8.    &lt;artifactId&gt;jackson-annotations&lt;&#x2F;artifactId&gt;  </span><br><span class="line">9.    &lt;version&gt;2.6.0&lt;&#x2F;version&gt;  </span><br><span class="line">10.&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>xml配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;redisson:client  </span><br><span class="line">    id&#x3D;&quot;redisson&quot;  </span><br><span class="line">    name&#x3D;&quot;redisson1,redisson2&quot;  </span><br><span class="line">    threads&#x3D;&quot;0&quot;  </span><br><span class="line">    netty-threads&#x3D;&quot;0&quot;  </span><br><span class="line">    codec-ref&#x3D;&quot;myCodec&quot;   </span><br><span class="line">    transport-mode&#x3D;&quot;NIO&quot;  </span><br><span class="line">    redisson-reference-enabled&#x3D;&quot;true&quot;  </span><br><span class="line">    codec-provider-ref&#x3D;&quot;myCodecProvider&quot;  </span><br><span class="line">    resolver-provider-ref&#x3D;&quot;myResolverProvider&quot;  </span><br><span class="line">    executor-ref&#x3D;&quot;myExecutor&quot;  </span><br><span class="line">    event-loop-group-ref&#x3D;&quot;myEventLoopGroup&quot;&gt;  </span><br><span class="line"> &lt;!--这里的name属性和qualifier子元素不能同时使用。id和name的属性都可以被用来作为qualifier的备选值。  --&gt;  </span><br><span class="line">    &lt;!--&lt;qualifier value&#x3D;&quot;redisson3&quot;&#x2F;&gt;--&gt;  </span><br><span class="line">    &lt;redisson:cluster-servers  </span><br><span class="line">        idle-connection-timeout&#x3D;&quot;10000&quot;  </span><br><span class="line">        ping-timeout&#x3D;&quot;1000&quot;  </span><br><span class="line">        connect-timeout&#x3D;&quot;10000&quot;  </span><br><span class="line">        timeout&#x3D;&quot;3000&quot;  </span><br><span class="line">        retry-attempts&#x3D;&quot;3&quot;  </span><br><span class="line">        retry-interval&#x3D;&quot;1500&quot;  </span><br><span class="line">        reconnection-timeout&#x3D;&quot;3000&quot;  </span><br><span class="line">        failed-attempts&#x3D;&quot;3&quot;  </span><br><span class="line">        password&#x3D;&quot;do_not_use_if_it_is_not_set&quot;  </span><br><span class="line">        subscriptions-per-connection&#x3D;&quot;5&quot;  </span><br><span class="line">        client-name&#x3D;&quot;none&quot;  </span><br><span class="line">        load-balancer-ref&#x3D;&quot;myLoadBalancer&quot;  </span><br><span class="line">        subscription-connection-minimum-idle-size&#x3D;&quot;1&quot;  </span><br><span class="line">        subscription-connection-pool-size&#x3D;&quot;50&quot;  </span><br><span class="line">        slave-connection-minimum-idle-size&#x3D;&quot;10&quot;  </span><br><span class="line">        slave-connection-pool-size&#x3D;&quot;64&quot;  </span><br><span class="line">        master-connection-minimum-idle-size&#x3D;&quot;10&quot;  </span><br><span class="line">        master-connection-pool-size&#x3D;&quot;64&quot;  </span><br><span class="line">        read-mode&#x3D;&quot;SLAVE&quot;  </span><br><span class="line">        subscription-mode&#x3D;&quot;SLAVE&quot;  </span><br><span class="line">        scan-interval&#x3D;&quot;1000&quot;&gt;  </span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot; &#x2F;&gt;  </span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6380&quot; &#x2F;&gt;  </span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6381&quot; &#x2F;&gt;  </span><br><span class="line">    &lt;&#x2F;redisson:cluster-servers&gt;  </span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br></pre></td></tr></table></figure><ul><li>最基本配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.&lt;!-- 最基本配置 --&gt;  </span><br><span class="line">2.&lt;redisson:client&gt;  </span><br><span class="line">3.    &lt;redisson:cluster-servers&gt;  </span><br><span class="line">4.        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot; &#x2F;&gt;  </span><br><span class="line">5.        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6380&quot; &#x2F;&gt;  </span><br><span class="line">6.        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6381&quot; &#x2F;&gt;  </span><br><span class="line">7.        ...  </span><br><span class="line">8.    &lt;&#x2F;redisson:cluster-servers&gt;  </span><br><span class="line">9.&lt;&#x2F;redisson:client&gt;</span><br></pre></td></tr></table></figure><h1 id="3-zookeeper（过段时间填坑）"><a href="#3-zookeeper（过段时间填坑）" class="headerlink" title="3. zookeeper（过段时间填坑）"></a>3. zookeeper（过段时间填坑）</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要通过一些互斥手段来防止彼此之间的干扰，以保证一致性，在这种情况下，就需要使用分布式锁了。
    
    </summary>
    
    
    
      <category term="经验积累" scheme="https://dcghx.github.io/tags/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>经验积累————缓存双写一致性</title>
    <link href="https://dcghx.github.io/2020/05/09/ywjy-%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>https://dcghx.github.io/2020/05/09/ywjy-%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-31T05:17:40.844Z</updated>
    
    <content type="html"><![CDATA[<p>分布式缓存是现在很多分布式应用中必不可少的组件，但是用到了分布式缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？<a id="more"></a></p><h1 id="1-Cache-Aside-Pattern"><a href="#1-Cache-Aside-Pattern" class="headerlink" title="1.Cache Aside Pattern"></a>1.Cache Aside Pattern</h1><p><strong><em>\</em>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。**</strong></p><p>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。更新的时候，<strong><em>\</em>先更新数据库，然后再删除缓存**</strong>。</p><p>为什么是删除缓存，而不是更新缓存？</p><p>原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。</p><p>另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于<strong><em>\</em>比较复杂的缓存数据计算的场景**</strong>，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，<strong><em>\</em>这个缓存到底会不会被频繁访问到？**</strong></p><p>举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低，用到缓存才去算缓存。</p><p><strong><em>\</em>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算**</strong>。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，都里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。</p><h1 id="2-最初级的缓存不一致问题及解决方案"><a href="#2-最初级的缓存不一致问题及解决方案" class="headerlink" title="2.最初级的缓存不一致问题及解决方案"></a>2.最初级的缓存不一致问题及解决方案</h1><p>问题：先修改数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p><p><img src="ywjy-%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7.assets/image-20200531131417979.png" alt="image-20200531131417979"></p><p><strong><em>\</em>解决思路：**</strong>先删除缓存，再修改数据库。如果数据库修改失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中。</p><h1 id="3-比较复杂的数据不一致问题分析"><a href="#3-比较复杂的数据不一致问题分析" class="headerlink" title="3.比较复杂的数据不一致问题分析"></a>3.比较复杂的数据不一致问题分析</h1><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong><em>\</em>查到了修改前的旧数据，放到了缓存中**</strong>。随后数据变更的程序完成了数据库的修改。</p><p>完了，数据库和缓存中的数据不一样了。。。</p><p>为什么上亿流量高并发场景下，缓存会出现这个问题？</p><p>只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，<strong><em>\</em>就可能会出现上述的数据库+缓存不一致的情况。**</strong></p><p>解决方案如下：</p><p>更新数据的时候，根据<strong><em>\</em>数据的唯一标识**</strong>，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个 jvm 内部队列中。</p><p>一个队列对应一个工作线程，每个工作线程<strong><em>\</em>串行**</strong>拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p><p>这里有一个<strong><em>\</em>优化点**</strong>，一个队列中，其实<strong><em>\</em>多个更新缓存请求串在一起是没意义的**</strong>，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p><p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。</p><p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p><p>高并发的场景下，该解决方案要注意的问题：</p><h2 id="3-1-读请求长时阻塞"><a href="#3-1-读请求长时阻塞" class="headerlink" title="3.1 读请求长时阻塞"></a>3.1 读请求长时阻塞</h2><p>由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。<br>该解决方案，最大的风险点在于说，可能数据更新很频繁，导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库。务必通过一些模拟真实的测试，看看更新数据的频率是怎样的。<br>另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要部署多个服务，每个服务分摊一些数据的更新操作。如果一个内存队列里居然会挤压 100 个商品的库存修改操作，每隔库存修改操作要耗费 10ms 去完成，那么最后一个商品的读请求，可能等待 10 * 100 = 1000ms = 1s 后，才能得到数据，这个时候就导致读请求的长时阻塞。<br>一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会 hang 多少时间，如果读请求在 200ms 返回，如果你计算过后，哪怕是最繁忙的时候，积压 10 个更新操作，最多等待 200ms，那还可以的。<br>如果一个内存队列中可能积压的更新操作特别多，那么你就要加机器，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。<br>其实根据之前的项目经验，一般来说，数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。像这种针对读高并发、读缓存架构的项目，一般来说写请求是非常少的，每秒的 QPS 能到几百就不错了。<br>实际粗略测算一下<br>如果一秒有 500 的写操作，如果分成 5 个时间片，每 200ms 就 100 个写操作，放到 20 个内存队列中，每个内存队列，可能就积压 5 个写操作。每个写操作性能测试后，一般是在 20ms 左右就完成，那么针对每个内存队列的数据的读请求，也就最多 hang 一会儿，200ms 以内肯定能返回了。<br>经过刚才简单的测算，我们知道，单机支撑的写 QPS 在几百是没问题的，如果写 QPS 扩大了 10 倍，那么就扩容机器，扩容 10 倍的机器，每个机器 20 个队列。</p><h2 id="3-2-读请求并发量过高"><a href="#3-2-读请求并发量过高" class="headerlink" title="3.2 读请求并发量过高"></a>3.2 读请求并发量过高</h2><p>这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时 hang 在服务上，看服务能不能扛的住，需要多少机器才能扛住最大的极限情况的峰值。</p><p>但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大。</p><h2 id="3-3-多服务实例部署的请求路由"><a href="#3-3-多服务实例部署的请求路由" class="headerlink" title="3.3 多服务实例部署的请求路由"></a>3.3 多服务实例部署的请求路由</h2><p>可能这个服务部署了多个实例，那么必须保证说，执行数据更新操作，以及执行缓存更新操作的请求，都通过 Nginx 服务器路由到相同的服务实例上。<br>比如说，对同一个商品的读写请求，全部路由到同一台机器上。可以自己去做服务间的按照某个请求参数的 hash 路由，也可以用 Nginx 的 hash 路由功能等等。</p><h2 id="3-4-热点商品的路由问题，导致请求的倾斜"><a href="#3-4-热点商品的路由问题，导致请求的倾斜" class="headerlink" title="3.4 热点商品的路由问题，导致请求的倾斜"></a>3.4 热点商品的路由问题，导致请求的倾斜</h2><p>万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能会造成某台机器的压力过大。就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以其实要根据业务系统去看，如果更新频率不是太高的话，这个问题的影响并不是特别大，但是的确可能某些机器的负载会高一些。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式缓存是现在很多分布式应用中必不可少的组件，但是用到了分布式缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？
    
    </summary>
    
    
    
      <category term="经验积累" scheme="https://dcghx.github.io/tags/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>经验积累————接口幂等性</title>
    <link href="https://dcghx.github.io/2020/05/09/ywjy-%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <id>https://dcghx.github.io/2020/05/09/ywjy-%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-31T05:24:57.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。<a id="more"></a></p><p>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的，更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</p><p>幂等在我的理解里就是，一个操作不论被执行多少次，产生的效果和返回的结果都是一样的。</p><ul><li><p>一个幂等的操作典型如：把编号为5的记录的A字段设置为0这种操作不管执行多少次都是幂等的。</p></li><li><p>一个非幂等的操作典型如：把编号为5的记录的A字段增加1这种操作显然就不是幂等的。</p></li></ul><p>任意多次执行所产生的影响均与一次执行的影响相同，这是幂等性的核心特点。其实在我们编程中主要操作就是CURD，其中读取（Retrieve）操作和删除（Delete）操作是天然幂等的，受影响的就是创建（Create）、更新（Update）。</p><p>对于业务中需要考虑幂等性的地方一般都是接口的重复请求，重复请求是指同一个请求因为某些原因被多次提交。导致这个情况会有几种场景：</p><ul><li><p>前端重复提交：提交订单，用户快速重复点击多次，造成后端生成多个内容重复的订单。</p></li><li><p>接口超时重试：对于给第三方调用的接口，为了防止网络抖动或其他原因造成请求丢失，这样的接口一般都会设计成超时重试多次。</p></li><li><p>消息重复消费：MQ消息中间件，消息重复消费。</p></li></ul><p>对于一些业务场景影响比较大的，接口的幂等性是个必须要考虑的问题，例如金钱的交易方面的接口。否则一个错误的、考虑不周的接口可能会给公司带来巨额的金钱损失，那么背锅的肯定是程序员自己了。</p><h1 id="1-幂等性的实现方式"><a href="#1-幂等性的实现方式" class="headerlink" title="1. 幂等性的实现方式"></a>1. 幂等性的实现方式</h1><p>对于和web端交互的接口，我们可以在前端拦截一部分，例如防止表单重复提交，按钮置灰、隐藏、不可点击等方式。</p><p>但是前端做控制实际效益不是很高，懂点技术的都会模拟请求调用你的服务，所以安全的策略还是需要从后端的接口层来做。</p><p>那么后端要实现分布式接口的幂等性有哪些策略方式呢？主要可以从以下几个方面来考虑实现：</p><h2 id="1-1-token机制"><a href="#1-1-token机制" class="headerlink" title="1.1 token机制"></a>1.1 token机制</h2><p>针对前端重复连续多次点击的情况，例如用户购物提交订单，提交订单的接口就可以通过 Token 的机制实现防止重复提交。</p><p><img src="ywjy-%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7.assets/image-20200531132106094.png" alt="image-20200531132106094"></p><p>主要流程就是：</p><ul><li><p>服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。（微服务肯定是分布式了，如果单机就适用jvm缓存）。</p></li><li><p>然后调用业务接口请求时，把token携带过去，一般放在请求头部。</p></li><li><p>服务器判断token是否存在redis中，存在表示第一次请求，可以继续执行业务，执行业务完成后，最后需要把redis中的token删除。</p></li><li><p>如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。</p></li></ul><h2 id="1-2-库表唯一索引"><a href="#1-2-库表唯一索引" class="headerlink" title="1.2 库表唯一索引"></a>1.2 库表唯一索引</h2><p>利用数据库的唯一索引特性，保证唯一的逻辑。唯一序列号可以是一个字段，例如订单的订单号，也可以是多字段的唯一性组合</p><p>比如有一个特殊订单表，这个特殊订单表关联了一个用户表，业务设置是每一个用户只能创建一个特殊订单，也就意味着在这个特殊订单表中只能有一条用户关联的记录。那么这时候就可以在这个特殊订单表上针对这个用户关联的字段做一个唯一索引，通过数据库的唯一约束来限制往特殊订单表中插入多条一个用户关联的记录。这样，当第二次请求往特殊订单表中插入一个用户关联的特殊订单记录的时候，数据库就会报错并回滚插入操作，也就保证了幂等。</p><h2 id="1-3分布式锁：另一个角度的Token校验"><a href="#1-3分布式锁：另一个角度的Token校验" class="headerlink" title="1.3分布式锁：另一个角度的Token校验"></a>1.3分布式锁：另一个角度的Token校验</h2><p>如果是分布式系统的话，构建全局唯一索引会比较困难，比如唯一性的字段就没有办法确定。这时候可以引入分布式锁，通过第三方的系统（Redis或Zookeeper），在业务系统插入数据或者更新数据前，需要先获取分布式锁，然后才能做操作，操作完成之后就释放锁。这样其实是把单机系统里面多线程并发锁的思路引入了多个系统的场景，也就是分布式系统中的解决思路。</p><p>要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志（用户ID+后缀等）获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁（分布式锁要第三方系统提供）。</p><h2 id="1-4悲观锁：获取数据的时候加锁获取"><a href="#1-4悲观锁：获取数据的时候加锁获取" class="headerlink" title="1.4悲观锁：获取数据的时候加锁获取"></a>1.4悲观锁：获取数据的时候加锁获取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;&#x2F;for update 行锁，当一个事务的操作未完成时候，其他事务可以读取但是不能写入或更新。  </span><br><span class="line">2.select * from yanggb where id &#x3D; &#39;huangq&#39; for update;</span><br></pre></td></tr></table></figure><p>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，需要根据实际情况选用。另外要注意的是，id字段一定是主键或者唯一索引，不然可能造成锁表的结果，处理起来会非常麻烦。</p><h2 id="1-5乐观锁：通过版本号或其他状态字段做更新限制"><a href="#1-5乐观锁：通过版本号或其他状态字段做更新限制" class="headerlink" title="1.5乐观锁：通过版本号或其他状态字段做更新限制"></a>1.5乐观锁：通过版本号或其他状态字段做更新限制</h2><p>与悲观锁长时间锁表不一样，乐观锁只是在更新数据那一刻锁表，其他时间不锁表。所以乐观锁相对于悲观锁，在大部分场景中效率会更高一些。乐观锁的实现方式多种多样，可以通过version或者其他状态条件。</p><p><img src="ywjy-%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7.assets/image-20200531132333942.png" alt="image-20200531132333942"></p><p>比如给业务表内添加一个版本号的字段，如果要调用一个接口去更新年龄之前，就需要先查一下他的版本号是多少，然后调用接口的时候带上版本号。</p><p>在接口里保证分布式接口的幂等性（在更新的SQL中添加version的条件判断）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.update user set age &#x3D; 21, version &#x3D; version + 1 where id &#x3D; 1 and version &#x3D; 1</span><br></pre></td></tr></table></figure><p>这样，多次提交的请求，因为版本号（version）都一样，因为第一次请求执行成功之后version已经+1了，则后面的请求因为version对应不上，都不会被执行。</p><h2 id="1-6状态机幂等：另一个角度的乐观锁。"><a href="#1-6状态机幂等：另一个角度的乐观锁。" class="headerlink" title="1.6状态机幂等：另一个角度的乐观锁。"></a>1.6状态机幂等：另一个角度的乐观锁。</h2><p>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机（状态变更图）。简单理解，就是业务单据上面有个状态的字段，状态在不同的情况下会发生变更，一般情况下存在有限状态机。这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助。</p><p>对于很多业务是有一个业务流转状态的，每个状态都有前置状态和后置状态，以及最后的结束状态。例如流程的待审批，审批中，驳回，重新发起，审批通过，审批拒绝。订单的待提交，待支付，已支付，取消。</p><p>以订单为例，已支付的状态的前置状态只能是待支付，而取消状态的前置状态只能是待支付，通过这种状态机的流转我们就可以控制请求的幂等。</p><p>假设当前状态是已支付，这时候如果支付接口又接收到了支付请求，则会抛异常或拒绝此次处理。</p><h2 id="1-7-总结"><a href="#1-7-总结" class="headerlink" title="1.7 总结"></a>1.7 总结</h2><p>通过以上的了解我们可以知道，针对不同的业务场景我们需要灵活的选择幂等性的实现方式。</p><p>例如防止类似于前端重复提交、重复下单的场景就可以通过 Token 的机制实现，而那些有状态前置和后置转换的场景则可以通过状态机的方式实现幂等性，对于那些重复消费和接口重试的场景则使用数据库唯一索引的方式实现更合理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。
    
    </summary>
    
    
    
      <category term="经验积累" scheme="https://dcghx.github.io/tags/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>经验积累————系统如何支撑高并发-思路</title>
    <link href="https://dcghx.github.io/2020/05/09/ywjy-%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E6%94%AF%E6%92%91%E9%AB%98%E5%B9%B6%E5%8F%91-%E6%80%9D%E8%B7%AF%20%E5%89%AF%E6%9C%AC/"/>
    <id>https://dcghx.github.io/2020/05/09/ywjy-%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E6%94%AF%E6%92%91%E9%AB%98%E5%B9%B6%E5%8F%91-%E6%80%9D%E8%B7%AF%20%E5%89%AF%E6%9C%AC/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-31T05:44:22.076Z</updated>
    
    <content type="html"><![CDATA[<p>很多人面试的时候被问到一个让人特别手足无措的问题：你的系统如何支撑高并发？<a id="more"></a></p><p>大多数同学被问到这个问题压根儿没什么思路去回答，不知道从什么地方说起，其实本质就是没经历过一些真正有高并发系统的锤炼罢了。</p><p>因为没有过相关的项目经历，所以就没法从真实的自身体会和经验中提炼出一套回答，然后系统地阐述出来自己负责过的系统如何支撑高并发的。</p><p>所以，这篇文章就从这个角度切入来简单说说这个问题，教你用一个最简单的思路来如何应对的。</p><p>当然这里首先说清楚一个前提：高并发系统各不相同。比如每秒百万并发的中间件系统、每日百亿请求的网关系统、瞬时每秒几十万请求的秒杀大促系统。</p><p>他们在应对高并发的时候，因为系统各自特点的不同，所以应对架构都是不一样的。</p><p>另外，比如电商平台中的订单系统、商品系统、库存系统，在高并发场景下的架构设计也是不同的，因为背后的业务场景都不一样。</p><p>所以，这篇文章主要是给大家提供一个回答这类问题的思路，不涉及任何复杂架构设计，让你不至于在面试中被问到这个问题时，跟面试官大眼瞪小眼。</p><p>具体要真能在面试的时候回答好这个问题，建议各位参考一下本文思路，然后对你自己手头负责的系统多去思考一下，最好做一些相关的架构实践。</p><h1 id="1-先考虑一个简单的系统架构"><a href="#1-先考虑一个简单的系统架构" class="headerlink" title="1. 先考虑一个简单的系统架构"></a>1. 先考虑一个简单的系统架构</h1><p>假设刚刚开始你的系统就部署在一台机器上，背后就连接了一台数据库，数据库部署在一台服务器上。</p><p>我们甚至可以再现实点，例如你的系统部署的机器是4核8G，数据库服务器是16核32G。</p><p>此时假设系统用户量总共就10万，用户量很少，日活用户按照不同系统的场景有区别，我们取一个较为客观的比例，10%吧，每天活跃的用户就1万。</p><p>按照二八法则，每天高峰期算4个小时，高峰期活跃的用户占比达到80%，就是8000人活跃在4小时内。然后每个人对系统发起请求，我们按照每天20次算吧。那么高峰期8000人发起的请求也才16万次，平均到4小时内的每秒（14400秒），每秒也就10次请求。</p><p>好吧！完全跟高并发搭不上边，对不对？</p><p>然后系统层面每秒是10次请求，对数据库的调用每次请求都会好几次数据库操作的，比如做CRUD之类的。</p><p>那么我们取一个一次请求对应3次数据库请求吧，那这样的话，数据库层每秒也就30次请求，对不对？</p><p>按照这台数据库服务器的配置，支撑是绝对没问题的。上述描述的系统，用一张图表示，就是下面这样：</p><p>![image-20200531134051415](ywjy-系统如何支撑高并发-思路 副本.assets/image-20200531134051415.png)</p><p>假设此时用户数开始快速增长，比如注册用户量增长了50倍，上升到了500万。</p><p>此时日活用户是50万，高峰期对系统每秒请求是500/s。然后对数据库的每秒请求数量是1500/s，这个时候会怎么样呢？</p><p>按照上述的机器配置来说，如果系统内处理的是较为复杂的一些业务逻辑，是那种重业务逻辑的系统的话，是比较耗费CPU的。</p><p>此时，4核8G的机器每秒请求达到500/s的时候，很可能你的机器CPU负载较高了。</p><p>然后数据库层面，以上述的配置而言，其实基本上1500/s的高峰请求压力的话，还算可以接受。</p><p>这个主要是要观察数据库所在机器的磁盘负载、网络负载、CPU负载、内存负载，按照我们的线上经验而言，那个配置的数据库在1500/s请求压力下是没问题的。</p><p>所以此时需要做的一个事情，首先就是要支持你的系统集群化部署。</p><p>可以在前面挂一个负载均衡层，把请求均匀打到系统层面，让系统可以用多台机器集群化支撑更高的并发压力。</p><p>比如说这里假设给系统增加部署一台机器，那么每台机器就只有250/s的请求了。</p><p>这样一来，两台机器的CPU负载都会明显降低，这个初步的“高并发”不就先cover住了吗？</p><p>要是连这个都不做，那单台机器负载越来越高的时候，极端情况下是可能出现机器上部署的系统无法有足够的资源响应请求了，然后出现请求卡死，甚至系统宕机之类的问题。</p><p>所以，简单小结，第一步要做的：</p><ul><li><p>添加负载均衡层，将请求均匀打到系统层。</p></li><li><p>系统层采用集群化部署多台机器，扛住初步的并发压力。</p></li></ul><p>此时的架构图变成下面的样子：</p><p>![image-20200531134123850](ywjy-系统如何支撑高并发-思路 副本.assets/image-20200531134123850.png)</p><h1 id="2-数据库分库分表-读写分离"><a href="#2-数据库分库分表-读写分离" class="headerlink" title="2. 数据库分库分表+读写分离"></a>2. 数据库分库分表+读写分离</h1><p>假设此时用户量继续增长，达到了1000万注册用户，然后每天日活用户是100万。</p><p>那么此时对系统层面的请求量会达到每秒1000/s，系统层面，你可以继续通过集群化的方式来扩容，反正前面的负载均衡层会均匀分散流量过去的。</p><p>但是，这时数据库层面接受的请求量会达到3000/s，这个就有点问题了。</p><p>此时数据库层面的并发请求翻了一倍，你一定会发现线上的数据库负载越来越高。</p><p>每次到了高峰期，磁盘IO、网络IO、内存消耗、CPU负载的压力都会很高，大家很担心数据库服务器能否抗住。</p><p>没错，一般来说，对那种普通配置的线上数据库，建议就是读写并发加起来，按照上述我们举例的那个配置，不要超过3000/s。</p><p>因为数据库压力过大，首先一个问题就是高峰期系统性能可能会降低，因为数据库负载过高对性能会有影响。</p><p>另外一个，压力过大把你的数据库给搞挂了怎么办？</p><p>所以此时你必须得对系统做分库分表 + 读写分离，也就是把一个库拆分为多个库，部署在多个数据库服务上，这是作为主库承载写入请求的。</p><p>然后每个主库都挂载至少一个从库，由从库来承载读请求。</p><p>此时假设对数据库层面的读写并发是3000/s，其中写并发占到了1000/s，读并发占到了2000/s。</p><p>那么一旦分库分表之后，采用两台数据库服务器上部署主库来支撑写请求，每台服务器承载的写并发就是500/s。每台主库挂载一个服务器部署从库，那么2个从库每个从库支撑的读并发就是1000/s。</p><p>简单总结，并发量继续增长时，我们就需要focus在数据库层面：分库分表、读写分离。此时的架构图如下所示：</p><p>![image-20200531134206158](ywjy-系统如何支撑高并发-思路 副本.assets/image-20200531134206158.png)</p><h1 id="3-缓存集群的引入"><a href="#3-缓存集群的引入" class="headerlink" title="3. 缓存集群的引入"></a>3. 缓存集群的引入</h1><p>接着就好办了，如果注册用户量越来越大，此时你可以不停地加机器，比如说系统层面不停加机器，就可以承载更高的并发请求。</p><p>然后数据库层面如果写入并发越来越高，就扩容加数据库服务器，通过分库分表是可以支持扩容机器的，如果数据库层面的读并发越来越高，就扩容加更多的从库。</p><p>但是这里有一个很大的问题：数据库其实本身不是用来承载高并发请求的。所以通常来说，数据库单机每秒承载的并发就在几千的数量级，而且数据库使用的机器都是比较高配置，比较昂贵的机器，成本很高。</p><p>如果不停地加机器，这是不对的。</p><p>在高并发架构里通常都有缓存这个环节，缓存系统的设计就是为了承载高并发而生。</p><p>单机承载的并发量都在每秒几万，甚至每秒数十万，对高并发的承载能力比数据库系统要高出一到两个数量级。</p><p>可以根据系统的业务特性，对那种写少读多的请求，引入缓存集群。</p><p>具体来说，就是在写数据库的时候同时写一份数据到缓存集群里，然后用缓存集群来承载大部分的读请求。</p><p>这样的话，通过缓存集群，就可以用更少的机器资源承载更高的并发。</p><p>比如说上面那个图里，读请求目前是每秒2000/s，两个从库各自抗了1000/s读请求，但是其中可能每秒1800次的读请求都是可以直接读缓存里的不怎么变化的数据的。</p><p>那么此时你一旦引入缓存集群，就可以抗下来这1800/s读请求，落到数据库层面的读请求就200/s。</p><p>同样，给大家来一张架构图，一起来感受一下：</p><p>![image-20200531134240804](ywjy-系统如何支撑高并发-思路 副本.assets/image-20200531134240804.png)</p><p>按照上述架构，好处是什么呢？</p><p>可能未来你的系统读请求每秒都几万次了，但是可能80%~90%都是通过缓存集群来读的，而缓存集群里的机器可能单机每秒都可以支撑几万读请求，所以耗费机器资源很少，可能就两三台机器就够了。</p><p>要是换成数据库来试一下，可能就要不停地加从库到10台、20台机器才能抗住每秒几万的读并发，那个成本是极高的。</p><p>好了，我们再来简单小结，承载高并发需要考虑的第三个点：</p><ul><li><p>不要盲目进行数据库扩容，数据库服务器成本昂贵，且本身就不是用来承载高并发的</p></li><li><p>针对写少读多的请求，引入缓存集群，用缓存集群抗住大量的读请求</p></li></ul><h1 id="4-引入消息中间件集群"><a href="#4-引入消息中间件集群" class="headerlink" title="4. 引入消息中间件集群"></a>4. 引入消息中间件集群</h1><p>接着再来看看数据库写这块的压力，其实是跟读类似的。</p><p>假如说所有写请求全部都落地数据库的主库层，当然是没问题的，但是写压力要是越来越大了呢？</p><p>比如每秒要写几万条数据，此时难道也是不停的给主库加机器吗？</p><p>可以当然也可以，但是同理，耗费的机器资源是很大的，这个就是数据库系统的特点所决定的。</p><p>相同的资源下，数据库系统太重太复杂，所以并发承载能力就在几千/s的量级，所以此时你需要引入别的一些技术。</p><p>比如说消息中间件技术，也就是MQ集群，是非常好的做写请求异步化处理，实现削峰填谷的效果。</p><p>假如说，现在每秒是1000/s次写请求，其中比如500次请求是必须请求过来立马写入数据库中的，但是另外500次写请求是可以允许异步化等待个几十秒，甚至几分钟后才落入数据库内的。</p><p>那么此时完全可以引入消息中间件集群，把允许异步化的每秒500次请求写入MQ，然后基于MQ做一个削峰填谷。比如就以平稳的100/s的速度消费出来然后落入数据库中即可，此时就会大幅度降低数据库的写入压力。</p><p>此时，架构图变成了下面这样：</p><p>![image-20200531134329813](ywjy-系统如何支撑高并发-思路 副本.assets/image-20200531134329813.png)</p><p>大家看上面的架构图，首先消息中间件系统本身也是为高并发而生，所以通常单机都是支撑几万甚至十万级的并发请求的。</p><p>所以，这本身也跟缓存系统一样，可以用很少的资源支撑很高的并发请求，用来支撑部分允许异步化的高并发写入是没问题的，比使用数据库直接支撑那部分高并发请求要减少很多的机器使用量。</p><p>而且经过消息中间件的削峰填谷之后，比如就用稳定的100/s的速度写数据库，那么数据库层面接收的写请求压力，不就成了500/s + 100/s  = 600/s了么？</p><p>大家看看，是不是发现减轻了数据库的压力？</p><p>到目前为止，通过下面的手段，我们已经可以让系统架构尽可能用最小的机器资源抗住了最大的请求压力，减轻了数据库的负担。</p><ul><li><p>系统集群化</p></li><li><p>数据库层面的分库分表+读写分离</p></li><li><p>针对读多写少的请求，引入缓存集群</p></li><li><p>针对高写入的压力，引入消息中间件集群</p></li></ul><h1 id="5-现在能hold住面试题了么？"><a href="#5-现在能hold住面试题了么？" class="headerlink" title="5. 现在能hold住面试题了么？"></a>5. 现在能hold住面试题了么？</h1><p>看完了这篇文章，你觉得自己能回答好面试里的高并发问题了吗？</p><p>很遗憾，答案是不能。而且我觉得单单凭借几篇文章是绝对不可能真的让你完全回答好这个问题的，这里有很多原因在里面。</p><p>首先，高并发这个话题本身是非常复杂的，远远不是一些文章可以说的清楚的，本质就在于，真实的支撑复杂业务场景的高并发系统架构其实是非常复杂的。</p><p>比如说每秒百万并发的中间件系统、每日百亿请求的网关系统、瞬时每秒几十万请求的秒杀大促系统、支撑几亿用户的大规模高并发电商平台架构，等等。</p><p>为了支撑高并发请求，在系统架构的设计时，会结合具体的业务场景和特点，设计出各种复杂的架构，这需要大量底层技术支撑，需要精妙的架构和机制设计的能力。</p><p>最终，各种复杂系统呈现出来的架构复杂度会远远超出大部分没接触过的同学的想象。</p><p>但是那么复杂的系统架构，通过一些文章是很难说的清楚里面的各种细节以及落地生产的过程的。</p><p>其次，高并发这话题本身包含的内容也远远不止本文说的这么几个topic：分库分表、缓存、消息。</p><p>一个完整而复杂的高并发系统架构中，一定会包含各种复杂的自研基础架构系统、各种精妙的架构设计（比如热点缓存架构设计、多优先级高吞吐MQ架构设计、系统全链路并发性能优化设计，等等）、还有各种复杂系统组合而成的高并发架构整体技术方案、还有NoSQL（Elasticsearch等）/负载均衡/Web服务器等相关技术。</p><p>所以大家切记要对技术保持敬畏之心，这些东西都很难通过一些文章来表述清楚。</p><p>最后，真正在生产落地的时候，高并发场景下系统会出现大量的技术问题。</p><p>比如说消息中间件吞吐量上不去需要优化、磁盘写压力过大性能太差、内存消耗过大容易撑爆、分库分表中间件不知道为什么丢了数据等等吧。</p><p>诸如此类的问题非常多，这些也不可能通过文章给全部说清楚。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多人面试的时候被问到一个让人特别手足无措的问题：你的系统如何支撑高并发？
    
    </summary>
    
    
    
      <category term="经验积累" scheme="https://dcghx.github.io/tags/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>nginx————负载均衡</title>
    <link href="https://dcghx.github.io/2020/05/09/nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://dcghx.github.io/2020/05/09/nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-31T06:00:25.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前我们搭建网站的时候，把war包放到tomcat下就能运行起来了，为什么部署上线的时候，又用到了nginx呢？<br>nginx可以做多台服务器的负载均衡，当用户非常少的时候，可以用一台服务直接部署web环境，那么当用户达到百万级别，千万级别的时候，就需要增加服务器，多台服务器又如何管理协作的呢？<a id="more"></a></p><p>nginx有以下功能：</p><ol><li>静态HTTP服务器-Nginx是一个HTTP服务器，可以将服务器上的静态文件（如HTML、图片）通过HTTP协议展现给客户端。</li><li>反向代理服务器-客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。</li><li>负载均衡-当网站访问量非常大，网站站长开心赚钱的同时，也摊上事儿了。因为网站越来越慢，一台服务器已经不够用了。<br>于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。同时带来的好处是，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</li><li>虚拟主机-有的网站访问量大，需要负载均衡。然而并不是所有网站都如此出色，有的网站，由于访问量太小，需要节省成本，将多个网站部署在同一台服务器上。</li><li>FastCGI-Nginx本身不支持PHP等语言，但是它可以通过FastCGI来将请求扔给某些语言或框架处理（例如PHP、Python、Perl）。</li></ol><h1 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h1><p>Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；<br>Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。</p><p>正向代理，代理的是客户端，比如小伙伴们平常科学上网,访问google网站就是用到的正向代理。</p><p><img src="nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.assets/image-20200531135053061.png" alt="image-20200531135053061"></p><p>反向代理，它代理的是服务端，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。</p><p><img src="nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.assets/image-20200531135108452.png" alt="image-20200531135108452"></p><h1 id="Nginx依赖包安装"><a href="#Nginx依赖包安装" class="headerlink" title="Nginx依赖包安装"></a>Nginx依赖包安装</h1><p>先安装依赖包</p><ol><li>gcc安装：安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装</li><li>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库</li><li>zlib库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</li><li>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.yum install -y gcc-c++  </span><br><span class="line">2.yum install -y pcre pcre-devel  </span><br><span class="line">3.yum install -y zlib zlib-devel  </span><br><span class="line">4.yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure><h1 id="Nginx下载与安装"><a href="#Nginx下载与安装" class="headerlink" title="Nginx下载与安装"></a>Nginx下载与安装</h1><p>直接下载.tar.gz安装包，下载地址：<a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">https://nginx.org/en/download.html</a><br>把下载的包放到/usr/local/nginx目录，然后解压安装到nginx-1.12.0当前目录，make编译安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.[root@yoyo sbin]# cd ~  </span><br><span class="line">2.[root@yoyo ~]# cd &#x2F;usr&#x2F;local&#x2F;  </span><br><span class="line">3.[root@yoyo local]# mkdir nginx  </span><br><span class="line">4.[root@yoyo local]# cd nginx  </span><br><span class="line">5.[root@yoyo nginx]# wget -c https:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.12.0.tar.gz  </span><br><span class="line">6.  </span><br><span class="line">7.[root@yoyo nginx]# tar -zxvf nginx-1.12.0.tar.gz  </span><br><span class="line">8.[root@yoyo nginx]# cd nginx-1.12.0  </span><br><span class="line">9.  </span><br><span class="line">10.# 安装到当前目录  </span><br><span class="line">11.[root@yoyo nginx]# .&#x2F;configure  </span><br><span class="line">12.[root@yoyo nginx]# make  </span><br><span class="line">13.[root@yoyo nginx]# make install</span><br></pre></td></tr></table></figure><p>到此为止环境已经安装好，接下来启动nginx服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.[root@yoyo nginx]# cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;  </span><br><span class="line">2.[root@yoyo nginx]# .&#x2F;nginx</span><br></pre></td></tr></table></figure><p>启动服务后，nginx默认是在80端口启动的，在浏览器输入<a href="http://47.104.x.x:80/" target="_blank" rel="noopener">http://47.104.x.x:80/</a> (80端口默认可以省略),能正常访问到页面，说明服务启动成功</p><p><img src="nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.assets/image-20200531135259807.png" alt="image-20200531135259807"></p><h1 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h1><p>先cd到/usr/local/nginx/sbin/</p><ol><li>启动服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure><ol start="2"><li>停止服务,此方式停止步骤是待nginx进程处理任务完毕进行停止。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -s stop</span><br></pre></td></tr></table></figure><ol start="3"><li>退出服务,此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -s quit</span><br></pre></td></tr></table></figure><ol start="4"><li>重新加载,当 ngin x的配置文件 nginx.conf 修改后，要想让配置生效需要重启 nginx，<br>使用-s reload不用先停止 ngin x再启动 nginx 即可将配置信息在 nginx 中生效</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure><ol start="5"><li>查询nginx进程</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep nginx</span><br></pre></td></tr></table></figure><h1 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h1><p>在系统服务目录里创建nginx.service文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service</span><br></pre></td></tr></table></figure><p>内容如下</p><p>Description:描述服务<br>After:描述服务类别<br>[Service]服务运行参数的设置<br>Type=forking是后台运行的形式<br>ExecStart为服务的具体运行命令<br>ExecReload为重启命令<br>ExecStop为停止命令<br>PrivateTmp=True表示给服务分配独立的临时空间<br>注意：[Service]的启动、重启、停止命令全部要求使用绝对路径<br>[Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3</p><p>:wq保存退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.[Unit]  </span><br><span class="line">2.Description&#x3D;nginx  </span><br><span class="line">3.After&#x3D;network.target  </span><br><span class="line">4.    </span><br><span class="line">5.[Service]  </span><br><span class="line">6.Type&#x3D;forking  </span><br><span class="line">7.ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx  </span><br><span class="line">8.ExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload  </span><br><span class="line">9.ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s quit  </span><br><span class="line">10.PrivateTmp&#x3D;true  </span><br><span class="line">11.    </span><br><span class="line">12.[Install]  </span><br><span class="line">13.WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p>1.设置开机自启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nginx.service</span><br></pre></td></tr></table></figure><p>2.停止开机自启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable nginx.service</span><br></pre></td></tr></table></figure><p>3.启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure><p>4.重新启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx.service</span><br></pre></td></tr></table></figure><p>5.查看所有已启动的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --type&#x3D;service</span><br></pre></td></tr></table></figure><h1 id="修改Nginx启动端口"><a href="#修改Nginx启动端口" class="headerlink" title="修改Nginx启动端口"></a>修改Nginx启动端口</h1><p>如果80端口之前已经使用过了，可以修改nginx的服务端口，先cd到/usr/local/nginx/conf目录<br>为了保险起见，编辑前先备份下原来的文件：cp nginx.conf nginx.conf.bak</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.[root@yoyo ~]# cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf  </span><br><span class="line">2.[root@yoyo conf]# ll  </span><br><span class="line">3.total 60  </span><br><span class="line">4.-rw-r--r-- 1 root root 1077 Jan  8 14:16 fastcgi.conf  </span><br><span class="line">5.-rw-r--r-- 1 root root 1077 Jan  8 14:16 fastcgi.conf.default  </span><br><span class="line">6.-rw-r--r-- 1 root root 1007 Jan  8 14:16 fastcgi_params  </span><br><span class="line">7.-rw-r--r-- 1 root root 1007 Jan  8 14:16 fastcgi_params.default  </span><br><span class="line">8.-rw-r--r-- 1 root root 2837 Jan  8 14:16 koi-utf  </span><br><span class="line">9.-rw-r--r-- 1 root root 2223 Jan  8 14:16 koi-win  </span><br><span class="line">10.-rw-r--r-- 1 root root 3957 Jan  8 14:16 mime.types  </span><br><span class="line">11.-rw-r--r-- 1 root root 3957 Jan  8 14:16 mime.types.default  </span><br><span class="line">12.-rw-r--r-- 1 root root 2656 Jan  8 14:16 nginx.conf  </span><br><span class="line">13.-rw-r--r-- 1 root root 2656 Jan  8 14:16 nginx.conf.default  </span><br><span class="line">14.-rw-r--r-- 1 root root  636 Jan  8 14:16 scgi_params  </span><br><span class="line">15.-rw-r--r-- 1 root root  636 Jan  8 14:16 scgi_params.default  </span><br><span class="line">16.-rw-r--r-- 1 root root  664 Jan  8 14:16 uwsgi_params  </span><br><span class="line">17.-rw-r--r-- 1 root root  664 Jan  8 14:16 uwsgi_params.default  </span><br><span class="line">18.-rw-r--r-- 1 root root 3610 Jan  8 14:16 win-utf  </span><br><span class="line">19.  </span><br><span class="line">20.[root@yoyo conf]# cp nginx.conf nginx.conf.bak  </span><br><span class="line">21.[root@yoyo conf]# vim nginx.conf</span><br></pre></td></tr></table></figure><p>vim打开后，找到服务端口listen 80这段，输入键盘上i键后编辑，改成81</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.server &#123;  </span><br><span class="line">2.        listen       80;  </span><br><span class="line">3.        server_name  localhost;  </span><br><span class="line">4.  </span><br><span class="line">5.        #charset koi8-r;  </span><br><span class="line">6.  </span><br><span class="line">7.        #access_log  logs&#x2F;host.access.log  main;  </span><br><span class="line">8.  </span><br><span class="line">9.        location &#x2F; &#123;  </span><br><span class="line">10.            root   html;  </span><br><span class="line">11.            index  index.html index.htm;  </span><br><span class="line">12.        &#125;</span><br></pre></td></tr></table></figure><p>编辑完成后按Esc键，输入:wq保存退出</p><p>修改后重新加载下配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@yoyo sbin]# cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;</span><br><span class="line">[root@yoyo sbin]# .&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure><h1 id="9-负载均衡实战"><a href="#9-负载均衡实战" class="headerlink" title="9 负载均衡实战"></a>9 负载均衡实战</h1><h2 id="9-1-调度算法解析"><a href="#9-1-调度算法解析" class="headerlink" title="9.1 调度算法解析"></a>9.1 调度算法解析</h2><ul><li>1、轮询（默认）<br>每个请求按时间顺序逐一分配到不同的后端服务，如果后端某台服务器死机，自动剔除故障系统，使用户访问不受影响。</li><li>2、weight（轮询权值）<br>weight的值越大分配到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。或者仅仅为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。<br>注意:此算法为常用的算法</li><li>3、ip_hash<br>每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的session共享问题。</li><li>4、fair<br>比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间 来分配请求，响应时间短的优先分配。Nginx本身不支持fair，如果需要这种调度算法，则必须安装upstream_fair模块</li><li>5、url_hash<br>按访问的URL的哈希结果来分配请求，使每个URL定向到一台后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身不支持url_hash，如果需要这种调度算法，则必须安装Nginx的hash软件包。</li></ul><h2 id="9-2-实例配置"><a href="#9-2-实例配置" class="headerlink" title="9.2 实例配置"></a>9.2 实例配置</h2><h3 id="9-2-1-轮询权值的负载均衡"><a href="#9-2-1-轮询权值的负载均衡" class="headerlink" title="9.2.1 轮询权值的负载均衡"></a>9.2.1 轮询权值的负载均衡</h3><p>后台服务服务接口</p><p>192.168.1.111:8081/test/t1————》输出1号</p><p>192.168.1.111:8082/test/t1————》输出2号</p><p>配置负载规则nginx.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">1.cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf</span><br><span class="line">2.vi nginx.conf </span><br><span class="line">3.worker_processes  1;  </span><br><span class="line">4.  </span><br><span class="line">5.events &#123;  </span><br><span class="line">6.    worker_connections  1024;  </span><br><span class="line">7.&#125;  </span><br><span class="line">8.  </span><br><span class="line">9.  </span><br><span class="line">10.http &#123;  </span><br><span class="line">11.    include       mime.types;  </span><br><span class="line">12.    default_type  application&#x2F;octet-stream;  </span><br><span class="line">13.  </span><br><span class="line">14.    sendfile        on;  </span><br><span class="line">15.  </span><br><span class="line">16.    keepalive_timeout  65;  </span><br><span class="line">17.      </span><br><span class="line">18.    #接口服务器配置块，可以指定多个upstream XXX,指定权重</span><br><span class="line">19.    upstream mk-name&#123;  </span><br><span class="line">20.        server 192.168.1.111:8081 weight&#x3D;1;  </span><br><span class="line">21.        server 192.168.1.111:8082 weight&#x3D;1;  </span><br><span class="line">22.    &#125;  </span><br><span class="line">23.  </span><br><span class="line">24.    #server块同样可以有多个，每个相当于一个虚拟服务器，端口要不一样  </span><br><span class="line">25.    server &#123;  </span><br><span class="line">26.        #端口  </span><br><span class="line">27.        listen       80;  </span><br><span class="line">28.        #负载器名称，一般指定为公司名称，相当于注释的作用  </span><br><span class="line">29.        server_name  cgh.com;  </span><br><span class="line">30.  </span><br><span class="line">31.        #指定请求路径块，这个地方支持通配符和正则，例如 &#x2F; 可以细化 &#x2F;people&#x2F;*等，同样这个模块也可以有多个  </span><br><span class="line">32.        location &#x2F; &#123;  </span><br><span class="line">33.            root   html;  </span><br><span class="line">34.            index  index.html index.htm;  </span><br><span class="line">35.            #指定对应的接口服务器配置快，http:&#x2F;&#x2F;mk_name中的mk_name一定要是upstream XXX配置的  </span><br><span class="line">36.            proxy_pass http:&#x2F;&#x2F;mk-name;  </span><br><span class="line">37.        &#125;  </span><br><span class="line">38.         </span><br><span class="line">39.        error_page   500 502 503 504  &#x2F;50x.html;  </span><br><span class="line">40.        location &#x3D; &#x2F;50x.html &#123;  </span><br><span class="line">41.            root   html;  </span><br><span class="line">42.        &#125;  </span><br><span class="line">43.  </span><br><span class="line">44.    &#125;  </span><br><span class="line">45.  </span><br><span class="line">46.&#125;</span><br></pre></td></tr></table></figure><p>修改完ngix.conf后重新加载配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure><p>测试请求</p><p><img src="nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.assets/image-20200531135955485.png" alt="image-20200531135955485"></p><p><img src="nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.assets/image-20200531140001403.png" alt="image-20200531140001403"></p><p>结果：因为我们把两个分发接口的权重设置成了一样的（默认都是1），所以这里我们每请求一次都会在1服务器和2服务器之间切换执行</p><p>其他负载均衡规则用法抽空填坑</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前我们搭建网站的时候，把war包放到tomcat下就能运行起来了，为什么部署上线的时候，又用到了nginx呢？&lt;br&gt;nginx可以做多台服务器的负载均衡，当用户非常少的时候，可以用一台服务直接部署web环境，那么当用户达到百万级别，千万级别的时候，就需要增加服务器，多台服务器又如何管理协作的呢？
    
    </summary>
    
    
    
      <category term="nginx" scheme="https://dcghx.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>经验积累————基于代码级别的读写分离</title>
    <link href="https://dcghx.github.io/2020/05/09/ywjy-%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%A0%81%E7%BA%A7%E5%88%AB%E7%9A%84%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <id>https://dcghx.github.io/2020/05/09/ywjy-%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%A0%81%E7%BA%A7%E5%88%AB%E7%9A%84%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-31T06:14:55.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>读写分离要做的事情就是对于一条SQL该选择哪个数据库去执行，至于谁来做选择数据库这件事儿，无非两个，要么中间件帮我们做，要么程序自己做<a id="more"></a>。因此，一般来讲，读写分离有两种实现方式。第一种是依靠中间件（比如：MyCat），也就是说应用程序连接到中间件，中间件帮我们做SQL分离；第二种是应用程序自己去做分离。这里我们选择程序自己来做，主要是利用Spring提供的路由数据源，以及AOP</p><p>然而，应用程序层面去做读写分离最大的弱点（不足之处）在于无法动态增加数据库节点，因为数据源配置都是写在配置中的，新增数据库意味着新加一个数据源，必然改配置，并重启应用。当然，好处就是相对简单。</p><p><img src="ywjy-%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%A0%81%E7%BA%A7%E5%88%AB%E7%9A%84%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.assets/image-20200531140629128.png" alt="image-20200531140629128"></p><h1 id="2-AbstractRoutingDataSource"><a href="#2-AbstractRoutingDataSource" class="headerlink" title="2. AbstractRoutingDataSource"></a>2. AbstractRoutingDataSource</h1><p>基于特定的查找key路由到特定的数据源。它内部维护了一组目标数据源，并且做了路由key与目标数据源之间的映射，提供基于key查找数据源的方法。</p><p><img src="ywjy-%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%A0%81%E7%BA%A7%E5%88%AB%E7%9A%84%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.assets/image-20200531140807774.png" alt="image-20200531140807774"></p><h1 id="3-实践"><a href="#3-实践" class="headerlink" title="3. 实践"></a>3. 实践</h1><h2 id="3-1-MySQL主从复制配置"><a href="#3-1-MySQL主从复制配置" class="headerlink" title="3.1 MySQL主从复制配置"></a>3.1 MySQL主从复制配置</h2><p>自行查阅资料</p><h2 id="3-2-pom配置"><a href="#3-2-pom配置" class="headerlink" title="3.2  pom配置"></a>3.2  pom配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1.&lt;dependencies&gt;  </span><br><span class="line">2.        &lt;dependency&gt;  </span><br><span class="line">3.            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;  </span><br><span class="line">4.            &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;  </span><br><span class="line">5.        &lt;&#x2F;dependency&gt;  </span><br><span class="line">6.        &lt;dependency&gt;  </span><br><span class="line">7.            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;  </span><br><span class="line">8.            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;  </span><br><span class="line">9.            &lt;optional&gt;true&lt;&#x2F;optional&gt;  </span><br><span class="line">10.        &lt;&#x2F;dependency&gt;  </span><br><span class="line">11.  </span><br><span class="line">12.        &lt;dependency&gt;  </span><br><span class="line">13.            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;  </span><br><span class="line">14.            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;  </span><br><span class="line">15.            &lt;scope&gt;test&lt;&#x2F;scope&gt;  </span><br><span class="line">16.        &lt;&#x2F;dependency&gt;  </span><br><span class="line">17.  </span><br><span class="line">18.        &lt;dependency&gt;  </span><br><span class="line">19.            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;  </span><br><span class="line">20.            &lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt;  </span><br><span class="line">21.        &lt;&#x2F;dependency&gt;  </span><br><span class="line">22.  </span><br><span class="line">23.        &lt;dependency&gt;  </span><br><span class="line">24.            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;  </span><br><span class="line">25.            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;  </span><br><span class="line">26.        &lt;&#x2F;dependency&gt;  </span><br><span class="line">27.  </span><br><span class="line">28.        &lt;dependency&gt;  </span><br><span class="line">29.            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;  </span><br><span class="line">30.            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;  </span><br><span class="line">31.        &lt;&#x2F;dependency&gt;  </span><br><span class="line">32.  </span><br><span class="line">33.        &lt;dependency&gt;  </span><br><span class="line">34.            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;  </span><br><span class="line">35.            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;  </span><br><span class="line">36.            &lt;version&gt;1.3.2&lt;&#x2F;version&gt;  </span><br><span class="line">37.        &lt;&#x2F;dependency&gt;  </span><br><span class="line">38.  </span><br><span class="line">39.        &lt;dependency&gt;  </span><br><span class="line">40.            &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;  </span><br><span class="line">41.            &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;  </span><br><span class="line">42.            &lt;version&gt;3.8&lt;&#x2F;version&gt;  </span><br><span class="line">43.        &lt;&#x2F;dependency&gt;  </span><br><span class="line">44.  </span><br><span class="line">45.        &lt;dependency&gt;  </span><br><span class="line">46.            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;  </span><br><span class="line">47.            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;  </span><br><span class="line">48.            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;  </span><br><span class="line">49.        &lt;&#x2F;dependency&gt;  </span><br><span class="line">50.  </span><br><span class="line">51.    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="3-3-数据源配置"><a href="#3-3-数据源配置" class="headerlink" title="3.3 数据源配置"></a>3.3 数据源配置</h2><p>application.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.spring:  </span><br><span class="line">2.  datasource:  </span><br><span class="line">3.      master:  </span><br><span class="line">4.        jdbc-url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;serverTimezone&#x3D;GMT  </span><br><span class="line">5.        username: root  </span><br><span class="line">6.        password: root  </span><br><span class="line">7.        driver-class-name: com.mysql.cj.jdbc.Driver  </span><br><span class="line">8.      slave1:  </span><br><span class="line">9.        jdbc-url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test2?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;serverTimezone&#x3D;GMT  </span><br><span class="line">10.        username: root  </span><br><span class="line">11.        password: root  </span><br><span class="line">12.        driver-class-name: com.mysql.cj.jdbc.Driver  </span><br><span class="line">13.      slave2:  </span><br><span class="line">14.        jdbc-url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test2?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;serverTimezone&#x3D;GMT  </span><br><span class="line">15.        username: root  </span><br><span class="line">16.        password: root  </span><br><span class="line">17.        driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><h2 id="3-3-自定义枚举表示数据源"><a href="#3-3-自定义枚举表示数据源" class="headerlink" title="3.3  自定义枚举表示数据源"></a>3.3  自定义枚举表示数据源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.public enum DBTypeEnum &#123;  </span><br><span class="line">2.    MASTER,SLAVE1,SLAVE2;  </span><br><span class="line">3.&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-多数据源配置"><a href="#3-4-多数据源配置" class="headerlink" title="3.4  多数据源配置"></a>3.4  多数据源配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1.@Configuration  </span><br><span class="line">2.public class DataSourceConfig &#123;  </span><br><span class="line">3.  </span><br><span class="line">4.    @Bean  </span><br><span class="line">5.    @ConfigurationProperties(&quot;spring.datasource.master&quot;)  </span><br><span class="line">6.    public DataSource masterDataSource()&#123;  </span><br><span class="line">7.        return DataSourceBuilder.create().build();  </span><br><span class="line">8.    &#125;  </span><br><span class="line">9.  </span><br><span class="line">10.    @Bean  </span><br><span class="line">11.    @ConfigurationProperties(&quot;spring.datasource.slave1&quot;)  </span><br><span class="line">12.    public DataSource slave1DataSource()&#123;  </span><br><span class="line">13.        return DataSourceBuilder.create().build();  </span><br><span class="line">14.    &#125;  </span><br><span class="line">15.  </span><br><span class="line">16.    @Bean  </span><br><span class="line">17.    @ConfigurationProperties(&quot;spring.datasource.slave2&quot;)  </span><br><span class="line">18.    public DataSource slave2DataSource()&#123;  </span><br><span class="line">19.        return DataSourceBuilder.create().build();  </span><br><span class="line">20.    &#125;  </span><br><span class="line">21.  </span><br><span class="line">22.    @Bean  </span><br><span class="line">23.    public DataSource myRoutingDataSource(@Qualifier(&quot;masterDataSource&quot;)DataSource m, </span><br><span class="line">24.                                          @Qualifier(&quot;slave1DataSource&quot;)DataSource s1,</span><br><span class="line">25.                                          @Qualifier(&quot;slave2DataSource&quot;)DataSource s2)&#123;  </span><br><span class="line">26.        Map targetDataSources &#x3D; new HashMap();  </span><br><span class="line">27.        targetDataSources.put(DBTypeEnum.MASTER,m);  </span><br><span class="line">28.        targetDataSources.put(DBTypeEnum.SLAVE1,s1);  </span><br><span class="line">29.        targetDataSources.put(DBTypeEnum.SLAVE2,s2);  </span><br><span class="line">30.  </span><br><span class="line">31.        MyRoutingDataSource myRoutingDataSource &#x3D; new MyRoutingDataSource();  </span><br><span class="line">32.        myRoutingDataSource.setDefaultTargetDataSource(m);  </span><br><span class="line">33.        myRoutingDataSource.setTargetDataSources(targetDataSources);  </span><br><span class="line">34.        return myRoutingDataSource;  </span><br><span class="line">35.    &#125;  </span><br><span class="line">36.  </span><br><span class="line">37.&#125;</span><br></pre></td></tr></table></figure><p>这里，我们配置了4个数据源，1个master，2两个slave，1个路由数据源。前3个数据源都是为了生成第4个数据源，而且后续我们只用这最后一个路由数据源。</p><h2 id="3-5-mybaties配置"><a href="#3-5-mybaties配置" class="headerlink" title="3.5  mybaties配置"></a>3.5  mybaties配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.@EnableTransactionManagement  </span><br><span class="line">2.@Configuration  </span><br><span class="line">3.@MapperScan(&quot;com.cgh.mapper*&quot;)  </span><br><span class="line">4.public class MyBatisConfig &#123;  </span><br><span class="line">5.  </span><br><span class="line">6.    @Resource(name &#x3D; &quot;myRoutingDataSource&quot;)  </span><br><span class="line">7.    private DataSource myRoutingDataSource;  </span><br><span class="line">8.  </span><br><span class="line">9.   @Bean  </span><br><span class="line">10.   public SqlSessionFactory sqlSessionFactory() throws Exception &#123;  </span><br><span class="line">11.       SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean();  </span><br><span class="line">12.       sqlSessionFactoryBean.setDataSource(myRoutingDataSource);  </span><br><span class="line">13.       sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mapper&#x2F;*.xml&quot;));  </span><br><span class="line">14.       return sqlSessionFactoryBean.getObject();  </span><br><span class="line">15.   &#125;  </span><br><span class="line">16.   @Bean  </span><br><span class="line">17.   public PlatformTransactionManager platformTransactionManager() &#123;  </span><br><span class="line">18.       return new DataSourceTransactionManager(myRoutingDataSource);  </span><br><span class="line">19.   &#125;  </span><br><span class="line">20.  </span><br><span class="line">21.  </span><br><span class="line">22.&#125;</span><br></pre></td></tr></table></figure><p>由于Spring容器中现在有4个数据源，所以我们需要为事务管理器和MyBatis手动指定一个明确的数据源。</p><h2 id="3-6-通过ThreadLocal将数据源设置到每个线程上下文中"><a href="#3-6-通过ThreadLocal将数据源设置到每个线程上下文中" class="headerlink" title="3.6 通过ThreadLocal将数据源设置到每个线程上下文中"></a>3.6 通过ThreadLocal将数据源设置到每个线程上下文中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1.@Slf4j  </span><br><span class="line">2.public class DBContextHolder &#123;  </span><br><span class="line">3.  </span><br><span class="line">4.    public static final ThreadLocal&lt;DBTypeEnum&gt; contextHolder &#x3D; new ThreadLocal&lt;&gt;();  </span><br><span class="line">5.    public static final AtomicInteger counter &#x3D; new AtomicInteger(-1);  </span><br><span class="line">6.  </span><br><span class="line">7.    public static void set(DBTypeEnum dbType)&#123;  </span><br><span class="line">8.        contextHolder.set(dbType);  </span><br><span class="line">9.    &#125;  </span><br><span class="line">10.  </span><br><span class="line">11.    public static DBTypeEnum get()&#123;  </span><br><span class="line">12.        return contextHolder.get();  </span><br><span class="line">13.    &#125;  </span><br><span class="line">14.  </span><br><span class="line">15.    public static void master()&#123;  </span><br><span class="line">16.        set(DBTypeEnum.MASTER);  </span><br><span class="line">17.        log.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;切换到master数据源&#x3D;&#x3D;&#x3D;&#x3D;&quot;);  </span><br><span class="line">18.    &#125;  </span><br><span class="line">19.  </span><br><span class="line">20.    public static void slave()&#123;  </span><br><span class="line">21.        &#x2F;&#x2F;轮询  </span><br><span class="line">22.        int index &#x3D; counter.getAndIncrement() % 2;  </span><br><span class="line">23.        if(index &gt; 9999)&#123;  </span><br><span class="line">24.            counter.set(-1);  </span><br><span class="line">25.        &#125;  </span><br><span class="line">26.        if(index &#x3D;&#x3D; 0)&#123;  </span><br><span class="line">27.            set(DBTypeEnum.SLAVE1);  </span><br><span class="line">28.            log.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;切换到 s1 数据源&#x3D;&#x3D;&#x3D;&#x3D;&quot;);  </span><br><span class="line">29.        &#125;else &#123;  </span><br><span class="line">30.            set(DBTypeEnum.SLAVE2);  </span><br><span class="line">31.            log.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;切换到 s2 数据源&#x3D;&#x3D;&#x3D;&#x3D;&quot;);  </span><br><span class="line">32.        &#125;  </span><br><span class="line">33.    &#125;  </span><br><span class="line">34.&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-获取路由key"><a href="#3-7-获取路由key" class="headerlink" title="3.7  获取路由key"></a>3.7  获取路由key</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.public class MyRoutingDataSource extends AbstractRoutingDataSource &#123;  </span><br><span class="line">2.  </span><br><span class="line">3.    @Nullable  </span><br><span class="line">4.    @Override  </span><br><span class="line">5.    protected Object determineCurrentLookupKey() &#123;  </span><br><span class="line">6.        return DBContextHolder.get();  </span><br><span class="line">7.    &#125;  </span><br><span class="line">8.&#125;</span><br></pre></td></tr></table></figure><h2 id="3-8-创建强制读取主库注解"><a href="#3-8-创建强制读取主库注解" class="headerlink" title="3.8 创建强制读取主库注解"></a>3.8 创建强制读取主库注解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.public @interface Master &#123;  </span><br><span class="line">2.&#125;</span><br></pre></td></tr></table></figure><h2 id="3-9-设置路由切面程序"><a href="#3-9-设置路由切面程序" class="headerlink" title="3.9 设置路由切面程序"></a>3.9 设置路由切面程序</h2><p>我们在切入点配置写成无论读操作还是写操作，只要有Master注解都表示读取主库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1.@Aspect  </span><br><span class="line">2.@Component  </span><br><span class="line">3.public class DataSourceAop &#123;  </span><br><span class="line">4.     </span><br><span class="line">5.   @Pointcut(&quot;!@annotation(com.cgh.config.Master) &quot; +  </span><br><span class="line">6.                       &quot;&amp;&amp; (execution(* com.cgh.service..*.select*(..)) &quot; + </span><br><span class="line">7.                       &quot;|| execution(* com.cgh.service..*.get*(..)))&quot;)  </span><br><span class="line">8.   public void readPointcut() &#123;  </span><br><span class="line">9.   &#125;  </span><br><span class="line">10.     </span><br><span class="line">11.   @Pointcut(&quot;@annotation(com.cgh.config.Master) &quot; +  </span><br><span class="line">12.                       &quot;|| execution(* com.cgh.service..*.insert*(..)) &quot; +  </span><br><span class="line">13.                       &quot;|| execution(* com.cgh.service..*.add*(..)) &quot; +  </span><br><span class="line">14.                       &quot;|| execution(* com.cgh.service..*.update*(..)) &quot; +  </span><br><span class="line">15.                       &quot;|| execution(* com.cgh.service..*.edit*(..)) &quot; +  </span><br><span class="line">16.                       &quot;|| execution(* com.cgh.service..*.delete*(..)) &quot; +  </span><br><span class="line">17.                       &quot;|| execution(* com.cgh.service..*.remove*(..))&quot;)  </span><br><span class="line">18.   public void writePointcut() &#123;  </span><br><span class="line">19.   &#125;  </span><br><span class="line">20.     </span><br><span class="line">21.   @Before(&quot;readPointcut()&quot;)  </span><br><span class="line">22.   public void read() &#123;  </span><br><span class="line">23.       DBContextHolder.slave();  </span><br><span class="line">24.   &#125;  </span><br><span class="line">25.     </span><br><span class="line">26.   @Before(&quot;writePointcut()&quot;)  </span><br><span class="line">27.   public void write() &#123;  </span><br><span class="line">28.       DBContextHolder.master();  </span><br><span class="line">29.   &#125;  </span><br><span class="line">30.     </span><br><span class="line">31.&#125;</span><br></pre></td></tr></table></figure><h2 id="3-10-设置强制读取主库"><a href="#3-10-设置强制读取主库" class="headerlink" title="3.10 设置强制读取主库"></a>3.10 设置强制读取主库</h2><p>有一般情况就有特殊情况，特殊情况是某些情况下我们需要强制读主库，针对这种情况，我们定义一个主键，用该注解标注的就读主库</p><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.@Service  </span><br><span class="line">2.public class PigServiceImpl implements PigService &#123;  </span><br><span class="line">3.  </span><br><span class="line">4.    @Autowired  </span><br><span class="line">5.    private PigMapper pigMapper;  </span><br><span class="line">6.  </span><br><span class="line">7.    @Override  </span><br><span class="line">8.    public void addPig(Pig pig) &#123;  </span><br><span class="line">9.        pigMapper.addPig(pig);  </span><br><span class="line">10.    &#125;  </span><br><span class="line">11.  </span><br><span class="line">12.    @Override  </span><br><span class="line">13.    public List&lt;Pig&gt; getAllPigs() &#123;  </span><br><span class="line">14.        return pigMapper.getAllPigs();  </span><br><span class="line">15.    &#125;  </span><br><span class="line">16.  </span><br><span class="line">17.    @Master  </span><br><span class="line">18.    @Override  </span><br><span class="line">19.    public List&lt;Pig&gt; getAllPigsMaster() &#123;  </span><br><span class="line">20.        return pigMapper.getAllPigs();  </span><br><span class="line">21.    &#125;  </span><br><span class="line">22.&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1. 引言&quot;&gt;&lt;/a&gt;1. 引言&lt;/h1&gt;&lt;p&gt;读写分离要做的事情就是对于一条SQL该选择哪个数据库去执行，至于谁来做选择数据库这件事儿，无非两个，要么中间件帮我们做，要么程序自己做
    
    </summary>
    
    
    
      <category term="经验积累" scheme="https://dcghx.github.io/tags/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>Redis————基础知识</title>
    <link href="https://dcghx.github.io/2020/05/09/redis-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://dcghx.github.io/2020/05/09/redis-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-31T06:41:20.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Redis"><a href="#1-什么是Redis" class="headerlink" title="1. 什么是Redis"></a>1. 什么是Redis</h1><p>redis是一个高性能的key-value数据库，它是完全开源免费的，而且redis是一个NOSQL类型数据库，是为了解决高并发、高扩展，大数据存储等一系列的问题而产生的数据库解决方案，是一个非关系型的数据库<a id="more"></a></p><h1 id="2-Reids的特点"><a href="#2-Reids的特点" class="headerlink" title="2. Reids的特点"></a>2. Reids的特点</h1><p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。</p><p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。</p><p>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h1 id="3-Reids的数据类型"><a href="#3-Reids的数据类型" class="headerlink" title="3. Reids的数据类型"></a>3. Reids的数据类型</h1><p><img src="redis-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20200531142531821.png" alt="image-20200531142531821"></p><p>String：缓存、限流、计数器、分布式锁、分布式Session</p><p>Hash：存储用户信息、用户主页访问量、组合查询</p><p>List：微博关注人时间轴列表、简单队列</p><p>Set：赞、踩、标签、好友关系</p><p>Zset：排行榜</p><h2 id="3-1-string"><a href="#3-1-string" class="headerlink" title="3.1 string"></a>3.1 string</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Autowired  </span><br><span class="line">   private RedisTemplate&lt;String, String&gt; redisTemplate;  </span><br><span class="line">  </span><br><span class="line">   &#x2F;** </span><br><span class="line">    * string 操作 </span><br><span class="line">    * @param key </span><br><span class="line">    * @param value </span><br><span class="line">    * @return </span><br><span class="line">    *&#x2F;  </span><br><span class="line">   @RequestMapping(&quot;&#x2F;string&quot;)  </span><br><span class="line">  public String stringRedis(@RequestParam String key, @RequestParam String value) &#123;  </span><br><span class="line">      &#x2F;&#x2F;添加  </span><br><span class="line">       redisTemplate.opsForValue().set(key, value);  </span><br><span class="line">       &#x2F;&#x2F;添加并设置过期时间  </span><br><span class="line">       redisTemplate.opsForValue().set(&quot;kak&quot;,&quot;4552&quot;,7200, TimeUnit.SECONDS);  </span><br><span class="line">       &#x2F;&#x2F;自增  </span><br><span class="line">       redisTemplate.opsForValue().increment(&quot;user_count&quot;,1);  </span><br><span class="line">       &#x2F;&#x2F;获取重新设置value  </span><br><span class="line">       redisTemplate.opsForValue().getAndSet(&quot;kak&quot;,&quot;hello&quot;);  </span><br><span class="line">       &#x2F;&#x2F;追加到字符串的末尾  </span><br><span class="line">       redisTemplate.opsForValue().append(&quot;kak&quot;,&quot;world&quot;);  </span><br><span class="line">       &#x2F;&#x2F;获取字符长度  </span><br><span class="line">       redisTemplate.opsForValue().size(&quot;kak&quot;);  </span><br><span class="line">  </span><br><span class="line">       return redisTemplate.opsForValue().get(key);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-hash"><a href="#3-2-hash" class="headerlink" title="3.2 hash"></a>3.2 hash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*** </span><br><span class="line"> * hash操作 </span><br><span class="line"> * @return </span><br><span class="line"> *&#x2F;  </span><br><span class="line">@GetMapping(&quot;&#x2F;hash&quot;)  </span><br><span class="line">public Map&lt;Object, Object&gt;  hashRedis()&#123;  </span><br><span class="line">    &#x2F;&#x2F;添加单个  </span><br><span class="line">    redisTemplate.opsForHash().put(&quot;user&quot;,&quot;id&quot;,&quot;001&quot;);  </span><br><span class="line">    &#x2F;&#x2F;点加多个  </span><br><span class="line">    Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();  </span><br><span class="line">    map.put(&quot;name&quot;,&quot;小明&quot;);  </span><br><span class="line">    map.put(&quot;sex&quot;,&quot;男&quot;);  </span><br><span class="line">    map.put(&quot;age&quot;,&quot;20&quot;);  </span><br><span class="line">    redisTemplate.opsForHash().putAll(&quot;user&quot;,map);  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;键集合  </span><br><span class="line">   Set&lt;Object&gt; keys &#x3D;  redisTemplate.opsForHash().keys(&quot;user&quot;);  </span><br><span class="line">    System.out.println(&quot;keys:&quot;+keys);  </span><br><span class="line">   &#x2F;&#x2F;value集合  </span><br><span class="line">    List&lt;Object&gt; values &#x3D;  redisTemplate.opsForHash().values(&quot;user&quot;);  </span><br><span class="line">    System.out.println(&quot;values:&quot;+values);  </span><br><span class="line">    &#x2F;&#x2F;遍历map  </span><br><span class="line">    Cursor&lt;Map.Entry&lt;Object,Object&gt;&gt; entryCursor  &#x3D; redisTemplate.opsForHash().scan(&quot;user&quot;, ScanOptions.NONE);  </span><br><span class="line">    while (entryCursor.hasNext())&#123;  </span><br><span class="line">        Map.Entry&lt;Object,Object&gt; entry &#x3D;entryCursor.next();  </span><br><span class="line">        System.out.println(&quot;键：&quot;+entry.getKey()+&quot;值：&quot;+entry.getValue());  </span><br><span class="line">    &#125;  </span><br><span class="line">   &#x2F;&#x2F;获取整个map  </span><br><span class="line">    return redisTemplate.opsForHash().entries(&quot;user&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-set"><a href="#3-3-set" class="headerlink" title="3.3 set"></a>3.3 set</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String lkl &#x3D; key &#x3D;&#x3D; null ?&quot;tel&quot;:key;  </span><br><span class="line">&#x2F;&#x2F;添加一个或者多个  </span><br><span class="line">String[] ste &#x3D; new String[]&#123;&quot;123&quot;,&quot;456&quot;,&quot;789&quot;,&quot;45&quot;,&quot;6&quot;&#125;;  </span><br><span class="line">redisTemplate.opsForSet().add(lkl,ste);  </span><br><span class="line">&#x2F;&#x2F;移除一个或多个  </span><br><span class="line">ste&#x3D; new String[]&#123;&quot;123&quot;&#125;;  </span><br><span class="line">redisTemplate.opsForSet().remove(lkl,ste);  </span><br><span class="line">&#x2F;&#x2F;遍历  </span><br><span class="line">Cursor&lt;String&gt; cursor &#x3D; redisTemplate.opsForSet().scan(lkl,ScanOptions.NONE);  </span><br><span class="line">while (cursor.hasNext())&#123;  </span><br><span class="line">    System.out.println(&quot;set成员元素：&quot;+cursor.next());  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F;获取所有元素  </span><br><span class="line">return  redisTemplate.opsForSet().members(key);</span><br></pre></td></tr></table></figure><h2 id="3-4-list"><a href="#3-4-list" class="headerlink" title="3.4 list"></a>3.4 list</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;表头插入单个  </span><br><span class="line">redisTemplate.opsForList().leftPush(&quot;left-list&quot;,&quot;java&quot;);  </span><br><span class="line">&#x2F;&#x2F;表头插入多个  </span><br><span class="line">String [] arr &#x3D; new String[]&#123;&quot;js&quot;,&quot;html&quot;,&quot;c#&quot;,&quot;C++&quot;&#125;;  </span><br><span class="line">redisTemplate.opsForList().leftPushAll(&quot;left-list&quot;,arr);  </span><br><span class="line">&#x2F;&#x2F;表尾插入单个  </span><br><span class="line">redisTemplate.opsForList().rightPush(&quot;rught-list&quot;,&quot;java&quot;);  </span><br><span class="line">&#x2F;&#x2F;表尾插入多个  </span><br><span class="line">redisTemplate.opsForList().rightPushAll(&quot;rught-list&quot;,arr);  </span><br><span class="line">&#x2F;&#x2F;设置位置  </span><br><span class="line">redisTemplate.opsForList().set(&quot;rught-list&quot;,0,&quot;第一个&quot;);  </span><br><span class="line">&#x2F;&#x2F;删除:count&gt; 0：删除等于从头到尾移动的值的元素。count &lt;0：删除等于从尾到头移动的值的元素。count &#x3D; 0：删除等于value的所有元素。  </span><br><span class="line">redisTemplate.opsForList().remove(&quot;rught-list&quot;,1,&quot;js&quot;);</span><br><span class="line">&#x2F;&#x2F;应该是获取指定范围的数据</span><br><span class="line">List&lt;String&gt; list &#x3D; redisTemplate.opsForList().range(&quot;left-list&quot;,0,100);</span><br></pre></td></tr></table></figure><h1 id="4-redis相比memcached有哪些优势？"><a href="#4-redis相比memcached有哪些优势？" class="headerlink" title="4.redis相比memcached有哪些优势？"></a>4.redis相比memcached有哪些优势？</h1><p>1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p><p>2) redis的速度比memcached快很多</p><p>3) redis可以持久化其数据</p><h1 id="5-redis适用于的场景"><a href="#5-redis适用于的场景" class="headerlink" title="5. redis适用于的场景"></a>5. redis适用于的场景</h1><ul><li>会话缓存（Session Cache）</li></ul><p>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。</p><ul><li>全页缓存（FPC）</li></ul><p>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。</p><ul><li>队列、排行榜/计数器、发布/订阅</li></ul><h1 id="6-redis的并发竞争问题如何解决"><a href="#6-redis的并发竞争问题如何解决" class="headerlink" title="6. redis的并发竞争问题如何解决?"></a>6. redis的并发竞争问题如何解决?</h1><p>Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：</p><p>1) 客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</p><p>2) 服务器角度，利用.redis的并发竞争问题如何解决?实现锁。</p><p>注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。</p><h1 id="7-是否支持事务"><a href="#7-是否支持事务" class="headerlink" title="7. 是否支持事务"></a>7. 是否支持事务</h1><p>支持</p><h1 id="8-假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#8-假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="8. 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a>8. 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h1><p>使用keys指令可以扫出指定模式的key列表。</p><p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p><p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h1 id="9-使用过Redis做异步队列么，你是怎么用的？"><a href="#9-使用过Redis做异步队列么，你是怎么用的？" class="headerlink" title="9. 使用过Redis做异步队列么，你是怎么用的？"></a>9. 使用过Redis做异步队列么，你是怎么用的？</h1><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p><p>如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。</p><p>如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。</p><p>如果对方追问pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。</p><p>如果对方追问redis如何实现延时队列？</p><p>使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。</p><h1 id="10、Redis如何做持久化的？"><a href="#10、Redis如何做持久化的？" class="headerlink" title="10、Redis如何做持久化的？"></a>10、Redis如何做持久化的？</h1><p>bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。<br>对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。<br>对方追问bgsave的原理是什么？你给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><h1 id="11、Pipeline有什么好处，为什么要用pipeline？"><a href="#11、Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="11、Pipeline有什么好处，为什么要用pipeline？"></a>11、Pipeline有什么好处，为什么要用pipeline？</h1><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p><h1 id="12、Redis的同步机制了解么？"><a href="#12、Redis的同步机制了解么？" class="headerlink" title="12、Redis的同步机制了解么？"></a>12、Redis的同步机制了解么？</h1><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h1 id="13、是否使用过Redis集群，集群的原理是什么？"><a href="#13、是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="13、是否使用过Redis集群，集群的原理是什么？"></a>13、是否使用过Redis集群，集群的原理是什么？</h1><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。<br>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p><h1 id="14-缓存雪崩"><a href="#14-缓存雪崩" class="headerlink" title="14. 缓存雪崩"></a>14. 缓存雪崩</h1><h2 id="14-1-什么是缓存雪崩"><a href="#14-1-什么是缓存雪崩" class="headerlink" title="14.1 什么是缓存雪崩"></a>14.1 什么是缓存雪崩</h2><p>如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩<br>由于原有缓存失效，新缓存未到期间所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机</p><h2 id="14-2-雪崩解决思路"><a href="#14-2-雪崩解决思路" class="headerlink" title="14.2 雪崩解决思路"></a>14.2 雪崩解决思路</h2><ul><li><p>1、加锁排队<br>mutex互斥锁解决，Redis的SETNX去set一个mutex key，当操作返回成功时，再进行加载数据库的操作并回设缓存，否则，就重试整个get缓存的方法</p></li><li><p>2、数据预热<br>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户直接查询事先被预热的缓存数据。可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的key</p></li><li><p>3、双层缓存策略<br>C1为原始缓存，C2为拷贝缓存，C1失效时，可以访问C2，C1缓存失效时间设置为短期，C2设置为长期</p></li><li><p>4、定时更新缓存策略</p><p>实效性要求不高的缓存，容器启动初始化加载，采用定时任务更新或移除缓存</p></li><li><p>5、设置不同的过期时间，让缓存失效的时间点尽量均匀</p></li></ul><h1 id="15、缓存击穿"><a href="#15、缓存击穿" class="headerlink" title="15、缓存击穿"></a>15、缓存击穿</h1><h2 id="15-1-什么是缓存击穿"><a href="#15-1-什么是缓存击穿" class="headerlink" title="15.1 什么是缓存击穿"></a>15.1 什么是缓存击穿</h2><p>在平常高并发的系统中，大量的请求同时查询一个key时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为缓存击穿</p><h2 id="15-2-缓存击穿解决思路"><a href="#15-2-缓存击穿解决思路" class="headerlink" title="15.2 缓存击穿解决思路"></a>15.2 缓存击穿解决思路</h2><p>上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它<br>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存</p><h1 id="16、缓存穿透"><a href="#16、缓存穿透" class="headerlink" title="16、缓存穿透"></a>16、缓存穿透</h1><h2 id="16-1-什么是缓存穿透"><a href="#16-1-什么是缓存穿透" class="headerlink" title="16.1 什么是缓存穿透"></a>16.1 什么是缓存穿透</h2><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到对应key的value，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库</p><h2 id="16-2-缓存穿透解决思路"><a href="#16-2-缓存穿透解决思路" class="headerlink" title="16.2 缓存穿透解决思路"></a>16.2 缓存穿透解决思路</h2><ul><li>1、缓存空值<br>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障）我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过5分钟。通过这个设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库</li><li>2、采用布隆过滤器BloomFilter<br>优势：占用内存空间很小，位存储；性能特别高，使用key的hash判断key存不存在<br>将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力<br>在缓存之前在加一层BloomFilter，在查询的时候先去BloomFilter去查询key是否存在，如果不存在就直接返回，存在再去查询缓存，缓存中没有再去查询数据库</li></ul><h1 id="17、常见缓存模式"><a href="#17、常见缓存模式" class="headerlink" title="17、常见缓存模式"></a>17、常见缓存模式</h1><ul><li>1、Cache Aside<br>应用在查询数据的时候，先从缓存Cache中读取数据，如果缓存中没有，则再从数据库中读取数据，得到数据库的数据之后，将这个数据也放到缓存Cache中<br>如果应用要更新某个数据，也是先去更新数据库中的数据，更新完成之后，则通过指令让缓存Cache中的数据失效</li></ul><p>  *、这里为什么不让更新操作在写完数据库之后，紧接着去把缓存Cache中的数据也修改了呢？<br>  主要是因为这样做的话，就有2个写操作的事件了，担心在并发的情况下会导致脏数据，举个例子：假如同时有2个请求，请求A和请求B，并发的执行。请求A是要去读数据，请求B是要去更新数据。初始状态缓存中是没有数据的，当请求A读到数据之后，准备往回写的时候，此刻，请求B正好要更新数据，更新完了数据库之后，又去把缓存更新了，那请求A再往缓存中写的就是旧数据了，属于脏数据</p><p>  *、那么Cache Aside模式就没有脏数据问题了吗？<br>  在极端情况下也可能会产生脏数据。例如，同时有2个请求，请求A和请求B，并发的执行。请求A是要去读数据，请求B是要去写数据。假如初始状态缓存中没有这个数据，那请求A发现缓存中没有数据，就会去数据库中读数据，读到了数据准备写回缓存中，就在这个时候，请求B是要去写数据的，请求B在写完数据库的数据之后，又去设置了缓存失效。这个时候，请求A由于在数据库中读到了之前的旧数据，开始往缓存中写数据了，此时写进入的就也是旧数据。那么最终就会导致，缓存中的数据与数据库的数据不一致，造成了脏数</p><ul><li>2、Read/Write Through<br>应用要读数据和更新数据都直接访问缓存服务<br>缓存服务同步地将数据更新到数据库<br>出现脏数据的概率较低，但是就强依赖缓存，对缓存服务的稳定性有较大要求<br>3、Write Behind模式<br>应用要读数据和更新数据都直接访问缓存服务 缓存服务异步地将数据更新到数据库（通过异步任务） 速度快，效率会非常高，但是数据的一致性比较差，还可能会有数据的丢失情况，实现逻辑也较为复杂</li></ul><h1 id="18-Redis-数据库内存数据满了，会宕机吗？有内存回收"><a href="#18-Redis-数据库内存数据满了，会宕机吗？有内存回收" class="headerlink" title="18.Redis 数据库内存数据满了，会宕机吗？有内存回收?"></a>18.Redis 数据库内存数据满了，会宕机吗？有内存回收?</h1><p>Redis 数据库内存数据满了，会宕机吗？答案是：不会让他出现存满的情况，在使用Redis的时候我们要配置Redis能使用的最大的内存大小，存到一定容量的时候还有Redis的内存淘汰策略呢，还有LRU算法进行淘汰，等等<br>我们知道Redis是基于内存的key-value数据库，因为系统的内存大小有限，所以我们在使用Redis的时候可以配置Redis能使用的最大的内存大小。<br>通过配置文件配置<br>通过在Redis安装目录下面的redis.conf配置文件中添加以下配置设置内存大小</p><p><img src="redis-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20200531143532978.png" alt="image-20200531143532978"></p><p>redis的配置文件不一定使用的是安装目录下面的redis.conf文件，启动redis服务的时候是可以传一个参数指定redis的配置文件的</p><p>通过命令修改</p><p>Redis支持运行时通过命令动态修改内存大小</p><p><img src="redis-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20200531143546051.png" alt="image-20200531143546051"></p><p>如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存</p><h2 id="18-1-Redis的内存淘汰策略"><a href="#18-1-Redis的内存淘汰策略" class="headerlink" title="18.1.Redis的内存淘汰策略"></a>18.1.Redis的内存淘汰策略</h2><p>既然可以设置Redis最大占用内存大小，那么配置的内存就有用完的时候。那在内存用完的时候，还继续往Redis里面添加数据不就没内存可用了吗？实际上Redis定义了几种策略用来处理这种情况：</p><ul><li>noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）</li><li>allkeys-lru：从所有key中使用LRU算法进行淘汰</li><li>volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰</li><li>allkeys-random：从所有key中随机淘汰数据</li><li>volatile-random：从设置了过期时间的key中随机淘汰</li><li>volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰</li></ul><p>当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noeviction一样返回错误</p><p><img src="redis-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20200531143702097.png" alt="image-20200531143702097"></p><h2 id="18-2-LRU算法"><a href="#18-2-LRU算法" class="headerlink" title="18.2 LRU算法"></a>18.2 LRU算法</h2><p>LRU(Least Recently Used)，即最近最少使用，是一种缓存置换算法。在使用内存作为缓存的时候，缓存的大小一般是固定的。当缓存被占满，这个时候继续往缓存里面添加数据，就需要淘汰一部分老的数据，释放内存空间用来存储新的数据。这个时候就可以使用LRU算法了。其核心思想是：如果一个数据在最近一段时间没有被用到，那么将来被使用到的可能性也很小，所以就可以被淘汰掉。</p><h3 id="18-2-1-LRU在Redis中的实现"><a href="#18-2-1-LRU在Redis中的实现" class="headerlink" title="18.2.1 LRU在Redis中的实现"></a>18.2.1 LRU在Redis中的实现</h3><p>Redis使用的是近似LRU算法，它跟常规的LRU算法还不太一样。近似LRU算法通过随机采样法淘汰数据，每次随机出5（默认）个key，从里面淘汰掉最近最少使用的key。<br>可以通过maxmemory-samples参数修改采样数量：例：maxmemory-samples 10 maxmenory-samples配置的越大，淘汰的结果越接近于严格的LRU算法<br>Redis3.0对近似LRU算法进行了一些优化。新算法会维护一个候选池（大小为16），池中的数据根据访问时间进行排序，第一次随机选取的key都会放入池中，随后每次随机选取的key只有在访问时间小于池中最小的时间才会放入池中，直到候选池被放满。当放满后，如果有新的key需要放入，则将池中最后访问时间最大（最近被访问）的移除。<br>当需要淘汰的时候，则直接从池中选取最近访问时间最小（最久没被访问）的key淘汰掉就行。</p><h2 id="18-3-LFU算法"><a href="#18-3-LFU算法" class="headerlink" title="18.3 LFU算法"></a>18.3 LFU算法</h2><p>LFU算法是Redis4.0里面新加的一种淘汰策略。它的全称是Least Frequently Used，它的核心思想是根据key的最近被访问的频率进行淘汰，很少被访问的优先被淘汰，被访问的多的则被留下来。<br>LFU算法能更好的表示一个key被访问的热度。假如你使用的是LRU算法，一个key很久没有被访问到，只刚刚是偶尔被访问了一次，那么它就被认为是热点数据，不会被淘汰，而有些key将来是很有可能被访问到的则被淘汰了。如果使用LFU算法则不会出现这种情况，因为使用一次并不会使一个key成为热点数据。<br>LFU一共有两种策略：<br>volatile-lfu：在设置了过期时间的key中使用LFU算法淘汰key<br>allkeys-lfu：在所有的key中使用LFU算法淘汰数据<br>设置使用这两种淘汰策略跟前面讲的一样，不过要注意的一点是这两周策略只能在Redis4.0及以上设置，如果在Redis4.0以下设置会报错</p><h1 id="19-如何用-Redis-统计独立用户访问量？"><a href="#19-如何用-Redis-统计独立用户访问量？" class="headerlink" title="19.如何用 Redis 统计独立用户访问量？"></a>19.如何用 Redis 统计独立用户访问量？</h1><h2 id="19-1使用Hash"><a href="#19-1使用Hash" class="headerlink" title="19.1使用Hash"></a>19.1使用Hash</h2><p>哈希是Redis的一种基础数据结构，Redis底层维护的是一个开散列，会把不同的key映射到哈希表上，如果是遇到关键字冲突，那么就会拉出一个链表出来。<br>当一个用户访问的时候，如果用户登陆过，那么我们就使用用户的id，如果用户没有登陆过，那么我们也能够前端页面随机生成一个key用来标识用户，当用户访问的时候，我们可以使用HSET命令，key可以选择URI与对应的日期进行拼凑，field可以使用用户的id或者随机标识，value可以简单设置为1。<br>当我们要统计某一个网站某一天的访问量的时候，就可以直接使用HLEN来得到最终的结果了。</p><p><img src="redis-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20200531143853303.png" alt="image-20200531143853303"></p><p>优点：简单，容易实现，查询也是非常方便，数据准确性非常高。缺点：占用内存过大，。随着key的增多，性能也会下降。小网站还行，拼多多这种数亿PV的网站肯定受不了</p><h2 id="19-2使用Bitset"><a href="#19-2使用Bitset" class="headerlink" title="19.2使用Bitset"></a>19.2使用Bitset</h2><p>我们知道，对于一个32位的int，如果我们只用来记录id，那么只能够记录一个用户，但如果我们转成2进制，每位用来表示一个用户，那么我们就能够一口气表示32个用户，空间节省了32倍！对于有大量数据的场景，如果我们使用bitset，那么，可以节省非常多的内存。对于没有登陆的用户，我们也可以使用哈希算法，把对应的用户标识哈希成一个数字id。bitset非常的节省内存，假设有1亿个用户，也只需要100000000/8/1024/1024约等于12兆内存。</p><p><img src="redis-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20200531143939090.png" alt="image-20200531143939090"></p><p>Redis已经为我们提供了SETBIT的方法，使用起来非常的方便，我们可以看看下面的例子，我们在item页面可以不停地使用SETBIT命令，设置用户已经访问了该页面，也可以使用GETBIT的方法查询某个用户是否访问。最后我们通过BITCOUNT可以统计该网页每天的访问数量。</p><p><img src="redis-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20200531143952830.png" alt="image-20200531143952830"></p><p>优点占用内存更小，查询方便，可以指定查询某个用户，数据可能略有瑕疵，对于非登陆的用户，可能不同的key映射到同一个id，否则需要维护一个非登陆用户的映射，有额外的开销。</p><p>缺点如果用户非常的稀疏，那么占用的内存可能比方法一更大。</p><p><img src="redis-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20200531144005650.png" alt="image-20200531144005650"></p><h2 id="19-3-使用概率算法"><a href="#19-3-使用概率算法" class="headerlink" title="19.3 使用概率算法"></a>19.3 使用概率算法</h2><p>对于拼多多这种多个页面都可能非常多访问量的网站，如果所需要的数量不用那么准确，可以使用概率算法，事实上，我们对一个网站的UV的统计，1亿跟1亿零30万其实是差不多的。在Redis中，已经封装了HyperLogLog算法，他是一种基数评估算法。这种算法的特征，一般都是数据不存具体的值，而是存用来计算概率的一些相关数据。</p><p><img src="redis-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20200531144034270.png" alt="image-20200531144034270"></p><p>当用户访问网站的时候，我们可以使用PFADD命令，设置对应的命令，最后我们只要通过PFCOUNT就能顺利计算出最终的结果，因为这个只是一个概率算法，所以可能存在0.81%的误差。</p><p>优点占用内存极小，对于一个key，只需要12kb。对于拼多多这种超多用户的特别适用。</p><p>缺点查询指定用户的时候，可能会出错，毕竟存的不是具体的数据。总数也存在一定的误差。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;向redis里存入数据和设置缓存时间    </span><br><span class="line">stringRedisTemplate.opsForValue().set(&quot;baike&quot;, &quot;100&quot;, 60 * 10, TimeUnit.SECONDS);  </span><br><span class="line">&#x2F;&#x2F;val做-1操作    </span><br><span class="line">stringRedisTemplate.boundValueOps(&quot;baike&quot;).increment(-1);  </span><br><span class="line">&#x2F;&#x2F;根据key获取缓存中的val    </span><br><span class="line">stringRedisTemplate.opsForValue().get(&quot;baike&quot;)  </span><br><span class="line">&#x2F;&#x2F;val +1    </span><br><span class="line">stringRedisTemplate.boundValueOps(&quot;baike&quot;).increment(1);  </span><br><span class="line">&#x2F;&#x2F;根据key获取过期时间    </span><br><span class="line">stringRedisTemplate.getExpire(&quot;baike&quot;);  </span><br><span class="line">&#x2F;&#x2F;根据key获取过期时间并换算成指定单位    </span><br><span class="line">stringRedisTemplate.getExpire(&quot;baike&quot;,TimeUnit.SECONDS);  </span><br><span class="line">&#x2F;&#x2F;根据key删除缓存    </span><br><span class="line">stringRedisTemplate.delete(&quot;baike&quot;);  </span><br><span class="line">&#x2F;&#x2F;检查key是否存在，返回boolean值    </span><br><span class="line">stringRedisTemplate.hasKey(&quot;baike&quot;);  </span><br><span class="line">&#x2F;&#x2F;向指定key中存放set集合    </span><br><span class="line">stringRedisTemplate.opsForSet().add(&quot;baike&quot;, &quot;1&quot;,&quot;2&quot;,&quot;3&quot;);  </span><br><span class="line">&#x2F;&#x2F;设置过期时间    </span><br><span class="line">stringRedisTemplate.expire(&quot;baike&quot;,1000 , TimeUnit.MILLISECONDS);  </span><br><span class="line">&#x2F;&#x2F;根据key查看集合中是否存在指定数据    </span><br><span class="line">stringRedisTemplate.opsForSet().isMember(&quot;baike&quot;, &quot;1&quot;);  </span><br><span class="line">&#x2F;&#x2F;根据key获取set集合    </span><br><span class="line">stringRedisTemplate.opsForSet().members(&quot;baike&quot;);  </span><br><span class="line">&#x2F;&#x2F;验证有效时间  </span><br><span class="line">Long expire &#x3D; redisTemplate.boundHashOps(&quot;baike&quot;).getExpire();  </span><br><span class="line">System.out.println(&quot;redis有效时间：&quot;+expire+&quot;S&quot;);  </span><br><span class="line">#添加key并设置有效时间，key存在则不做任何处理返回false，添加成功返回true  </span><br><span class="line">boolean b &#x3D; stringRedisTemplate.opsForValue().setIfAbsent(&quot;k1&quot;,null,60, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-什么是Redis&quot;&gt;&lt;a href=&quot;#1-什么是Redis&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是Redis&quot;&gt;&lt;/a&gt;1. 什么是Redis&lt;/h1&gt;&lt;p&gt;redis是一个高性能的key-value数据库，它是完全开源免费的，而且redis是一个NOSQL类型数据库，是为了解决高并发、高扩展，大数据存储等一系列的问题而产生的数据库解决方案，是一个非关系型的数据库
    
    </summary>
    
    
    
      <category term="Redis" scheme="https://dcghx.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis————集群</title>
    <link href="https://dcghx.github.io/2020/05/09/redis-%E9%9B%86%E7%BE%A4/"/>
    <id>https://dcghx.github.io/2020/05/09/redis-%E9%9B%86%E7%BE%A4/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-31T07:02:29.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-主从同步-复制"><a href="#1-主从同步-复制" class="headerlink" title="1.主从同步/复制"></a>1.主从同步/复制<a id="more"></a></h1><p><img src="redis-%E9%9B%86%E7%BE%A4.assets/image-20200531145051011.png" alt="image-20200531145051011"></p><p>通过持久化功能，Redis保证了即使在服务器重启的情况下也不会丢失（或少量丢失）数据，因为持久化会把内存中数据保存到硬盘上，重启会从硬盘上加载数据。 但是由于数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。</p><p>为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。为此， Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。</p><p>在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库(slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。</p><ul><li>主从数据库的配置：</li></ul><p>主数据库不用配置，从数据库的配置文件（redis.conf）中可以加载主数据库的信息，也可以在启动时，使用 redis-server –port 6380 –slaveof 127.0.0.1 6379 命令指明主数据库的 IP 和端口。从数据库一般是只读，可以改为可写，但写入的数据很容易被主同步没，所以还是只读就可以。也可以在运行时使用 slaveof ip port 命令，停止原来的主，切换成刚刚设置的主 slaveof no one会把自己变成主。</p><ul><li>主从复制原理：</li></ul><p><img src="redis-%E9%9B%86%E7%BE%A4.assets/image-20200531145130371.png" alt="image-20200531145130371"></p><p>1) 从数据库连接主数据库，发送SYNC命令； </p><p>2) 主数据库接收到SYNC命令后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； </p><p>3) 主数据库BGSAVE执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令； </p><p>4) 从数据库收到快照文件后丢弃所有旧数据，载入收到的快照； </p><p>5) 主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令； </p><p>6) 从数据库完成对快照的载入，开始接收命令请求，并执行来自主数据库缓冲区的写命令；（从数据库初始化完成）</p><p>7) 主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令（从数据库初始化完成后的操作）</p><p>8) 出现断开重连后，2.8之后的版本会将断线期间的命令传给从数据库，增量复制。</p><p>9) 主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。Redis 的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p><p>优点：</p><ul><li><p>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离；</p></li><li><p>为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成；</p></li><li><p>Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力；</p></li><li><p>Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求；</p></li><li><p>Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据；</p></li></ul><p>缺点：</p><ul><li><p>Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复；</p></li><li><p>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性；</p></li><li><p>如果多个Slave断线了，需要重启的时候，尽量不要在同一时间段进行重启。因为只要Slave启动，就会发送sync请求和主机全量同步，当多个 Slave 重启的时候，可能会导致 Master IO剧增从而宕机。</p></li><li><p>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂；</p></li></ul><h1 id="2-哨兵模式"><a href="#2-哨兵模式" class="headerlink" title="2. 哨兵模式"></a>2. 哨兵模式</h1><p>第一种主从同步/复制的模式，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。</p><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><p><img src="redis-%E9%9B%86%E7%BE%A4.assets/image-20200531145316840.png" alt="image-20200531145316840"></p><p>哨兵模式的作用：</p><ul><li><p>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器；</p></li><li><p>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机；</p></li></ul><p>然而一个哨兵进程对Redis服务器进行监控，也可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式</p><p><img src="redis-%E9%9B%86%E7%BE%A4.assets/image-20200531145337517.png" alt="image-20200531145337517"></p><ul><li>故障切换的过程：</li></ul><p>　　假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。</p><ul><li>哨兵模式的配置：</li></ul><p>配置一主二从和三个哨兵的 Redis 服务器来演示这个过程</p><p><img src="redis-%E9%9B%86%E7%BE%A4.assets/image-20200531145405513.png" alt="image-20200531145405513"></p><ul><li>主从服务器配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.# 使得Redis服务器可以跨网络访问  </span><br><span class="line">2.bind 0.0.0.0  </span><br><span class="line">3.  </span><br><span class="line">4.# 设置密码  </span><br><span class="line">5.requirepass &quot;123456&quot;  </span><br><span class="line">6.  </span><br><span class="line">7.# 以下有关slaveof的配置只是配置从服务器，主服务器不需要配置  </span><br><span class="line">8.# 指定主服务器  </span><br><span class="line">9.slaveof 192.168.11.128 6379  </span><br><span class="line">10.# 主服务器密码  </span><br><span class="line">11.masterauth 123456</span><br></pre></td></tr></table></figure><ul><li>哨兵配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.# 禁止保护模式  </span><br><span class="line">2.protected-mode no  </span><br><span class="line">3.# 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。  </span><br><span class="line">4.sentinel monitor mymaster 192.168.11.128 6379 2  </span><br><span class="line">5.# sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码  </span><br><span class="line">6.# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;  </span><br><span class="line">7.sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure><p>配置3个哨兵，每个哨兵的配置都是一样的。在Redis安装目录下有一个sentinel.conf文件，copy一份进行修改</p><ul><li>启动</li></ul><p>注意启动的顺序。首先是主机（192.168.11.128）的 Redis 服务进程，然后启动从机的 Redis 服务进程，最后启动3个哨兵的服务进程。</p><p>哨兵模式的工作方式：</p><ul><li><p>每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。</p></li><li><p>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）</p></li><li><p>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态</p></li><li><p>当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）</p></li><li><p>在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</p></li><li><p>当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</p></li><li><p>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</p></li></ul><p>优点：</p><ul><li><p>哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。</p></li><li><p>主从可以自动切换，系统更健壮，可用性更高。</p></li></ul><p>缺点：</p><ul><li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li></ul><h1 id="3-Cluster-集群"><a href="#3-Cluster-集群" class="headerlink" title="3.Cluster 集群"></a>3.Cluster 集群</h1><p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，也就是说每台 Redis 节点上存储不同的内容。</p><p>redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。其redis-cluster<a href="http://lib.csdn.net/base/architecture" target="_blank" rel="noopener">架构</a>图如下：</p><p><img src="redis-%E9%9B%86%E7%BE%A4.assets/image-20200531145740017.png" alt="image-20200531145740017"></p><p>其结构特点：</p><ul><li><p>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。</p></li><li><p>节点的fail是通过集群中超过半数的节点检测失效时才生效。</p></li><li><p>客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。   </p></li><li><p>redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value。</p></li><li><p>Redis集群预分好16384个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。</p></li></ul><h2 id="3-1Redis-集群的数据分片"><a href="#3-1Redis-集群的数据分片" class="headerlink" title="3.1Redis 集群的数据分片"></a>3.1Redis 集群的数据分片</h2><p>Redis 集群没有使用一致性hash, 而是引入了 <a href="http://msd.misuland.com/pd/3255817928875967848" target="_blank" rel="noopener">哈希</a>槽的概念.Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:</p><ul><li><p>节点A覆盖0－5460;   </p></li><li><p>节点B覆盖5461－10922;   </p></li><li><p>节点C覆盖10923－16383.</p></li></ul><p>存取数据：</p><p>   如果存入一个值，按照redis cluster哈希槽的<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">算法</a>： CRC16(‘key’)384 = 6782。 那么就会把这个key 的存储分配到 B 上了。同样，当我连接(A,B,C)任何一个节点想获取’key’这个key时，也会这样的算法，然后内部跳转到B节点上获取数据 </p><p> 新增一个主节点：</p><p>   新增一个节点D，redis cluster的这种做法是从各个节点的前面各拿取一部分slot到D上，我会在接下来的实践中实验。大致就会变成这样：</p><ul><li><p>节点A覆盖1365-5460  </p></li><li><p>节点B覆盖6827-10922 </p></li><li><p>节点C覆盖12288-16383  </p></li><li><p>节点D覆盖0-1364,5461-6826,10923-12287</p></li></ul><p>同样删除一个节点也是类似，移动完成后就可以删除这个节点了。</p><p>这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我想移除节点A,需要将A中的槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p><h2 id="3-2Redis-Cluster主从模式"><a href="#3-2Redis-Cluster主从模式" class="headerlink" title="3.2Redis Cluster主从模式"></a>3.2Redis Cluster主从模式</h2><p> redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。</p><p>上面那个例子里, 集群有ABC三个主节点, 如果这3个节点都没有加入从节点，如果B挂掉了，我们就无法访问整个集群了。A和C的slot（哈希槽）也无法访问。</p><p>所以我们在集群建立的时候，一定要为每个主节点都添加了从节点, 比如像这样, 集群包含主节点A、B、C, 以及从节点A1、B1、C1, 那么即使B挂掉系统也可以继续正确工作。</p><p>B1节点替代了B节点，所以Redis集群将会选择B1节点作为新的主节点，集群将会继续正确地提供服务。 当B重新开启后，它就会变成B1的从节点。</p><p>不过需要注意，如果节点B和B1同时挂了，Redis集群就无法继续正确地提供服务了。</p><h2 id="3-3Redis-一致性保证"><a href="#3-3Redis-一致性保证" class="headerlink" title="3.3Redis 一致性保证"></a>3.3Redis 一致性保证</h2><p>Redis 并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作.</p><p>第一个原因是因为集群是用了异步复制. 写操作过程:</p><ul><li><p>客户端向主节点B写入一条命令.</p></li><li><p>主节点B向客户端回复命令状态.</p></li><li><p>主节点将写操作复制给他得从节点 B1, B2 和 B3.</p></li></ul><p>主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。</p><p>举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .</p><p>Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.</p><p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-主从同步-复制&quot;&gt;&lt;a href=&quot;#1-主从同步-复制&quot; class=&quot;headerlink&quot; title=&quot;1.主从同步/复制&quot;&gt;&lt;/a&gt;1.主从同步/复制
    
    </summary>
    
    
    
      <category term="Redis" scheme="https://dcghx.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis————发布订阅</title>
    <link href="https://dcghx.github.io/2020/05/09/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"/>
    <id>https://dcghx.github.io/2020/05/09/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-31T07:23:04.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-redis实现消息队列"><a href="#1-redis实现消息队列" class="headerlink" title="1.redis实现消息队列"></a>1.redis实现消息队列</h1><p>redis的列表类型天生支持用作消息队列。(类似于MQ的队列模型–任何时候都可以消费，一条消息只能消费一次)<a id="more"></a></p><p>在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。</p><p>  从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。相信对于有良好数据结构基础的开发者而言，这一点并不难理解。(类似于java的ArrayList)</p><p>redis对list的操作命令中。L表示从左边(头部)开始插与弹出，R表示从右边(尾部)开始插与弹出。</p><h2 id="1-1-redis中简单的操作list，简单的在命令行操作实现队列"><a href="#1-1-redis中简单的操作list，简单的在命令行操作实现队列" class="headerlink" title="1.1 redis中简单的操作list，简单的在命令行操作实现队列"></a>1.1 redis中简单的操作list，简单的在命令行操作实现队列</h2><h3 id="1-1-1-从左向右插入，从右向左弹出"><a href="#1-1-1-从左向右插入，从右向左弹出" class="headerlink" title="1.1.1 从左向右插入，从右向左弹出:"></a>1.1.1 从左向右插入，从右向左弹出:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist a b c d  </span><br><span class="line">(integer) 4  </span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1  </span><br><span class="line">1) &quot;d&quot;  </span><br><span class="line">2) &quot;c&quot;  </span><br><span class="line">3) &quot;b&quot;  </span><br><span class="line">4) &quot;a&quot;  </span><br><span class="line">127.0.0.1:6379&gt; rpop mylist  </span><br><span class="line">&quot;a&quot;  </span><br><span class="line">127.0.0.1:6379&gt; rpop mylist  </span><br><span class="line">&quot;b&quot;</span><br></pre></td></tr></table></figure><p>执行完  lpush mylist a b c d 之后数据结构如下:(满足先进先出的队列模式)</p><p><img src="redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.assets/image-20200531150800323.png" alt="image-20200531150800323"></p><p>执行完第一次:rpop mylist之后数据结构如下:</p><p><img src="redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.assets/image-20200531150809982.png" alt="image-20200531150809982"></p><h3 id="1-1-2-从右向左插入，从左向右弹出"><a href="#1-1-2-从右向左插入，从左向右弹出" class="headerlink" title="1.1.2 从右向左插入，从左向右弹出:"></a>1.1.2 从右向左插入，从左向右弹出:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush mylist2 a b c d  </span><br><span class="line">(integer) 4  </span><br><span class="line">127.0.0.1:6379&gt; lrange mylist2 0 -1  </span><br><span class="line">1) &quot;a&quot;  </span><br><span class="line">2) &quot;b&quot;  </span><br><span class="line">3) &quot;c&quot;  </span><br><span class="line">4) &quot;d&quot;  </span><br><span class="line">127.0.0.1:6379&gt; lpop mylist2  </span><br><span class="line">&quot;a&quot;  </span><br><span class="line">127.0.0.1:6379&gt; lpop mylist2  </span><br><span class="line">&quot;b&quot;</span><br></pre></td></tr></table></figure><p>执行完:rpush mylist2 a b c d之后的数据结构如下</p><p><img src="redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.assets/image-20200531150854070.png" alt="image-20200531150854070"></p><p>第一次执行完  lpop mylist2 之后数据结构如下:(满足先进先出的队列模式)</p><p><img src="redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.assets/image-20200531150908974.png" alt="image-20200531150908974"></p><h2 id="1-2-JAVA程序实现消息队列"><a href="#1-2-JAVA程序实现消息队列" class="headerlink" title="1.2 JAVA程序实现消息队列"></a>1.2 JAVA程序实现消息队列</h2><ul><li>redis.properties</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.redis.url&#x3D;localhost  </span><br><span class="line">2.redis.port&#x3D;6379  </span><br><span class="line">3.redis.maxIdle&#x3D;30  </span><br><span class="line">4.redis.minIdle&#x3D;10  </span><br><span class="line">5.redis.maxTotal&#x3D;100  </span><br><span class="line">6.redis.maxWait&#x3D;10000</span><br></pre></td></tr></table></figure><ul><li>获取连接的工具类:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class JedisPoolUtils &#123;  </span><br><span class="line">    private static JedisPool pool &#x3D; null;  </span><br><span class="line">    static &#123;  </span><br><span class="line">        &#x2F;&#x2F;加载配置文件  </span><br><span class="line">InputStream in &#x3D; JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;redis.properties&quot;);  </span><br><span class="line">        Properties pro &#x3D; new Properties();  </span><br><span class="line">        try &#123;  </span><br><span class="line">            pro.load(in);  </span><br><span class="line">        &#125; catch (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;获得池子对象  </span><br><span class="line">        JedisPoolConfig poolConfig &#x3D; new JedisPoolConfig();  </span><br><span class="line">        poolConfig.setMaxIdle(Integer.parseInt(pro.get(&quot;redis.maxIdle&quot;).toString()));&#x2F;&#x2F;最大闲置个数  </span><br><span class="line">        poolConfig.setMaxWaitMillis(Integer.parseInt(pro.get(&quot;redis.maxWait&quot;).toString()));&#x2F;&#x2F;最大闲置个数  </span><br><span class="line">        poolConfig.setMinIdle(Integer.parseInt(pro.get(&quot;redis.minIdle&quot;).toString()));&#x2F;&#x2F;最小闲置个数  </span><br><span class="line">        poolConfig.setMaxTotal(Integer.parseInt(pro.get(&quot;redis.maxTotal&quot;).toString()));&#x2F;&#x2F;最大连接数  </span><br><span class="line">        pool &#x3D; new JedisPool(poolConfig, pro.getProperty(&quot;redis.url&quot;), Integer.parseInt(pro.get(&quot;redis.port&quot;).toString()));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;获得jedis资源的方法  </span><br><span class="line">    public static Jedis getJedis() &#123;  </span><br><span class="line">        return pool.getResource();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Jedis jedis &#x3D; getJedis();  </span><br><span class="line">        System.out.println(jedis);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消息生产者:(开启5个线程生产消息)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class MessageProducer extends Thread &#123;  </span><br><span class="line">    public static final String MESSAGE_KEY &#x3D; &quot;message:queue&quot;;  </span><br><span class="line">    private volatile int count;  </span><br><span class="line">  </span><br><span class="line">    public void putMessage(String message) &#123;  </span><br><span class="line">        Jedis jedis &#x3D; JedisPoolUtils.getJedis();  </span><br><span class="line">        Long size &#x3D; jedis.lpush(MESSAGE_KEY, message);  </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; put message,size&#x3D;&quot; + size + &quot;,count&#x3D;&quot; + count);  </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public synchronized void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;  </span><br><span class="line">            putMessage(&quot;message&quot; + count);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        MessageProducer messageProducer &#x3D; new MessageProducer();  </span><br><span class="line">        Thread t1 &#x3D; new Thread(messageProducer, &quot;thread1&quot;);  </span><br><span class="line">        Thread t2 &#x3D; new Thread(messageProducer, &quot;thread2&quot;);  </span><br><span class="line">        Thread t3 &#x3D; new Thread(messageProducer, &quot;thread3&quot;);  </span><br><span class="line">        Thread t4 &#x3D; new Thread(messageProducer, &quot;thread4&quot;);  </span><br><span class="line">        Thread t5 &#x3D; new Thread(messageProducer, &quot;thread5&quot;);  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">        t3.start();  </span><br><span class="line">        t4.start();  </span><br><span class="line">        t5.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果：(证明了redis是单线程操作，只能一个一个操作)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.thread1 put message,size&#x3D;1,count&#x3D;0  </span><br><span class="line">2.thread1 put message,size&#x3D;2,count&#x3D;1  </span><br><span class="line">3.thread1 put message,size&#x3D;3,count&#x3D;2  </span><br><span class="line">4.thread1 put message,size&#x3D;4,count&#x3D;3  </span><br><span class="line">5.thread1 put message,size&#x3D;5,count&#x3D;4  </span><br><span class="line">6.thread3 put message,size&#x3D;6,count&#x3D;5  </span><br><span class="line">7.thread3 put message,size&#x3D;7,count&#x3D;6  </span><br><span class="line">8.thread3 put message,size&#x3D;8,count&#x3D;7  </span><br><span class="line">9.thread3 put message,size&#x3D;9,count&#x3D;8  </span><br><span class="line">10.thread3 put message,size&#x3D;10,count&#x3D;9  </span><br><span class="line">11.thread4 put message,size&#x3D;11,count&#x3D;10  </span><br><span class="line">12.thread4 put message,size&#x3D;12,count&#x3D;11  </span><br><span class="line">13.thread4 put message,size&#x3D;13,count&#x3D;12  </span><br><span class="line">14.thread4 put message,size&#x3D;14,count&#x3D;13  </span><br><span class="line">15.thread4 put message,size&#x3D;15,count&#x3D;14  </span><br><span class="line">16.thread5 put message,size&#x3D;16,count&#x3D;15  </span><br><span class="line">17.thread5 put message,size&#x3D;17,count&#x3D;16  </span><br><span class="line">18.thread5 put message,size&#x3D;18,count&#x3D;17  </span><br><span class="line">19.thread5 put message,size&#x3D;19,count&#x3D;18  </span><br><span class="line">20.thread5 put message,size&#x3D;20,count&#x3D;19  </span><br><span class="line">21.thread2 put message,size&#x3D;21,count&#x3D;20  </span><br><span class="line">22.thread2 put message,size&#x3D;22,count&#x3D;21  </span><br><span class="line">23.thread2 put message,size&#x3D;23,count&#x3D;22  </span><br><span class="line">24.thread2 put message,size&#x3D;24,count&#x3D;23  </span><br><span class="line">25.thread2 put message,size&#x3D;25,count&#x3D;24</span><br></pre></td></tr></table></figure><ul><li>redis后台查看:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.127.0.0.1:6379&gt; lrange message:queue 0 -1  </span><br><span class="line">2. 1) &quot;message24&quot;  </span><br><span class="line">3. 2) &quot;message23&quot;  </span><br><span class="line">4. 3) &quot;message22&quot;  </span><br><span class="line">5. 4) &quot;message21&quot;  </span><br><span class="line">6. 5) &quot;message20&quot;  </span><br><span class="line">7. 6) &quot;message19&quot;  </span><br><span class="line">8. 7) &quot;message18&quot;  </span><br><span class="line">9. 8) &quot;message17&quot;  </span><br><span class="line">10. 9) &quot;message16&quot;  </span><br><span class="line">11.10) &quot;message15&quot;  </span><br><span class="line">12.11) &quot;message14&quot;  </span><br><span class="line">13.12) &quot;message13&quot;  </span><br><span class="line">14.13) &quot;message12&quot;  </span><br><span class="line">15.14)......</span><br></pre></td></tr></table></figure><ul><li>消息消费者:(开启两个线程消费消息)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MessageConsumer implements Runnable &#123;  </span><br><span class="line">    public static final String MESSAGE_KEY &#x3D; &quot;message:queue&quot;;  </span><br><span class="line">    private volatile int count;  </span><br><span class="line">  </span><br><span class="line">    public void consumerMessage() &#123;  </span><br><span class="line">        Jedis jedis &#x3D; JedisPoolUtils.getJedis();  </span><br><span class="line">        String message &#x3D; jedis.rpop(MESSAGE_KEY);  </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; consumer message,message&#x3D;&quot; + message + &quot;,count&#x3D;&quot; + count);  </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            consumerMessage();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        MessageConsumer messageConsumer &#x3D; new MessageConsumer();  </span><br><span class="line">        Thread t1 &#x3D; new Thread(messageConsumer, &quot;thread6&quot;);  </span><br><span class="line">        Thread t2 &#x3D; new Thread(messageConsumer, &quot;thread7&quot;);  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果:(满足先进先出的规则)–虽然消息已经消费完了，但是仍然在不停的rpop，所以造成浪费</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.thread6 consumer message,message&#x3D;message0,count&#x3D;0  </span><br><span class="line">2.thread6 consumer message,message&#x3D;message1,count&#x3D;1  </span><br><span class="line">3.thread6 consumer message,message&#x3D;message2,count&#x3D;2  </span><br><span class="line">4......  </span><br><span class="line">5.thread6 consumer message,message&#x3D;null,count&#x3D;25  </span><br><span class="line">6.thread7 consumer message,message&#x3D;null,count&#x3D;26  </span><br><span class="line">7.thread6 consumer message,message&#x3D;null,count&#x3D;27  </span><br><span class="line">8.....</span><br></pre></td></tr></table></figure><p>但上述例子中消息消费者有一个问题存在，即需要不停的调用rpop方法查看List中是否有待处理消息。每调用一次都会发起一次连接，这会造成不必要的浪费。也许你会使用Thread.sleep()等方法让消费者线程隔一段时间再消费，但这样做有两个问题：</p><ul><li><p>如果生产者速度大于消费者消费速度，消息队列长度会一直增大，时间久了会占用大量内存空间。</p></li><li><p>如果睡眠时间过长，这样不能处理一些时效性的消息，睡眠时间过短，也会在连接上造成比较大的开销。</p></li></ul><h2 id="1-3-brpop和blpop实现阻塞读取-重要"><a href="#1-3-brpop和blpop实现阻塞读取-重要" class="headerlink" title="1.3 brpop和blpop实现阻塞读取(重要)"></a>1.3 brpop和blpop实现阻塞读取(重要)</h2><p>也就是上面的操作需要一直调用rpop命令或者lpop命令才可以实现不停的监听且消费消息。为了解决这一问题，redis提供了阻塞命令 brpop和blpop。下面以brpop命名为例进行试验:</p><p>　　brpop命令可以接收多个键，其完整的命令格式为 BRPOP key [key …] timeout,如:brpop key1 0。意义是同时检测多个键，如果所有键都没有元素则阻塞，如果其中一个有元素则从该键中弹出该元素(会按照key的顺序进行读取，可以实现具有优先级的队列)。例如下面试验:</p><p>开启两个客户端，第一个客户端中采用brpop阻塞读取两个键:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 127.0.0.1:6379&gt; brpop mylist1 mylist2 0</span><br></pre></td></tr></table></figure><p>第二个客户端增加mylist1 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 127.0.0.1:6379&gt; lpush mylist1 1 2 </span><br><span class="line">2. (integer) 2</span><br></pre></td></tr></table></figure><p>则在第一个客户端显示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 127.0.0.1:6379&gt; brpop mylist1 mylist2 0 </span><br><span class="line">2. 1) &quot;mylist1&quot; </span><br><span class="line">3. 2) &quot;1&quot; </span><br><span class="line">4. (56.31s)</span><br></pre></td></tr></table></figure><p><strong><em>\</em>也就是brpop会阻塞队列，并且每次也是弹出一个消息，如果没有消息会阻塞。**</strong></p><p>如果多个键都有元素则按照从左到右读取第一个键中的一个元素，例如我们现在queue1和queue2各自添加一个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.127.0.0.1:6379&gt; lpush queue1 1 2  </span><br><span class="line">2.(integer) 2  </span><br><span class="line">3.127.0.0.1:6379&gt; lpush queue2 3 4  </span><br><span class="line">4.(integer) 2</span><br></pre></td></tr></table></figure><p>然后执行brpop命令:(会返回读取的key和value，第一个是返回的key，第二个是value)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.127.0.0.1:6379&gt; brpop queue1 queue2 2  </span><br><span class="line">2.1) &quot;queue1&quot;  </span><br><span class="line">3.2) &quot;1&quot;</span><br></pre></td></tr></table></figure><p>借此特性可以实现区分优先级的任务队列。也就是brpop会按照key的顺序依次读取一个数据。</p><p>改造上面代码实现阻塞读取:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.public class MessageConsumer implements Runnable &#123;  </span><br><span class="line">2.    public static final String MESSAGE_KEY &#x3D; &quot;message:queue&quot;;  </span><br><span class="line">3.    private volatile int count;  </span><br><span class="line">4.    private Jedis jedis &#x3D; JedisPoolUtils.getJedis();  </span><br><span class="line">5.  </span><br><span class="line">6.    public void consumerMessage() &#123;  </span><br><span class="line">7.        &#x2F;&#x2F;0是timeout,返回的是一个集合，第一个是消息的key，第二个是消息的内容  </span><br><span class="line">8.        List&lt;String&gt; brpop &#x3D; jedis.brpop(0, MESSAGE_KEY);  </span><br><span class="line">9.        System.out.println(brpop);  </span><br><span class="line">10.    &#125;  </span><br><span class="line">11.  </span><br><span class="line">12.    @Override  </span><br><span class="line">13.    public void run() &#123;  </span><br><span class="line">14.        while (true) &#123;  &#x2F;&#x2F;这个地方要循环了</span><br><span class="line">15.            consumerMessage();  </span><br><span class="line">16.        &#125;  </span><br><span class="line">17.    &#125;  </span><br><span class="line">18.  </span><br><span class="line">19.    public static void main(String[] args) &#123;  </span><br><span class="line">20.        MessageConsumer messageConsumer &#x3D; new MessageConsumer();  </span><br><span class="line">21.        Thread t1 &#x3D; new Thread(messageConsumer, &quot;thread6&quot;);  </span><br><span class="line">22.        Thread t2 &#x3D; new Thread(messageConsumer, &quot;thread7&quot;);  </span><br><span class="line">23.        t1.start();  </span><br><span class="line">24.        t2.start();  </span><br><span class="line">25.    &#125;  </span><br><span class="line">26.&#125;</span><br></pre></td></tr></table></figure><p>然后可以运行Customer，清空控制台，可以看到程序没有任何输出，阻塞在了brpop这儿。然后在打开Redis的客户端，输入指令client list，可以查看当前的连接个数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.[message:queue, message0]  </span><br><span class="line">2.[message:queue, message1]  </span><br><span class="line">3.[message:queue, message2]  </span><br><span class="line">4.[message:queue, message3]  </span><br><span class="line">5.[message:queue, message4]  </span><br><span class="line">6.[message:queue, message5]  </span><br><span class="line">7.[message:queue, message6]  </span><br><span class="line">8.[message:queue, message7]  </span><br><span class="line">9.[message:queue, message8]  </span><br><span class="line">10.[message:queue, message9]  </span><br><span class="line">11.[message:queue, message10]  </span><br><span class="line">12.[message:queue, message11]  </span><br><span class="line">13.[message:queue, message12]  </span><br><span class="line">14.[message:queue, message13]  </span><br><span class="line">15.[message:queue, message14]  </span><br><span class="line">16.[message:queue, message15]  </span><br><span class="line">17.[message:queue, message16]  </span><br><span class="line">18.[message:queue, message17]  </span><br><span class="line">19.[message:queue, message18]  </span><br><span class="line">20.[message:queue, message19]  </span><br><span class="line">21.[message:queue, message20]  </span><br><span class="line">22.[message:queue, message21]  </span><br><span class="line">23.[message:queue, message22]  </span><br><span class="line">24.[message:queue, message23]  </span><br><span class="line">25.[message:queue, message24]</span><br></pre></td></tr></table></figure><h1 id="2-发布-订阅模式"><a href="#2-发布-订阅模式" class="headerlink" title="2.发布/订阅模式"></a>2.发布/订阅模式</h1><h2 id="2-1客户端发布-订阅"><a href="#2-1客户端发布-订阅" class="headerlink" title="2.1客户端发布/订阅"></a>2.1客户端发布/订阅</h2><h3 id="2-1-1-普通的发布-订阅"><a href="#2-1-1-普通的发布-订阅" class="headerlink" title="2.1.1 普通的发布/订阅"></a>2.1.1 普通的发布/订阅</h3><p>除了实现任务队列外，redis还提供了一组命令可以让开发者实现”发布/订阅”(publish/subscribe)模式。”发布/订阅”模式同样可以实现进程间的消息传递，其原理如下:</p><p>“发布/订阅”模式包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或者多个频道(channel),而发布者可以向指定的频道(channel)发送消息，所有订阅此频道的订阅者都会收到此消息。</p><p>1) 发布消息</p><p>发布者发布消息的命令是publish,用法是 publish channel message，如向 channel1.1说一声hi</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.127.0.0.1:6379&gt; publish channel:1 hi  </span><br><span class="line">2.(integer) 0</span><br></pre></td></tr></table></figure><p>这样消息就发出去了。返回值表示接收这条消息的订阅者数量。发出去的消息不会被持久化，也就是有客户端订阅channel:1后只能接收到后续发布到该频道的消息，之前的就接收不到了。</p><p>2) 订阅频道</p><p>订阅频道的命令是 subscribe，可以同时订阅多个频道，用法是 subscribe channel1 [channel2 …],例如新开一个客户端订阅上面频道:(不会收到消息，因为不会收到订阅之前就发布到该频道的消息)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.127.0.0.1:6379&gt; subscribe channel:1  </span><br><span class="line">2.Reading messages... (press Ctrl-C to quit)  </span><br><span class="line">3.1) &quot;subscribe&quot;  </span><br><span class="line">4.2) &quot;channel:1&quot;  </span><br><span class="line">5.3) (integer) 1</span><br></pre></td></tr></table></figure><p>执行上面命令客户端会进入订阅状态，处于此状态下客户端不能使用除subscribe、unsubscribe、psubscribe和punsubscribe这四个属于”发布/订阅”之外的命令，否则会报错。</p><p>进入订阅状态后客户端可能收到3种类型的回复。每种类型的回复都包含3个值，第一个值是消息的类型，根据消类型的不同，第二个和第三个参数的含义可能不同。</p><p>消息类型的取值可能是以下3个:</p><ul><li><p>subscribe。表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个是当前客户端订阅的频道数量。</p></li><li><p>message。表示接收到的消息，第二个值表示产生消息的频道名称，第三个值是消息的内容。</p></li><li><p>unsubscribe。表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为0时客户端会退出订阅状态，之后就可以执行其他非”发布/订阅”模式的命令了。</p></li></ul><p>3) 第一个客户端重新向channel:1发送一条消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.127.0.0.1:6379&gt; publish channel:1 hi  </span><br><span class="line">2.(integer) 1</span><br></pre></td></tr></table></figure><p>返回值表示订阅此频道的数量</p><p>上面订阅的客户端:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.127.0.0.1:6379&gt; subscribe channel:1  </span><br><span class="line">2.Reading messages... (press Ctrl-C to quit)  </span><br><span class="line">3.1) &quot;subscribe&quot;  </span><br><span class="line">4.2) &quot;channel:1&quot;  </span><br><span class="line">5.3) (integer) 1  </span><br><span class="line">6.1) &quot;message&quot;  </span><br><span class="line">7.2) &quot;channel:1&quot;  </span><br><span class="line">8.3) &quot;hi&quot;</span><br></pre></td></tr></table></figure><p>红字部分表示成功的收到消息(依次是消息类型，频道，消息内容)</p><h3 id="2-1-2-按照规则发布-订阅"><a href="#2-1-2-按照规则发布-订阅" class="headerlink" title="2.1.2 按照规则发布/订阅"></a>2.1.2 按照规则发布/订阅</h3><p>除了可以使用subscribe命令订阅指定的频道外，还可以使用psubscribe命令订阅指定的规则。规则支持通配符格式。命令格式为   psubscribe pattern [pattern …]订阅多个模式的频道。</p><p>通配符中?表示1个占位符，<em>表示任意个占位符(包括0)，?</em>表示1个以上占位符。</p><p>1) 订阅者订阅三个通配符频道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; psubscribe c? b* d?*  </span><br><span class="line">Reading messages... (press Ctrl-C to quit)  </span><br><span class="line">1) &quot;psubscribe&quot;  </span><br><span class="line">2) &quot;c?&quot;  </span><br><span class="line">3) (integer) 1  </span><br><span class="line">1) &quot;psubscribe&quot;  </span><br><span class="line">2) &quot;b*&quot;  </span><br><span class="line">3) (integer) 2  </span><br><span class="line">1) &quot;psubscribe&quot;  </span><br><span class="line">2) &quot;d?*&quot;  </span><br><span class="line">3) (integer) 3</span><br></pre></td></tr></table></figure><p>2) 新开一个客户端发送到指定频道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\liqiang&gt;redis-cli  </span><br><span class="line">127.0.0.1:6379&gt; publish c m1  </span><br><span class="line">(integer) 0  </span><br><span class="line">127.0.0.1:6379&gt; publish c1 m1  </span><br><span class="line">(integer) 1  </span><br><span class="line">127.0.0.1:6379&gt; publish c11 m1  </span><br><span class="line">(integer) 0  </span><br><span class="line">127.0.0.1:6379&gt; publish b m1  </span><br><span class="line">(integer) 1  </span><br><span class="line">127.0.0.1:6379&gt; publish b1 m1  </span><br><span class="line">(integer) 1  </span><br><span class="line">127.0.0.1:6379&gt; publish b11 m1  </span><br><span class="line">(integer) 1  </span><br><span class="line">127.0.0.1:6379&gt; publish d m1  </span><br><span class="line">(integer) 0  </span><br><span class="line">127.0.0.1:6379&gt; publish d1 m1  </span><br><span class="line">(integer) 1  </span><br><span class="line">127.0.0.1:6379&gt; publish d11 m1  </span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>上面返回值为1表示被订阅者所接受，可以匹配上面的通配符。</p><p>3) 订阅者客户端:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; psubscribe c? b* d?*  </span><br><span class="line">Reading messages... (press Ctrl-C to quit)  </span><br><span class="line">1) &quot;psubscribe&quot;  </span><br><span class="line">2) &quot;c?&quot;  </span><br><span class="line">3) (integer) 1  </span><br><span class="line">1) &quot;psubscribe&quot;  </span><br><span class="line">2) &quot;b*&quot;  </span><br><span class="line">3) (integer) 2  </span><br><span class="line">1) &quot;psubscribe&quot;  </span><br><span class="line">2) &quot;d?*&quot;  </span><br><span class="line">3) (integer) 3  </span><br><span class="line">1) &quot;pmessage&quot;  </span><br><span class="line">2) &quot;c?&quot;  </span><br><span class="line">3) &quot;c1&quot;  </span><br><span class="line">4) &quot;m1&quot;  </span><br><span class="line">1) &quot;pmessage&quot;  </span><br><span class="line">2) &quot;b*&quot;  </span><br><span class="line">3) &quot;b&quot;  </span><br><span class="line">4) &quot;m1&quot;  </span><br><span class="line">1) &quot;pmessage&quot;  </span><br><span class="line">2) &quot;b*&quot;  </span><br><span class="line">3) &quot;b1&quot;  </span><br><span class="line">4) &quot;m1&quot;  </span><br><span class="line">1) &quot;pmessage&quot;  </span><br><span class="line">2) &quot;b*&quot;  </span><br><span class="line">3) &quot;b11&quot;  </span><br><span class="line">4) &quot;m1&quot;  </span><br><span class="line">1) &quot;pmessage&quot;  </span><br><span class="line">2) &quot;d?*&quot;  </span><br><span class="line">3) &quot;d1&quot;  </span><br><span class="line">4) &quot;m1&quot;  </span><br><span class="line">1) &quot;pmessage&quot;  </span><br><span class="line">2) &quot;d?*&quot;  </span><br><span class="line">3) &quot;d11&quot;  </span><br><span class="line">4) &quot;m1&quot;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>使用psubscribe命令可以重复订阅同一个频道，如客户端执行了psubscribe c? c?<em>。这时向c1发布消息客户端会接受到两条消息，而同时publish命令的返回值是2而不是。.同样的，如果有另一个客户端执行了subscribe c1 和psubscribe c?</em>的话，向c1发送一条消息该客户顿也会受到两条消息(但是是两种类型:message和pmessage)，同时publish命令也返回2.</p></li><li><p>punsubscribe命令可以退订指定的规则，用法是: punsubscribe [pattern [pattern …]],如果没有参数则会退订所有规则。</p></li><li><p>使用punsubscribe只能退订通过psubscribe命令订阅的规则，不会影响直接通过subscribe命令订阅的频道；同样unsubscribe命令也不会影响通过psubscribe命令订阅的规则。另外需要注意punsubscribe命令退订某个规则时不会将其中的通配符展开，而是进行严格的字符串匹配，所以punsubscribe * 无法退订c<em>规则，而是必须使用punsubscribe c</em>才可以退订。</p></li></ul><h2 id="2-2-Java程序实现发布者订阅者模式"><a href="#2-2-Java程序实现发布者订阅者模式" class="headerlink" title="2.2 Java程序实现发布者订阅者模式"></a>2.2 Java程序实现发布者订阅者模式</h2><h3 id="2-2-1-生产者"><a href="#2-2-1-生产者" class="headerlink" title="2.2.1 生产者"></a>2.2.1 生产者</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class MessageProducer extends Thread &#123;  </span><br><span class="line">    public static final String CHANNEL_KEY &#x3D; &quot;channel:1&quot;;  </span><br><span class="line">    private volatile int count;  </span><br><span class="line">  </span><br><span class="line">    public void putMessage(String message) &#123;  </span><br><span class="line">        Jedis jedis &#x3D; JedisPoolUtils.getJedis();  </span><br><span class="line">        Long publish &#x3D; jedis.publish(CHANNEL_KEY, message);&#x2F;&#x2F;返回订阅者数量  </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; put message,count&#x3D;&quot; + count+&quot;,subscriberNum&#x3D;&quot;+publish);  </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public synchronized void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;  </span><br><span class="line">            putMessage(&quot;message&quot; + count);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        MessageProducer messageProducer &#x3D; new MessageProducer();  </span><br><span class="line">        Thread t1 &#x3D; new Thread(messageProducer, &quot;thread1&quot;);  </span><br><span class="line">        Thread t2 &#x3D; new Thread(messageProducer, &quot;thread2&quot;);  </span><br><span class="line">        Thread t3 &#x3D; new Thread(messageProducer, &quot;thread3&quot;);  </span><br><span class="line">        Thread t4 &#x3D; new Thread(messageProducer, &quot;thread4&quot;);  </span><br><span class="line">        Thread t5 &#x3D; new Thread(messageProducer, &quot;thread5&quot;);  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">        t3.start();  </span><br><span class="line">        t4.start();  </span><br><span class="line">        t5.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.thread1 put message,count&#x3D;0,subscriberNum&#x3D;0  </span><br><span class="line">2....  </span><br><span class="line">3.thread3 put message,count&#x3D;24,subscriberNum&#x3D;0</span><br></pre></td></tr></table></figure><h3 id="2-2-2-消费者subscribe-方式"><a href="#2-2-2-消费者subscribe-方式" class="headerlink" title="2.2.2 消费者subscribe 方式"></a>2.2.2 消费者subscribe 方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class MessageConsumer implements Runnable &#123;  </span><br><span class="line">    public static final String CHANNEL_KEY &#x3D; &quot;channel:1&quot;;&#x2F;&#x2F;频道  </span><br><span class="line">  </span><br><span class="line">    public static final String EXIT_COMMAND &#x3D; &quot;exit&quot;;&#x2F;&#x2F;结束程序的消息  </span><br><span class="line">  </span><br><span class="line">    private MyJedisPubSub myJedisPubSub &#x3D; new MyJedisPubSub();&#x2F;&#x2F;处理接收消息  </span><br><span class="line">  </span><br><span class="line">    public void consumerMessage() &#123;  </span><br><span class="line">        Jedis jedis &#x3D; JedisPoolUtils.getJedis();</span><br><span class="line">&#x2F;&#x2F;第一个参数是处理接收消息，第二个参数是订阅的消息频道    </span><br><span class="line">        jedis.subscribe(myJedisPubSub, CHANNEL_KEY);</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  &#x2F;&#x2F;这个地方我有疑问，需要循环么？</span><br><span class="line">            consumerMessage();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        MessageConsumer messageConsumer &#x3D; new MessageConsumer();  </span><br><span class="line">        Thread t1 &#x3D; new Thread(messageConsumer, &quot;thread5&quot;);  </span><br><span class="line">        Thread t2 &#x3D; new Thread(messageConsumer, &quot;thread6&quot;);  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">&#x2F;** </span><br><span class="line"> * 继承JedisPubSub，重写接收消息的方法 </span><br><span class="line"> *&#x2F;  </span><br><span class="line">class MyJedisPubSub extends JedisPubSub &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void onMessage(String channel, String message) &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;-接收到消息:channel&#x3D;&quot; + channel + &quot;,message&#x3D;&quot; + message);  </span><br><span class="line">        &#x2F;&#x2F;接收到exit消息后退出  </span><br><span class="line">        if (MessageConsumer.EXIT_COMMAND.equals(message)) &#123;  </span><br><span class="line">            System.exit(0);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再次启动生产者生产消息,消费者控制台:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.thread6-接收到消息:channel&#x3D;channel:1,message&#x3D;message0  </span><br><span class="line">2.thread5-接收到消息:channel&#x3D;channel:1,message&#x3D;message0  </span><br><span class="line">3.thread5-接收到消息:channel&#x3D;channel:1,message&#x3D;message1  </span><br><span class="line">4.thread6-接收到消息:channel&#x3D;channel:1,message&#x3D;message1  </span><br><span class="line">5.thread5-接收到消息:channel&#x3D;channel:1,message&#x3D;message2  </span><br><span class="line">6.thread6-接收到消息:channel&#x3D;channel:1,message&#x3D;message2  </span><br><span class="line">7....</span><br><span class="line">8.thread5-接收到消息:channel&#x3D;channel:1,message&#x3D;message24  </span><br><span class="line">9.thread6-接收到消息:channel&#x3D;channel:1,message&#x3D;message24</span><br></pre></td></tr></table></figure><h3 id="2-2-3-消费者-psubscribe实现订阅消费消息"><a href="#2-2-3-消费者-psubscribe实现订阅消费消息" class="headerlink" title="2.2.3 消费者 psubscribe实现订阅消费消息"></a>2.2.3 消费者 psubscribe实现订阅消费消息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class MessageConsumer implements Runnable &#123;  </span><br><span class="line">    public static final String CHANNEL_KEY &#x3D; &quot;channel*&quot;;&#x2F;&#x2F;频道  </span><br><span class="line">  </span><br><span class="line">    public static final String EXIT_COMMAND &#x3D; &quot;exit&quot;;&#x2F;&#x2F;结束程序的消息  </span><br><span class="line">  </span><br><span class="line">    private MyJedisPubSub myJedisPubSub &#x3D; new MyJedisPubSub();&#x2F;&#x2F;处理接收消息  </span><br><span class="line">  </span><br><span class="line">    public void consumerMessage() &#123;  </span><br><span class="line">        Jedis jedis &#x3D; JedisPoolUtils.getJedis();  </span><br><span class="line">&#x2F;&#x2F;第一个参数是处理接收消息，第二个参数是订阅的消息频道  </span><br><span class="line">        jedis.psubscribe(myJedisPubSub, CHANNEL_KEY);</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  &#x2F;&#x2F;这个地方我有疑问，需要循环么？</span><br><span class="line">            consumerMessage();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        MessageConsumer messageConsumer &#x3D; new MessageConsumer();  </span><br><span class="line">        Thread t1 &#x3D; new Thread(messageConsumer, &quot;thread5&quot;);  </span><br><span class="line">        Thread t2 &#x3D; new Thread(messageConsumer, &quot;thread6&quot;);  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line">&#x2F;&#x2F;继承JedisPubSub，重写接收消息的方法 </span><br><span class="line">class MyJedisPubSub extends JedisPubSub &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void onPMessage(String pattern, String channel, String message) &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;-接收到消息:pattern&#x3D;&quot;+pattern+&quot;,channel&#x3D;&quot; + channel + &quot;,message&#x3D;&quot; + message);  </span><br><span class="line">        &#x2F;&#x2F;接收到exit消息后退出  </span><br><span class="line">        if (MessageConsumer.EXIT_COMMAND.equals(message)) &#123;  </span><br><span class="line">            System.exit(0);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动生产者生产消息之后查看消费者控制台:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.thread6-接收到消息:pattern&#x3D;channel*,channel&#x3D;channel:1,message&#x3D;message0  </span><br><span class="line">2.thread5-接收到消息:pattern&#x3D;channel*,channel&#x3D;channel:1,message&#x3D;message0  </span><br><span class="line">3.thread5-接收到消息:pattern&#x3D;channel*,channel&#x3D;channel:1,message&#x3D;message1  </span><br><span class="line">4.thread6-接收到消息:pattern&#x3D;channel*,channel&#x3D;channel:1,message&#x3D;message1  </span><br><span class="line">5.thread6-接收到消息:pattern&#x3D;channel*,channel&#x3D;channel:1,message&#x3D;message2  </span><br><span class="line">6.thread5-接收到消息:pattern&#x3D;channel*,channel&#x3D;channel:1,message&#x3D;message2  </span><br><span class="line">7....  </span><br><span class="line">8.thread5-接收到消息:pattern&#x3D;channel*,channel&#x3D;channel:1,message&#x3D;message24  </span><br><span class="line">9.thread6-接收到消息:pattern&#x3D;channel*,channel&#x3D;channel:1,message&#x3D;message24</span><br></pre></td></tr></table></figure><p>补充:订阅的时候subscribe()和psubscribe()的第二个参数支持可变参数，也就是可以实现订阅多个频道。</p><h2 id="2-3-补充-停止阻塞队列监听、订阅监听"><a href="#2-3-补充-停止阻塞队列监听、订阅监听" class="headerlink" title="2.3 补充(停止阻塞队列监听、订阅监听):"></a>2.3 补充(停止阻塞队列监听、订阅监听):</h2><ul><li>发布订阅执行订阅之后该线程处于阻塞状态，线程不会终止，如果终止线程需要退订，需要调用JedisPubSub的unsubscribe()方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Test111 &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Jedis jedis &#x3D; JedisPoolUtils.getJedis();  </span><br><span class="line">        System.out.println(&quot;订阅前&quot;);  </span><br><span class="line">        jedis.subscribe(new JedisPubSub() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void onMessage(String channel, String message) &#123;  </span><br><span class="line">                super.onMessage(channel, message);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;, &quot;c1&quot;);  </span><br><span class="line">        System.out.println(&quot;订阅后&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">结果只会打印订阅前，而且线程不会终止。</span><br><span class="line"> </span><br><span class="line">为了使线程可以停止，必须退订，而且退订只能调用  JedisPubSub.unsubscribe()方法，例如:收到quit消息之后会退订，线程会回到主线程打印订阅后。</span><br><span class="line">public class Test111 &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Jedis jedis &#x3D; JedisPoolUtils.getJedis();  </span><br><span class="line">        System.out.println(&quot;订阅前&quot;);  </span><br><span class="line">        jedis.subscribe(new JedisPubSub() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void onMessage(String channel, String message) &#123;  </span><br><span class="line">                if(&quot;quit&quot;.equals(message))&#123;  </span><br><span class="line">                    unsubscribe(&quot;c1&quot;);  </span><br><span class="line">                &#125;  </span><br><span class="line">                System.out.println(message);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            @Override  </span><br><span class="line">            public void unsubscribe(String... channels) &#123;  </span><br><span class="line">                super.unsubscribe(channels);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;, &quot;c1&quot;);  </span><br><span class="line">        System.out.println(&quot;订阅后&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BRPOP:当给定列表内没有任何元素可供弹出的时候，连接将被BRPOP命令阻塞，直到等待超时或发现可弹出元素为止。(每次只弹出一个元素，当没有元素的时候处于阻塞，当弹出一个元素之后就会解除阻塞)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test111 &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Jedis jedis &#x3D; JedisPoolUtils.getJedis();  </span><br><span class="line">        System.out.println(&quot;brpop之前&quot;);  </span><br><span class="line">        List&lt;String&gt; messages &#x3D; jedis.brpop(0,&quot;list1&quot;);  </span><br><span class="line">        System.out.println(messages);  </span><br><span class="line">        System.out.println(&quot;brpop之后&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-redis实现消息队列&quot;&gt;&lt;a href=&quot;#1-redis实现消息队列&quot; class=&quot;headerlink&quot; title=&quot;1.redis实现消息队列&quot;&gt;&lt;/a&gt;1.redis实现消息队列&lt;/h1&gt;&lt;p&gt;redis的列表类型天生支持用作消息队列。(类似于MQ的队列模型–任何时候都可以消费，一条消息只能消费一次)
    
    </summary>
    
    
    
      <category term="Redis" scheme="https://dcghx.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot(1)————基础</title>
    <link href="https://dcghx.github.io/2020/05/09/springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80/"/>
    <id>https://dcghx.github.io/2020/05/09/springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-31T08:32:02.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、spring-boot父项目搭建"><a href="#1、spring-boot父项目搭建" class="headerlink" title="1、spring boot父项目搭建"></a>1、spring boot父项目搭建<a id="more"></a></h1><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps1.jpg" alt="img"></p><hr><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps2.jpg" alt="img"></p><p>一般选取lomback、测试jar即可</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps3.jpg" alt="img"></p><hr><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps4.jpg" alt="img"></p><p>Pom文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1.&lt;dependencies&gt;    </span><br><span class="line">2.    &lt;dependency&gt;    </span><br><span class="line">3.        &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;    </span><br><span class="line">4.        &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;    </span><br><span class="line">5.        &lt;optional&gt;true&lt;&#x2F;optional&gt;    </span><br><span class="line">6.    &lt;&#x2F;dependency&gt;    </span><br><span class="line">7.    &lt;dependency&gt;    </span><br><span class="line">8.        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    </span><br><span class="line">9.        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;    </span><br><span class="line">10.        &lt;scope&gt;test&lt;&#x2F;scope&gt;    </span><br><span class="line">11.        &lt;exclusions&gt;    </span><br><span class="line">12.            &lt;exclusion&gt;    </span><br><span class="line">13.                &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;    </span><br><span class="line">14.                &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;    </span><br><span class="line">15.            &lt;&#x2F;exclusion&gt;    </span><br><span class="line">16.        &lt;&#x2F;exclusions&gt;    </span><br><span class="line">17.    &lt;&#x2F;dependency&gt;    </span><br><span class="line">18.&lt;&#x2F;dependencies&gt;    </span><br><span class="line">19.  </span><br><span class="line">20.&lt;!--&lt;build&gt;    </span><br><span class="line">21.    &lt;plugins&gt;    </span><br><span class="line">22.        &lt;plugin&gt;    </span><br><span class="line">23.            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    </span><br><span class="line">24.            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;    </span><br><span class="line">25.        &lt;&#x2F;plugin&gt;    </span><br><span class="line">26.    &lt;&#x2F;plugins&gt;    </span><br><span class="line">27.    &lt;resources&gt;    </span><br><span class="line">28.        &lt;resource&gt;    </span><br><span class="line">29.            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;    </span><br><span class="line">30.            &lt;includes&gt;    </span><br><span class="line">31.                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;    </span><br><span class="line">32.                &lt;!–&lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;    </span><br><span class="line">33.                &lt;include&gt;**&#x2F;*.yml&lt;&#x2F;include&gt;–&gt;    </span><br><span class="line">34.            &lt;&#x2F;includes&gt;    </span><br><span class="line">35.            &lt;!–&lt;filtering&gt;false&lt;&#x2F;filtering&gt;–&gt;    </span><br><span class="line">36.        &lt;&#x2F;resource&gt;    </span><br><span class="line">37.        &lt;!–指定资源的位置–&gt;    </span><br><span class="line">38.        &lt;resource&gt;    </span><br><span class="line">39.            &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;    </span><br><span class="line">40.        &lt;&#x2F;resource&gt;    </span><br><span class="line">41.    &lt;&#x2F;resources&gt;    </span><br><span class="line">42.&lt;&#x2F;build&gt;--&gt;</span><br></pre></td></tr></table></figure><h1 id="2、spring-boot子项目搭建"><a href="#2、spring-boot子项目搭建" class="headerlink" title="2、spring boot子项目搭建"></a>2、spring boot子项目搭建</h1><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps5.jpg" alt="img"></p><hr><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps6.jpg" alt="img"></p><hr><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps7.jpg" alt="img"></p><h1 id="3、java-Bean的工具lombok"><a href="#3、java-Bean的工具lombok" class="headerlink" title="3、java Bean的工具lombok"></a>3、java Bean的工具lombok</h1><p>lombok是开源的代码生成库，是一款非常实用的小工具，我们在编辑实体类时可以通过lombok注解减少getter、setter等方法的编写，在更改实体类时只需要修改属性即可，减少了很多重复代码的编写工作</p><h2 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h2><p>首先我们需要安装IntelliJ IDEA中的lombok插件，打开IntelliJ IDEA后点击菜单栏中的File–&gt;Settings，或者使用快捷键Ctrl+Alt+S进入到设置页面。</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps8.jpg" alt="img"></p><p>我们点击设置中的Plugins进行插件的安装，在右侧选择Browse repositories…，然后在搜索页面输入lombok变可以查询到下方的Lombok Plugin，鼠标点击Lombok Plugin可在右侧看到Install按钮，点击该按钮便可安装。</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps9.jpg" alt="img"></p><p>我们在安装页面可以看到lombok具体支持的所有注解，在安装过程中有Downloading Plugins的提示，安装过程中进度条会变化。需要提醒的是，在安装过程中一定要保证网络连接可用且良好，否则可能会安装失败。安装成功后我们可以看到右侧的Restart按钮，此时可先不操作，因为我们还有后续的配置工作。安装完成后我们再回到Plugins，此时在右侧可以搜索到lombok，而安装前是不行的。</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps10.jpg" alt="img"></p><hr><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps11.jpg" alt="img"></p><hr><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps12.jpg" alt="img"></p><hr><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps13.jpg" alt="img"></p><h2 id="3-2-配置注解处理器"><a href="#3-2-配置注解处理器" class="headerlink" title="3.2 配置注解处理器"></a>3.2 配置注解处理器</h2><p>同样我们在Settings设置页面，我们点击Build，Execution，Deployment–&gt;选择Compiler–&gt;选中Annotation Processors，然后在右侧勾选Enable annotation processing即可。</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps14.jpg" alt="img"></p><h2 id="3-3-lombok插件的pom引用"><a href="#3-3-lombok插件的pom引用" class="headerlink" title="3.3 lombok插件的pom引用"></a>3.3 lombok插件的pom引用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="3-4-常用注解"><a href="#3-4-常用注解" class="headerlink" title="3.4 常用注解"></a>3.4 常用注解</h2><ul><li><p>@Getter / @Setter：可以作用在类上和属性上，放在类上，会对所有的非静态(non-static)属性生成Getter/Setter方法，放在属性上，会对该属性生成Getter/Setter方法。并可以指定Getter/Setter方法的访问级别。</p></li><li><p>@EqualsAndHashCode ：默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。 </p></li><li><p>@ToString 生成toString方法，默认情况下，会输出类名、所有属性，属性会按照顺序输出，以逗号分割。</p></li><li><p>@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor：无参构造器、部分参数构造器、全参构造器</p></li><li><p>@Data：包含@ToString, @EqualsAndHashCode, 所有属性的@Getter, 所有non-final属性的@Setter和</p></li><li><p>@RequiredArgsConstructor的组合，通常情况下，基本上使用这个注解就足够了。</p></li><li><p>@Budilder：可以进行Builder方式初始化。</p></li><li><p>@Slf4j：等同于：private final Logger logger = LoggerFactory.getLogger(XXX.class);简直不能更爽了！一般上用在其他java类上</p></li></ul><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps15.jpg" alt="img"></p><h1 id="4、springboot配置文件详解"><a href="#4、springboot配置文件详解" class="headerlink" title="4、springboot配置文件详解"></a>4、springboot配置文件详解</h1><p>基于springboot的约定优于配置的原则，在多数情况下，启动一个应用时，基本上无需做太多的配置，应用就能正常启动。但在大部分开发环境下，添加额外配置是无所避免的，比如自定义应用端口号(比较在机器比较少的情况下，一台机器还是需要部署多个应用的，当然利用docker的话，是可避免的，这是后话了)、mq的服务地址、缓存服务的服务地址、数据库的配置等，都或多或少的需要一些外部的配置项。</p><h2 id="4-1-配置文件格式简要说明"><a href="#4-1-配置文件格式简要说明" class="headerlink" title="4.1 配置文件格式简要说明"></a>4.1 配置文件格式简要说明</h2><p>springboot默认的全局配置文件名为application.properties或者application.yml(spring官方推荐使用的格式是.yml格式，目前官网都是实例都是使用yml格式进行配置讲解的),应用启动时会自动加载此文件，无需手动引入。除此之外还有一个bootstrap的全局文件，它的加载顺序在application配置文件之前，主要是用于在应用程序上下文的引导阶段，在后期讲解springCloudConfig时，主要是利用此特性，进行配置文件的动态修改，在此不表，在通常情况下，此两个配置文件是没有差别的，所以一般上都只需要配置application即可。</p><h2 id="4-2-自定义属性值"><a href="#4-2-自定义属性值" class="headerlink" title="4.2 自定义属性值"></a>4.2 自定义属性值</h2><p>application.properties配置文件支持自定义属性的支持，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.blog.address&#x3D;https:&#x2F;&#x2F;blog.lqdev.cn  </span><br><span class="line">2.blog.author&#x3D;oKong</span><br></pre></td></tr></table></figure><p>然后可通过@Value(“${blog.author}”)的形式获取属性值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.@Value(&quot;$&#123;blog.address&#125;&quot;)  </span><br><span class="line">2.String address;  </span><br><span class="line">3.      </span><br><span class="line">4.@Value(&quot;$&#123;blog.author&#125;&quot;)  </span><br><span class="line">5.String author;  </span><br><span class="line">6.      </span><br><span class="line">7.@Value(&quot;$&#123;blog.desc&#125;&quot;)    </span><br><span class="line">8.String desc;</span><br></pre></td></tr></table></figure><p>这里提醒下，在填写一些默认的比如，数据库属性时，可使用alt+/的方式，IDE会自动显示提示，避免了手动嵌入属性值或者忘记属性的尴尬。</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps16.jpg" alt="img"></p><p>关于自定义属性时，特别是一些公用包，会使用到属性值时，建议在创建<strong><em>\</em>additional-spring-configuration-metadata.json**</strong>属性元文件，这样在使用上述快捷方式时，会进行提示，包括属性名和属性说明，这样也方便调用者询问属性名是啥。</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps17.jpg" alt="img"></p><hr><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps18.jpg" alt="img"></p><h2 id="4-3-springboot用-value-“-key-”-读取配置文件中文乱码问题解决"><a href="#4-3-springboot用-value-“-key-”-读取配置文件中文乱码问题解决" class="headerlink" title="4.3 springboot用@value(“${key}”)读取配置文件中文乱码问题解决"></a>4.3 springboot用@value(“${key}”)读取配置文件中文乱码问题解决</h2><p>设置 File Encodings的Transparent native-to-ascii conversion为true，具体步骤如下依次点击 File -&gt; Settings -&gt; Editor -&gt; File Encodings 将Properties Files (*.properties)下的Default encoding for properties files设置为UTF-8，将Transparent native-to-ascii conversion前的勾选上。</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps19.jpg" alt="img"></p><h2 id="4-4-属性引用"><a href="#4-4-属性引用" class="headerlink" title="4.4 属性引用"></a>4.4 属性引用</h2><p>在配置文件中，各个属性参数可进行引用的，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.blog.address&#x3D;https:&#x2F;&#x2F;blog.lqdev.cn  </span><br><span class="line">2.blog.author&#x3D;oKong  </span><br><span class="line">3.blog.desc&#x3D;$&#123;blog.author&#125;,$&#123;blog.address&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-随机数"><a href="#4-5-随机数" class="headerlink" title="4.5 随机数"></a>4.5 随机数</h2><p>Spring Boot的属性配置文件中可以通过${random}来产生int值、long值或者string字符串，来支持属性的随机值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.# 随机字符串  </span><br><span class="line">2..blog.value&#x3D;$&#123;random.value&#125;  </span><br><span class="line">3.# 随机int  </span><br><span class="line">4..blog.number&#x3D;$&#123;random.int&#125;  </span><br><span class="line">5.# 随机long  </span><br><span class="line">6..blog.bignumber&#x3D;$&#123;random.long&#125;  </span><br><span class="line">7.# 10以内的随机数  </span><br><span class="line">8..blog.test1&#x3D;$&#123;random.int(10)&#125;  </span><br><span class="line">9.# 1-20的随机数  </span><br><span class="line">10..blog.test2&#x3D;$&#123;random.int[1,20]&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-自定义配置文件"><a href="#4-6-自定义配置文件" class="headerlink" title="4.6 自定义配置文件"></a>4.6 自定义配置文件</h2><p>在多数情况下，配置信息基本上都是放入application.properties文件中，但在一些场景下，比如某个配置项比较多时，为了分开存放，也可自定义配置文件，如my.properties。由于自定义的文件，系统不会自动加载，这个时候就需要手动引入了。<br>利用@PropertySource注解既可以引入配置文件，需要引入多个时，可使用@PropertySources设置数组，引入多个文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.@SpringBootApplication  </span><br><span class="line">2.@PropertySource(value&#x3D;&quot;classpath:my.properties&quot;,encoding&#x3D;&quot;utf-8&quot;)  </span><br><span class="line">3.public class Chapter3Application &#123;  </span><br><span class="line">4.  </span><br><span class="line">5.    public static void main(String[] args) &#123;  </span><br><span class="line">6.        SpringApplication.run(Chapter3Application.class, args);  </span><br><span class="line">7.    &#125;  </span><br><span class="line">8.&#125;</span><br></pre></td></tr></table></figure><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps20.jpg" alt="img"></p><h2 id="4-7-配置绑定对象"><a href="#4-7-配置绑定对象" class="headerlink" title="4.7 配置绑定对象"></a>4.7 配置绑定对象</h2><p>虽然使用@Value()方式，能方便的引入自定义的属性值，但在多某个配置项属于某一配置时，希望对应到一个实体配置类中，springboot也提供了支持。利用@ConfigurationProperties属性，即可完成<br>my.properties配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.config.code&#x3D;code  </span><br><span class="line">2.config.name&#x3D;趔趄的猿  </span><br><span class="line">3.config.hobby[0]&#x3D;看电影  </span><br><span class="line">4.config.hobby[1]&#x3D;旅游</span><br></pre></td></tr></table></figure><p>实体类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.@Component  </span><br><span class="line">2.&#x2F;&#x2F;@EnableConfigurationProperties(value&#x3D; &#123;Config.class&#125;)  </span><br><span class="line">3.@ConfigurationProperties(prefix&#x3D;&quot;config&quot;)  </span><br><span class="line">4.@Data  </span><br><span class="line">5.public class Config &#123;  </span><br><span class="line">6.      </span><br><span class="line">7.    String code;  </span><br><span class="line">8.      </span><br><span class="line">9.    String name;  </span><br><span class="line">10.      </span><br><span class="line">11.    List&lt;String&gt; hobby;  </span><br><span class="line">12.&#125;</span><br></pre></td></tr></table></figure><p>这里可直接加入<strong><em>\</em>@Component**</strong>使其在启动时被自动扫描到，或者使用<strong><em>\</em>@EnableConfigurationProperties**</strong>注解注册此实体bean.其次，在引入<strong><em>\</em>@ConfigurationProperties**</strong>时，IDE会提示你引入<strong><em>\</em>spring-boot-configuration-processor**</strong>依赖，前面提到，在自定义属性时，创建<strong><em>\</em>additional-spring-configuration-metadata.json**</strong>可进行属性提示，而此依赖功能类似，会编译时自动生成<strong><em>\</em>spring-configuration-metadata.json**</strong>文件，此文件主要给IDE使用，用于提示使用。添加后在配置文件点击属性时，会自动跳转到对应绑定的实体类中</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps21.jpg" alt="img"></p><h1 id="5-常用注解"><a href="#5-常用注解" class="headerlink" title="5. 常用注解"></a>5. 常用注解</h1><h3 id="1-SpringBootApplication"><a href="#1-SpringBootApplication" class="headerlink" title="1. @SpringBootApplication"></a>1. @SpringBootApplication</h3><p>在系统启动类里面，都加入了此启动注解，此注解是个组合注解，包括了@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan注解。</p><p>@SpringBootConfiguration 继承至@Configuration，对于熟悉spring的开发者而言，此标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到srping容器中，并且实例名就是方法名。</p><p>@EnableAutoConfiguration 这个注解就是springboot能自动进行配置的魔法所在了。主要是通过此注解，能所有符合自动配置条件的bean的定义加载到spring容器中，比如根据spring-boot-starter-web ，来判断你的项目是否需要添加了webmvc和tomcat，就会自动的帮你配置web项目中所需要的默认配置。具体的使用，会在后期自定义实现一个自动启动类时，会讲解到它的一些机制。此章节就不深入了，只需要它是这个用途即可，一般上也单独使用不要这个注解，但比如需要排除一些无需自动配置的类时，可利用exclude进行排除。</p><p>@ComponentScan 这个熟悉spring的开发者也应该熟悉，会扫描当前包及其子包下被@Component，@Controller，@Service，@Repository等注解标记的类并纳入到spring容器中进行管理。</p><h3 id="2-Controller-和-RestController"><a href="#2-Controller-和-RestController" class="headerlink" title="2. @Controller 和 @RestController"></a>2. @Controller 和 @RestController</h3><p>@RestController 是Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。而@Controller是用来创建处理http请求的对象，一般结合@RequestMapping使用。</p><h3 id="3-RequestMapping"><a href="#3-RequestMapping" class="headerlink" title="3. @RequestMapping"></a>3. @RequestMapping</h3><p>一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>常用属性：</p><p>value， method；<br>value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；<br>method： 指定请求的method类型， GET、POST、PUT、DELETE等；</p><p>consumes，produces；<br>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;<br>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p><p>params，headers；<br>params： 指定request中必须包含某些参数值是，才让该方法处理。<br>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><p>常用的基本上就value和method了。<br>其简化注解有</p><p>@GetMapping 等同于 @RequestMapping(method = RequestMethod.GET)<br>@PostMapping 等同于 @RequestMapping(method = RequestMethod.POST)<br>@PutMapping 等同于 @RequestMapping(method = RequestMethod.PUT)<br>@DeleteMapping 等同于 @RequestMapping(method = RequestMethod.DELETE)<br>@PatchMapping 等同于 @RequestMapping(method = RequestMethod.PATCH)</p><h3 id="4-RequestBody和-ResponseBody"><a href="#4-RequestBody和-ResponseBody" class="headerlink" title="4. @RequestBody和@ResponseBody"></a>4. @RequestBody和@ResponseBody</h3><p>@RequestBody注解允许request的参数在reqeust体中，常常结合前端POST请求，进行前后端交互。</p><p>@ResponseBody注解支持将的参数在response体中，通常返回json格式给前端。</p><h3 id="5-PathVariable、-RequestParam、-RequestAttribute"><a href="#5-PathVariable、-RequestParam、-RequestAttribute" class="headerlink" title="5. @PathVariable、@RequestParam、@RequestAttribute"></a>5. @PathVariable、@RequestParam、@RequestAttribute</h3><p>@PathVariable用来接收参数,如/path/001,可接收001作为参数</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps22.jpg" alt="img"></p><p>@RequestParam 用来接收URL中的参数,如/param?id=001,可接收001作为参数</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps23.jpg" alt="img"></p><p>@RequestAttribute用于访问由过滤器或拦截器创建的、预先存在的请求属性，效果等同与request.getAttrbute().</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps24.jpg" alt="img"></p><h3 id="7-Component、-Service、-Repository"><a href="#7-Component、-Service、-Repository" class="headerlink" title="7. @Component、@Service、@Repository"></a>7. @Component、@Service、@Repository</h3><p>这三者都是申明一个单例的bean类并纳入spring容器中，后两者其实都是继承于@Component。</p><p>@Component 最普通的组件，可以被注入到spring容器进行管理</p><p>@Repository 作用于持久层</p><p>@Service 作用于业务逻辑层</p><p>通常一些类无法确定是使用@Service还是@Component时，注解使用@Component，比如redis的配置类等</p><h3 id="8-ModelAttribute-很少用到"><a href="#8-ModelAttribute-很少用到" class="headerlink" title="8. @ModelAttribute(很少用到)"></a>8. @ModelAttribute(很少用到)</h3><p>主要是绑定请求参数到指定对象上。此注解可被用于方法、参数上。</p><p>运用在参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；</p><p>运用在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；</p><p>由于现在都采用前后端分离开发，故此注解相对用的较少了，但对于一些在每次请求前需要进行一些额外操作时。使用此注解依然是个选择，比如进行统一的业务校验等，但使用此注解实现类似功能时需要注意，使用异步调用时，比如callable或者DeferredResult时，被此注解的方法会执行两次，因为异步请求时，是挂起另一个线程去重新执行，对于配置了拦截器而已，它们的执行顺序为</p><p>preHandle —-&gt;afterConcurrentHandlingStarted —-&gt; Controller—-&gt;preHandler—-&gt; postHandler —-&gt; afterCompletion</p><h1 id="7-过滤器、拦截器、监听器"><a href="#7-过滤器、拦截器、监听器" class="headerlink" title="7. 过滤器、拦截器、监听器"></a>7. 过滤器、拦截器、监听器</h1><h2 id="7-1-过滤器Filter"><a href="#7-1-过滤器Filter" class="headerlink" title="7.1 过滤器Filter"></a>7.1 过滤器Filter</h2><p>Servlet过滤器是在java servlet规范2.3中定义的，他能够对servlet容器的请求和响应对象进行检查和修改。</p><p>Servlet过滤器本身并不产生请求和响应对象，他只能提供过滤作用，servlet过滤能够在servlet被调用之前检查request对象，修改request的header和request内容，在调用后检查response对象，修改response的头和内容。</p><p>特点：</p><ul><li><p>过滤器可以检查和修改request和response对象</p></li><li><p>过滤器可以被指定url，当访问到该url时才会触发过滤</p></li><li><p>过滤器可以有很多个，串联使用，形成过滤器链。</p></li></ul><p>作用：</p><ul><li><p>查询请求并作出相应的行动</p></li><li><p>阻塞请求和响应</p></li><li><p>修改请求头和请求体，自定义请求</p></li><li><p>修改响应头和响应体，自定义响应</p></li><li><p>与外部资源进行交互</p></li></ul><p>场景：</p><p>认证过滤，登录和审核过滤，加密过滤率，令牌过滤，资源访问出发事件过滤</p><p>接口构成：</p><p>过滤器都必须实现javax.servlet.Filter接口，主要有三种方法：</p><ul><li><p>init方法：初始化时方法，容器启动时做读取一些初始化参数，</p></li><li><p>doFilter方法：实际进行过滤操作，具体怎么过滤，怎么修改在这里进行，</p></li><li><p>destroy方法：容器字啊销毁过滤器实例前调用的方法，可以释放资源。</p></li></ul><p>* 例子（基于@WebFilter版本，web.xmL版本的用时再看）</p><p>@WebFilter是Servlet3.0新增的注解，原先实现过滤器，需要在web.xml中进行配置，而现在通过此注解，启动启动时会自动扫描自动注册。</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps25.jpg" alt="img"></p><p>然后在启动类加入@ServletComponentScan注解即可。</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps26.jpg" alt="img"></p><p>控制台输出：说明过滤器启动成功</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps27.jpg" alt="img"></p><p>上述注解式方式虽然实现了单一过滤器的启动，但是如果在项目中同时存在多个过滤器的情况下，就需要关注一个问题，各个过滤器启动顺序是无法指定的，此时就需要用到FilterRegistrationBean进行过滤器的注册，FilterRegistrationBean是springboot提供的，此类提供setOrder方法，可以为filter设置排序值，让spring在注册web filter之前排序后再依次注册。</p><p><strong>第一个过滤器</strong></p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps28.jpg" alt="img"></p><p><strong>第二个过滤器</strong></p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps29.jpg" alt="img"></p><p>启动类中利用<strong><em>\</em>@bean**</strong>注册FilterRegistrationBean，并用setOrder设置过滤器的执行顺序</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps30.jpg" alt="img"></p><p>控制台输出</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps31.jpg" alt="img"></p><h2 id="7-2-拦截器Interceptor"><a href="#7-2-拦截器Interceptor" class="headerlink" title="7.2 拦截器Interceptor"></a>7.2 拦截器Interceptor</h2><p>SpringMVC 中的Interceptor 拦截器也是相当重要和相当有用的，它的主要作用是拦截用户的请求并进行相应的处理。比如通过它来进行权限验证，或者是来判断用户是否登陆，或者是像12306 那样子判断当前时间是否是购票时间。</p><p> SpringMVC 中的Interceptor 拦截请求是通过HandlerInterceptor 来实现的。在SpringMVC 中定义一个</p><p>Interceptor 非常简单，主要有两种方式：<br>第一种方式是要定义的Interceptor类要实现了Spring 的HandlerInterceptor 接口，或者是这个类继承实现了HandlerInterceptor 接口的类，比如Spring 已经提供的实现了HandlerInterceptor 接口的抽象类HandlerInterceptorAdapter ；</p><p>第二种方式是实现Spring的WebRequestInterceptor接口，或者是继承实现了WebRequestInterceptor的类。<br>过滤器和拦截器的相似：</p><ul><li>都有优先处理请求的权利，都可以决定是否将请求转移到请求的实际处理的控制器处。</li><li>都可以对请求或者会话当中的数据进行加工。</li></ul><p>过滤器和拦截器的区别：</p><ul><li>Filter需要在web.xml中配置，依赖于Servlet。Interceptor需要在SpringMVC中配置，依赖于框架；</li><li>两者的本质区别：拦截器（Interceptor）是基于Java的反射机制，而过滤器（Filter）是基于函数回调。从灵活性上说拦截器功能更强大些，Filter能做的事情，都能做，而且可以在请求前，请求后执行，比较灵活。Filter主要是针对URL地址做一个编码的事情、过滤掉没用的参数、安全校验（比较泛的，比如登录不登录之类），太细的话，还是建议用interceptor。不过还是根据不同情况选择合适的。</li><li>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</li><li>过滤器是JavaEE标准，采用函数回调的方式进行。是在请求进入容器之后，还未进入Servlet之前进行预处理，并且在请求结束返回给前端这之间进行后期处理。拦截器是被包裹在过滤器之中的。如下图</li></ul><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps32.png" alt="img"></p><p>* 例子（基于springboot版本，spring版本的用时再看）</p><p>1.自定义拦截器</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps33.jpg" alt="img"></p><p>2.Config配置类</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps34.jpg" alt="img"></p><p>然后我们需要编写一个Controller控制类用于处理url请求，因为拦截器只能拦截SpringMVC的Controller控制器处理的请求</p><h2 id="7-3-监听器-Listener"><a href="#7-3-监听器-Listener" class="headerlink" title="7.3 监听器 Listener"></a>7.3 监听器 Listener</h2><p>JavaWeb主要有三种类型的监听器ServletContextListener，HttpSessionListener，ServletRequestListener,   这三种类型监听器对应的作用域分别是application(HttpSession), servletContext, servletRequest。编写自定义的监听器时，只需要实现上述的三个接口即可。</p><ul><li>servletContext在整个应用启动到结束中生效。启动系统时创建这个对象，整个过程中这个对象是唯一的。 </li><li>httpSession则是在一个session会话中生效，在一个session被创建直到失效的过程中都起作用，只是一个启动的应用中httpSession对象能够有多个，比方同一台电脑两个浏览器訪问。就会创建两个httpSession对象。 </li><li>servletRequest是在一个request请求被创建和销毁的过程中生效，每发起一次请求就会创建一个新的servletRequest对象，比方刷新浏览器页面、点击应用的内链等等。</li></ul><p>*例子（基于springboot版本，spring版本的用时再看）</p><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps35.jpg" alt="img"></p><hr><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps36.jpg" alt="img"></p><hr><p><img src="springboot-%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80.assets/wps37.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、spring-boot父项目搭建&quot;&gt;&lt;a href=&quot;#1、spring-boot父项目搭建&quot; class=&quot;headerlink&quot; title=&quot;1、spring boot父项目搭建&quot;&gt;&lt;/a&gt;1、spring boot父项目搭建
    
    </summary>
    
    
    
      <category term="spring-boot" scheme="https://dcghx.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>数据库————基础知识</title>
    <link href="https://dcghx.github.io/2020/05/09/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://dcghx.github.io/2020/05/09/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-05-09T03:15:27.000Z</published>
    <updated>2020-05-31T07:30:39.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据库四大特性"><a href="#1-数据库四大特性" class="headerlink" title="1.数据库四大特性"></a>1.数据库四大特性</h1><h2 id="1-1原子性（Atomicity）"><a href="#1-1原子性（Atomicity）" class="headerlink" title="1.1原子性（Atomicity）"></a>1.1原子性（Atomicity）</h2><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><h2 id="1-2一致性（Consistency）"><a href="#1-2一致性（Consistency）" class="headerlink" title="1.2一致性（Consistency）"></a>1.2一致性（Consistency）</h2><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。<br>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p><h2 id="1-3隔离性（Isolation）"><a href="#1-3隔离性（Isolation）" class="headerlink" title="1.3隔离性（Isolation）"></a>1.3隔离性（Isolation）</h2><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p><h2 id="1-4持久性（Durability）"><a href="#1-4持久性（Durability）" class="headerlink" title="1.4持久性（Durability）"></a>1.4持久性（Durability）</h2><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。<br>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务已经正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p><h1 id="2-隔离级别"><a href="#2-隔离级别" class="headerlink" title="2.隔离级别"></a>2.隔离级别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update account set money&#x3D;money+100 where name&#x3D;’B’;  (此时A通知B)</span><br><span class="line">update account set money&#x3D;money - 100 where name&#x3D;’A’;</span><br></pre></td></tr></table></figure><p>当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。</p><p>以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题： </p><h2 id="2-1脏读"><a href="#2-1脏读" class="headerlink" title="2.1脏读"></a>2.1脏读</h2><p>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据，当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。<br>例如：用户A向用户B转账100元，对应SQL命令如下</p><p>当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。</p><h2 id="2-2不可重复读"><a href="#2-2不可重复读" class="headerlink" title="2.2不可重复读"></a>2.2不可重复读</h2><p>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。<br>例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发生了不可重复读。<br>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。<br>在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……</p><h2 id="2-3幻读"><a href="#2-3幻读" class="headerlink" title="2.3幻读"></a>2.3幻读</h2><p>幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。<br>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p><h2 id="2-4四种隔离级别"><a href="#2-4四种隔离级别" class="headerlink" title="2.4四种隔离级别"></a>2.4四种隔离级别</h2><p>现在来看看MySQL数据库为我们提供的四种隔离级别：<br>① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。<br>② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。<br>③ Read committed (读已提交)：可避免脏读的发生。<br>④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</p><p>以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。</p><p>在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。</p><h1 id="3-七大传播属性"><a href="#3-七大传播属性" class="headerlink" title="3.七大传播属性"></a>3.七大传播属性</h1><ol><li>1)PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</li><li>PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。</li><li>PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。</li><li>PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。</li><li>PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>PROPAGATION_NESTED–如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</li></ol><h1 id="4-MySQL数据库引擎类别"><a href="#4-MySQL数据库引擎类别" class="headerlink" title="4.MySQL数据库引擎类别"></a>4.MySQL数据库引擎类别</h1><p>你能用的数据库引擎取决于mysql在安装的时候是如何被编译的。要添加一个新的引擎，就必须重新编译MYSQL。在缺省情况下，MYSQL支持三个引擎：ISAM、MYISAM和HEAP。另外两种类型INNODB和BERKLEY（BDB），也常常可以使用。</p><p>##4.1ISAM<br>ISAM是一个定义明确且历经时间考验的数据表格管理方法，它在设计之时就考虑到数据库被查询的次数要远大于更新的次数。因此，ISAM执行读取操作的速度很快，而且不占用大量的内存和存储资源。ISAM的两个主要不足之处在于，它不支持事务处理，也不能够容错：如果你的硬盘崩溃了，那么数据文件就无法恢复了。如果你正在把ISAM用在关键任务应用程序里，那就必须经常备份你所有的实时数据，通过其复制特性，MYSQL能够支持这样的备份应用程序。</p><h2 id="4-2MYISAM"><a href="#4-2MYISAM" class="headerlink" title="4.2MYISAM"></a>4.2MYISAM</h2><p>MYISAM是MYSQL的ISAM扩展格式和缺省的数据库引擎。除了提供ISAM里所没有的索引和字段管理的功能，MYISAM还使用一种表格锁定的机制，来优化多个并发的读写操作。其代价是你需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间。MYISAM还有一些有用的扩展，例如用来修复数据库文件的MYISAMCHK工具和用来恢复浪费空间的MYISAMPACK工具.<br>MYISAM强调了快速读取操作，这可能就是为什么MYSQL受到了WEB开发如此青睐的主要原因：在WEB开发中你所进行的大量数据操作都是读取操作。所以，大多数虚拟主机提供商和INTERNET平台提供商只允许使用MYISAM格式。</p><h2 id="4-3HEAP"><a href="#4-3HEAP" class="headerlink" title="4.3HEAP"></a>4.3HEAP</h2><p>HEAP允许只驻留在内存里的临时表格。驻留在内存里让HEAP要比ISAM和MYISAM都快，但是它所管理的数据是不稳定的，而且如果在关机之前没有进行保存，那么所有的数据都会丢失。在数据行被删除的时候，HEAP也不会浪费大量的空间。HEAP表格在你需要使用SELECT表达式来选择和操控数据的时候非常有用。要记住，在用完表格之后就删除表格。</p><h2 id="4-4INNODB和BERKLEYDB"><a href="#4-4INNODB和BERKLEYDB" class="headerlink" title="4.4INNODB和BERKLEYDB"></a>4.4INNODB和BERKLEYDB</h2><p>INNODB和BERKLEYDB（BDB）数据库引擎都是造就MYSQL灵活性的技术的直接产品，这项技术就是MYSQL++ API。在使用MYSQL的时候，你所面对的每一个挑战几乎都源于ISAM和MYISAM数据库引擎不支持事务处理也不支持外来键。尽管要比ISAM和MYISAM引擎慢很多，但是INNODB和BDB包括了对事务处理和外来键的支持，这两点都是前两个引擎所没有的。如前所述，如果你的设计需要这些特性中的一者或者两者，那你就要被迫使用后两个引擎中的一个了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-数据库四大特性&quot;&gt;&lt;a href=&quot;#1-数据库四大特性&quot; class=&quot;headerlink&quot; title=&quot;1.数据库四大特性&quot;&gt;&lt;/a&gt;1.数据库四大特性&lt;/h1&gt;&lt;h2 id=&quot;1-1原子性（Atomicity）&quot;&gt;&lt;a href=&quot;#1-1原子性（A
      
    
    </summary>
    
    
    
      <category term="数据库" scheme="https://dcghx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
