<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>酱油村的记事录</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-27T14:19:12.636Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>酱油君</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程—-—ThreadLocal</title>
    <link href="http://yoursite.com/2020/05/09/dxc-threadlocal/"/>
    <id>http://yoursite.com/2020/05/09/dxc-threadlocal/</id>
    <published>2020-05-09T03:15:26.000Z</published>
    <updated>2020-05-27T14:19:12.636Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p><p>用ThreadLocal声明的变量可以在线程内部提供变量副本，线程修改ThreadLocal声明的变量互不影响，这就不存在并发的情况了。<a id="more"></a></p><h1 id="1-ThreadLocal的基本使用"><a href="#1-ThreadLocal的基本使用" class="headerlink" title="1.ThreadLocal的基本使用"></a>1.ThreadLocal的基本使用</h1><p><img src="dxc-threadlocal.assets/image-20200509163209050.png" alt="image-20200509163209050"></p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public  class  ThreadLocalDemo  &#123;     </span><br><span class="line">  &#x2F;&#x2F; 初始化ThreadLocal的值————第一种方法：实现抽象方法  </span><br><span class="line">  &#x2F;&#x2F;   private static ThreadLocal threadLocal &#x3D; ThreadLocal.withInitial(new Supplier&lt;String&gt;() &#123;</span><br><span class="line">  &#x2F;&#x2F;        @Override  </span><br><span class="line">  &#x2F;&#x2F;        public String get() &#123;  </span><br><span class="line">  &#x2F;&#x2F;            return &quot;Initial value&quot;;  </span><br><span class="line">  &#x2F;&#x2F;        &#125;  </span><br><span class="line">  &#x2F;&#x2F;    &#125;);  </span><br><span class="line">    </span><br><span class="line">  &#x2F;&#x2F; 初始化ThreadLocal的值————第二种方法：使用Lambda表达式  </span><br><span class="line">  private  static  ThreadLocal  threadLocal  &#x3D; ThreadLocal.withInitial(() - &gt; &#123;</span><br><span class="line">    return  &quot;Initial value&quot;;</span><br><span class="line">  &#125;);       &#x2F;&#x2F; 初始化ThreadLocal的值————第三种方式重写initialValue()方法  </span><br><span class="line">  &#x2F;&#x2F;    private static ThreadLocal threadLocal &#x3D; new ThreadLocal()&#123;  </span><br><span class="line">  &#x2F;&#x2F;        @Override  </span><br><span class="line">  &#x2F;&#x2F;        protected Object initialValue() &#123;  </span><br><span class="line">  &#x2F;&#x2F;            return &quot;Initial value&quot;;  </span><br><span class="line">  &#x2F;&#x2F;        &#125;  </span><br><span class="line">  &#x2F;&#x2F;    &#125;;  </span><br><span class="line">        </span><br><span class="line">  public  static  void  main(String[]  args)  &#123;          </span><br><span class="line">    System.out.println(&quot;ThreadLocal的初始值：&quot;  +  threadLocal.get());          </span><br><span class="line">    threadLocal.set(&quot;Main方法&quot;);          </span><br><span class="line">    new  Thread(()  - &gt;  &#123;              </span><br><span class="line">      System.out.println(&quot;子线程获取ThreadLocal的值：&quot;  +  threadLocal.get());              </span><br><span class="line">      threadLocal.set(&quot;Thread线程&quot;);       </span><br><span class="line">      System.out.println(&quot;子线程执行set方法后，子线程获取ThreadLocal的值：&quot;  +  threadLocal.get());              </span><br><span class="line">      threadLocal.remove();    </span><br><span class="line">      System.out.println(&quot;子线程执行remove方法后，子线程获取ThreadLocal的值：&quot;  +  threadLocal.get());          </span><br><span class="line">    &#125;).start();     </span><br><span class="line">    System.out.println(&quot;主线程执行set方法后，主线程获取ThreadLocal的值：&quot;  +  threadLocal.get());          </span><br><span class="line">    threadLocal.remove();    </span><br><span class="line">    System.out.println(&quot;主线程执行remove方法后，主线程获取ThreadLocal的值：&quot;  +  threadLocal.get());      </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.ThreadLocal的初始值：Initial value  </span><br><span class="line">2.主线程执行set方法后，主线程获取ThreadLocal的值：Main方法  </span><br><span class="line">3.主线程执行remove方法后，主线程获取ThreadLocal的值：Initial value  </span><br><span class="line">4.子线程获取ThreadLocal的值：Initial value  </span><br><span class="line">5.子线程执行set方法后，子线程获取ThreadLocal的值：Thread线程  </span><br><span class="line">6.子线程执行remove方法后，子线程获取ThreadLocal的值：Initial value</span><br></pre></td></tr></table></figure><h1 id="2-ThreadLocal源码剖析"><a href="#2-ThreadLocal源码剖析" class="headerlink" title="2.ThreadLocal源码剖析"></a>2.ThreadLocal源码剖析</h1><p>先看下ThreadLocal类的类图：</p><p><img src="dxc-threadlocal.assets/image-20200509171236546.png" alt="image-20200509171236546"></p><p>可以看出ThreadLocal有两个静态内部类，分别是SuppliedThreadLocal和ThreadLocalMap。实际上，ThreadLocal 类的核心就是 ThreadLocalMap 这个内部类。当创建线程的时候，线程对象都会有 ThreadLocalMap 类型的成员变量。</p><p>*ThreadLocalMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line">2.static class ThreadLocalMap &#123;  </span><br><span class="line">3.  </span><br><span class="line">4.    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;  </span><br><span class="line">5.        Object value;  </span><br><span class="line">6.        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;  </span><br><span class="line">7.            super(k);  </span><br><span class="line">8.            value &#x3D; v;  </span><br><span class="line">9.        &#125;  </span><br><span class="line">10.    &#125;  </span><br><span class="line">11.  </span><br><span class="line">12.    &#x2F;&#x2F; Entry数组的初始容量  </span><br><span class="line">13.    private static final int INITIAL_CAPACITY &#x3D; 16;  </span><br><span class="line">14.  </span><br><span class="line">15.    &#x2F;&#x2F; ThreadLocalMap对象实际上由Entry数组记录ThreadLocal变量  </span><br><span class="line">16.    private Entry[] table;  </span><br><span class="line">17.  </span><br><span class="line">18.    &#x2F;&#x2F; Entry数组元素的个数  </span><br><span class="line">19.    private int size &#x3D; 0;  </span><br><span class="line">20.  </span><br><span class="line">21.    &#x2F;&#x2F; Entry扩容的阀值  </span><br><span class="line">22.    private int threshold;  </span><br><span class="line">23.  </span><br><span class="line">24.    &#x2F;&#x2F; 设置Entry数组的阀值，长度为 len 的 2&#x2F;3 倍  </span><br><span class="line">25.    private void setThreshold(int len) &#123;  </span><br><span class="line">26.        threshold &#x3D; len * 2 &#x2F; 3;  </span><br><span class="line">27.    &#125;  </span><br><span class="line">28.  </span><br><span class="line">29.    &#x2F;&#x2F; Entry数组的下一个索引  </span><br><span class="line">30.    private static int nextIndex(int i, int len) &#123;  </span><br><span class="line">31.        return ((i + 1 &lt; len) ? i + 1 : 0);  </span><br><span class="line">32.    &#125;  </span><br><span class="line">33.  </span><br><span class="line">34.    &#x2F;&#x2F; Entry数组的上一个索引  </span><br><span class="line">35.    private static int prevIndex(int i, int len) &#123;  </span><br><span class="line">36.        return ((i - 1 &gt;&#x3D; 0) ? i - 1 : len - 1);  </span><br><span class="line">37.    &#125;  </span><br><span class="line">38.  </span><br><span class="line">39.    &#x2F;&#x2F; 初始化ThreadLocalMap对象  </span><br><span class="line">40.    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;  </span><br><span class="line">41.        table &#x3D; new Entry[INITIAL_CAPACITY];  </span><br><span class="line">42.        int i &#x3D; firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);  </span><br><span class="line">43.        table[i] &#x3D; new Entry(firstKey, firstValue);&#x2F;&#x2F; 初始化Entry  </span><br><span class="line">44.        size &#x3D; 1;  </span><br><span class="line">45.        setThreshold(INITIAL_CAPACITY);  </span><br><span class="line">46.    &#125;  </span><br><span class="line">47.  </span><br><span class="line">48.    &#x2F;&#x2F; ThreadLocal.set()主要核心方法  </span><br><span class="line">49.    private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;  </span><br><span class="line">50.        Entry[] tab &#x3D; table;  </span><br><span class="line">51.        int len &#x3D; tab.length;  </span><br><span class="line">52.        int i &#x3D; key.threadLocalHashCode &amp; (len - 1);&#x2F;&#x2F; ThreadLocal对象经过哈希算法确定元素索引 i  </span><br><span class="line">53.  </span><br><span class="line">54.        &#x2F;&#x2F; 如果数组索引对应的Entry对象不是null，则进入for循环  </span><br><span class="line">55.        for (Entry e &#x3D; tab[i];  </span><br><span class="line">56.             e !&#x3D; null;  </span><br><span class="line">57.             e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;  </span><br><span class="line">58.            ThreadLocal&lt;?&gt; k &#x3D; e.get();  </span><br><span class="line">59.  </span><br><span class="line">60.            if (k &#x3D;&#x3D; key) &#123;  </span><br><span class="line">61.                e.value &#x3D; value;  </span><br><span class="line">62.                return;  </span><br><span class="line">63.            &#125;  </span><br><span class="line">64.  </span><br><span class="line">65.            &#x2F;&#x2F; 如果key为null则说明该entry已经失效，执行replaceStaleEntry替换掉  </span><br><span class="line">66.            if (k &#x3D;&#x3D; null) &#123;  </span><br><span class="line">67.                replaceStaleEntry(key, value, i);  </span><br><span class="line">68.                return;  </span><br><span class="line">69.            &#125;  </span><br><span class="line">70.        &#125;  </span><br><span class="line">71.        &#x2F;&#x2F; 向数组新增Entry对象元素  </span><br><span class="line">72.        tab[i] &#x3D; new Entry(key, value);  </span><br><span class="line">73.        int sz &#x3D; ++size;  </span><br><span class="line">74.        if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;&#x3D; threshold)&#x2F;&#x2F; 清除一些过期的值并且判断是否需要扩容  </span><br><span class="line">75.            rehash();  </span><br><span class="line">76.    &#125;  </span><br><span class="line">77.  </span><br><span class="line">78.&#x2F;&#x2F; 将新元素放进陈旧的元素  </span><br><span class="line">79.    private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,  </span><br><span class="line">80.                                   int staleSlot) &#123;  </span><br><span class="line">81.        Entry[] tab &#x3D; table;  </span><br><span class="line">82.        int len &#x3D; tab.length;  </span><br><span class="line">83.        Entry e;  </span><br><span class="line">84.  </span><br><span class="line">85.        int slotToExpunge &#x3D; staleSlot;  </span><br><span class="line">86.        &#x2F;&#x2F; 向前查找被弃用的索引  </span><br><span class="line">87.        for (int i &#x3D; prevIndex(staleSlot, len);  </span><br><span class="line">88.             (e &#x3D; tab[i]) !&#x3D; null;  </span><br><span class="line">89.             i &#x3D; prevIndex(i, len))  </span><br><span class="line">90.            if (e.get() &#x3D;&#x3D; null)  </span><br><span class="line">91.                slotToExpunge &#x3D; i;  </span><br><span class="line">92.  </span><br><span class="line">93.        &#x2F;&#x2F; 向后查找key或者value为null的元素  </span><br><span class="line">94.        for (int i &#x3D; nextIndex(staleSlot, len);  </span><br><span class="line">95.             (e &#x3D; tab[i]) !&#x3D; null;  </span><br><span class="line">96.             i &#x3D; nextIndex(i, len)) &#123;  </span><br><span class="line">97.            ThreadLocal&lt;?&gt; k &#x3D; e.get();  </span><br><span class="line">98.  </span><br><span class="line">99.            if (k &#x3D;&#x3D; key) &#123;  </span><br><span class="line">100.                e.value &#x3D; value;  </span><br><span class="line">101.  </span><br><span class="line">102.                tab[i] &#x3D; tab[staleSlot];  </span><br><span class="line">103.                tab[staleSlot] &#x3D; e;  </span><br><span class="line">104.  </span><br><span class="line">105.                &#x2F;&#x2F; 如果存在则清除被弃用的Entry对象  </span><br><span class="line">106.                if (slotToExpunge &#x3D;&#x3D; staleSlot)  </span><br><span class="line">107.                    slotToExpunge &#x3D; i;  </span><br><span class="line">108.                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);  </span><br><span class="line">109.                return;  </span><br><span class="line">110.            &#125;  </span><br><span class="line">111.  </span><br><span class="line">112.            if (k &#x3D;&#x3D; null &amp;&amp; slotToExpunge &#x3D;&#x3D; staleSlot)  </span><br><span class="line">113.                slotToExpunge &#x3D; i;  </span><br><span class="line">114.        &#125;  </span><br><span class="line">115.  </span><br><span class="line">116.        tab[staleSlot].value &#x3D; null;  </span><br><span class="line">117.        tab[staleSlot] &#x3D; new Entry(key, value);  </span><br><span class="line">118.  </span><br><span class="line">119.        &#x2F;&#x2F; 如果还有其它被弃用的Entry对象，执行cleanSomeSlots方法清除他们  </span><br><span class="line">120.        if (slotToExpunge !&#x3D; staleSlot)  </span><br><span class="line">121.            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);  </span><br><span class="line">122.    &#125;  </span><br><span class="line">123.  </span><br><span class="line">124.    &#x2F;&#x2F; 清除被弃用的元素  </span><br><span class="line">125.    private boolean cleanSomeSlots(int i, int n) &#123;  </span><br><span class="line">126.        boolean removed &#x3D; false;  </span><br><span class="line">127.        Entry[] tab &#x3D; table;  </span><br><span class="line">128.        int len &#x3D; tab.length;  </span><br><span class="line">129.        do &#123;  </span><br><span class="line">130.            i &#x3D; nextIndex(i, len);  </span><br><span class="line">131.            Entry e &#x3D; tab[i];  </span><br><span class="line">132.            if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; null) &#123;  </span><br><span class="line">133.                n &#x3D; len;  </span><br><span class="line">134.                removed &#x3D; true;  </span><br><span class="line">135.                i &#x3D; expungeStaleEntry(i);  </span><br><span class="line">136.            &#125;  </span><br><span class="line">137.        &#125; while ( (n &gt;&gt;&gt;&#x3D; 1) !&#x3D; 0);  </span><br><span class="line">138.        return removed;  </span><br><span class="line">139.    &#125;  </span><br><span class="line">140.  </span><br><span class="line">141.    &#x2F;&#x2F; 清除目标对象，并向后扫描清除被弃用的元素  </span><br><span class="line">142.    private int expungeStaleEntry(int staleSlot) &#123;  </span><br><span class="line">143.        Entry[] tab &#x3D; table;  </span><br><span class="line">144.        int len &#x3D; tab.length;  </span><br><span class="line">145.  </span><br><span class="line">146.        tab[staleSlot].value &#x3D; null;  </span><br><span class="line">147.        tab[staleSlot] &#x3D; null;  </span><br><span class="line">148.        size--;  </span><br><span class="line">149.  </span><br><span class="line">150.        Entry e;  </span><br><span class="line">151.        int i;  </span><br><span class="line">152.        for (i &#x3D; nextIndex(staleSlot, len);  </span><br><span class="line">153.             (e &#x3D; tab[i]) !&#x3D; null;  </span><br><span class="line">154.             i &#x3D; nextIndex(i, len)) &#123;  </span><br><span class="line">155.            ThreadLocal&lt;?&gt; k &#x3D; e.get();  </span><br><span class="line">156.            if (k &#x3D;&#x3D; null) &#123;  </span><br><span class="line">157.                e.value &#x3D; null;  </span><br><span class="line">158.                tab[i] &#x3D; null;  </span><br><span class="line">159.                size--;  </span><br><span class="line">160.            &#125; else &#123;  </span><br><span class="line">161.                int h &#x3D; k.threadLocalHashCode &amp; (len - 1);  </span><br><span class="line">162.                if (h !&#x3D; i) &#123;  </span><br><span class="line">163.                    tab[i] &#x3D; null;  </span><br><span class="line">164.  </span><br><span class="line">165.                    while (tab[h] !&#x3D; null)  </span><br><span class="line">166.                        h &#x3D; nextIndex(h, len);  </span><br><span class="line">167.                    tab[h] &#x3D; e;  </span><br><span class="line">168.                &#125;  </span><br><span class="line">169.            &#125;  </span><br><span class="line">170.        &#125;  </span><br><span class="line">171.        return i;  </span><br><span class="line">172.    &#125;  </span><br><span class="line">173.  </span><br><span class="line">174.    &#x2F;&#x2F; 清除弃用元素并判断是否需要扩容  </span><br><span class="line">175.    private void rehash() &#123;  </span><br><span class="line">176.        expungeStaleEntries();  </span><br><span class="line">177.        if (size &gt;&#x3D; threshold - threshold &#x2F; 4)  </span><br><span class="line">178.            resize();  </span><br><span class="line">179.    &#125;  </span><br><span class="line">180.  </span><br><span class="line">181.    &#x2F;&#x2F; 扩容  </span><br><span class="line">182.    private void resize() &#123;  </span><br><span class="line">183.        Entry[] oldTab &#x3D; table;  </span><br><span class="line">184.        int oldLen &#x3D; oldTab.length;  </span><br><span class="line">185.        int newLen &#x3D; oldLen * 2;  </span><br><span class="line">186.        Entry[] newTab &#x3D; new Entry[newLen];  </span><br><span class="line">187.        int count &#x3D; 0;  </span><br><span class="line">188.  </span><br><span class="line">189.        for (int j &#x3D; 0; j &lt; oldLen; ++j) &#123;  </span><br><span class="line">190.            Entry e &#x3D; oldTab[j];  </span><br><span class="line">191.            if (e !&#x3D; null) &#123;  </span><br><span class="line">192.                ThreadLocal&lt;?&gt; k &#x3D; e.get();  </span><br><span class="line">193.                if (k &#x3D;&#x3D; null) &#123;  </span><br><span class="line">194.                    e.value &#x3D; null; &#x2F;&#x2F; Help the GC  </span><br><span class="line">195.                &#125; else &#123;  </span><br><span class="line">196.                    int h &#x3D; k.threadLocalHashCode &amp; (newLen - 1);  </span><br><span class="line">197.                    while (newTab[h] !&#x3D; null)  </span><br><span class="line">198.                        h &#x3D; nextIndex(h, newLen);  </span><br><span class="line">199.                    newTab[h] &#x3D; e;  </span><br><span class="line">200.                    count++;  </span><br><span class="line">201.                &#125;  </span><br><span class="line">202.            &#125;  </span><br><span class="line">203.        &#125;  </span><br><span class="line">204.  </span><br><span class="line">205.        setThreshold(newLen);  </span><br><span class="line">206.        size &#x3D; count;  </span><br><span class="line">207.        table &#x3D; newTab;  </span><br><span class="line">208.    &#125;  </span><br><span class="line">209.  </span><br><span class="line">210.    &#x2F;&#x2F; 清空被弃用的元素  </span><br><span class="line">211.    private void expungeStaleEntries() &#123;  </span><br><span class="line">212.        Entry[] tab &#x3D; table;  </span><br><span class="line">213.        int len &#x3D; tab.length;  </span><br><span class="line">214.        for (int j &#x3D; 0; j &lt; len; j++) &#123;  </span><br><span class="line">215.            Entry e &#x3D; tab[j];  </span><br><span class="line">216.            if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; null)  </span><br><span class="line">217.                expungeStaleEntry(j);  </span><br><span class="line">218.        &#125;  </span><br><span class="line">219.    &#125;  </span><br><span class="line">220.&#125;</span><br></pre></td></tr></table></figure><p>可以看到ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。</p><p>至此，可能大部分朋友已经明白了ThreadLocal是如何为每个线程创建变量的副本的：</p><p>首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。</p><p>实际上，ThreadLocalMap是一个数组，而数组内的元素都是由key和value组成的Entry对象。ThreadLocalMap的key就是经过哈希算法计算出来的ThreadLocal对象。神奇的是，ThreadLocal的哈希算法可以保证只要在ThreadLocalMap数组长度为2的 N 次方的时候，哈希值能平均的分布,避免键冲突。</p><h1 id="3-看一下set方法"><a href="#3-看一下set方法" class="headerlink" title="3.看一下set方法"></a>3.看一下set方法</h1><p><img src="dxc-threadlocal.assets/image-20200509171657703.png" alt="image-20200509171657703"></p><p>1) 获取当前线程对象</p><p>2) 以当前线程对象为参数获取，当前Thread对象中的ThreadLocalMap对象</p><p>3) 判断当前Thread对象中的ThreadLocalMap对象是否为null</p><p><em>*为null：为当前线程对象的ThreadLocalMaps成员变量初始化，并赋值</em></p><p><img src="dxc-threadlocal.assets/image-20200509171752156.png" alt="image-20200509171752156"></p><p>构造方法中会将val生成Entry对象存入Entry数组（索引为ThreadLocal对象内存地址哈希计算所得）</p><p><em>*不为null：调用ThreadLocalMap的set方法进行赋值</em></p><p><img src="dxc-threadlocal.assets/image-20200509171833410.png" alt="image-20200509171833410"></p><p>在ThreadLocalMap的set方法中，将传递来的参数ThreadLocal对象的地址值进行哈希计算出索引值，创建Val的Entry对象，将值插入所计算得出Entry数组的索引位置</p><h1 id="4-看一下get方法"><a href="#4-看一下get方法" class="headerlink" title="4.看一下get方法"></a>4.看一下get方法</h1><p><img src="dxc-threadlocal.assets/image-20200509171930269.png" alt="image-20200509171930269"></p><p>1) 获取当前线程对象</p><p>2) 以当前线程对象为参数获取，当前Thread对象中的ThreadLocalMap对象</p><p>3) 判断当前Thread对象中的ThreadLocalMap对象是否为null</p><p><em>*为null：进入初始化方法：创建ThrealocalMap，赋初始值</em></p><p><img src="dxc-threadlocal.assets/image-20200509172040768.png" alt="image-20200509172040768"></p><p><em>*不为null：调用ThrealocalMap的getEntry方法获取Entry对象，参数ThreadLocal对象</em></p><p><img src="dxc-threadlocal.assets/image-20200509172110335.png" alt="image-20200509172110335"></p><p>根据ThreadLocal对象的内存地址哈希计算得出指定ThreadLocal对象的值在Entry数据的存储索引，获取Entry对象进而获取值</p><h1 id="领悟："><a href="#领悟：" class="headerlink" title="领悟："></a>领悟：</h1><p>我们可以看出一个Thread对象的ThreadLocalMap成员变量是属于该线程对象的，所以ThreadLocalMap对象中的Entry数组也是属于该线程的，Entry数组索引由ThreadLocal对象内存哈希计算得出，元素为值封装的Entry对象，ThreadLocal对象的init***、get、set方法调用是加载ThreadLocal对象到Entry数组的时机，所以ThreadLocal对象用static修饰完全没有问题，因为每个线程对象的ThreadLocalMap对象是不同的，同时也只是取ThreadLocal对象的内存地址计算作为数组的索引</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。&lt;/p&gt;
&lt;p&gt;用ThreadLocal声明的变量可以在线程内部提供变量副本，线程修改ThreadLocal声明的变量互不影响，这就不存在并发的情况了。
    
    </summary>
    
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程(1)</title>
    <link href="http://yoursite.com/2020/05/09/dxc-msg/"/>
    <id>http://yoursite.com/2020/05/09/dxc-msg/</id>
    <published>2020-05-09T03:15:26.000Z</published>
    <updated>2020-05-27T16:16:58.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-线程"><a href="#1-线程" class="headerlink" title="1.线程"></a>1.线程</h1><p>线程:程序执行流的最小单元【可以理解为：进程中独立运行的子任务】。<br>多线程优点:最大限度的利用CPU的空闲时间来处理其他任务。<a id="more"></a></p><h2 id="1-1线程创建方式"><a href="#1-1线程创建方式" class="headerlink" title="1.1线程创建方式"></a>1.1线程创建方式</h2><p>继承Thread类</p><p><img src="dxc-msg.assets/image-20200528001244377.png" alt="image-20200528001244377"></p><p>实现Runable接口</p><p><img src="dxc-msg.assets/image-20200528001259400.png" alt="image-20200528001259400"></p><h2 id="1-2线程停止thread-interrupt-、thread-stop"><a href="#1-2线程停止thread-interrupt-、thread-stop" class="headerlink" title="1.2线程停止thread.interrupt()、thread.stop()"></a>1.2线程停止thread.interrupt()、thread.stop()</h2><p>在Thread类中,提供了stop(),suspend()和resume()方法,这三个方法分别是用来结束,暂停,恢复线程. 但是都已经被标记为@Deprecated废弃了. 因为一个线程不应该由其他线程来结束,他应该收到别人的通知,然后自己在合适的位置结束,如果不合理的结束,会导致很多意外的结果,比如临界区还没完全操作完,提前释放锁,但是部分状态已经改变,还有没有做一些清理操作等等.</p><p>基于上面的理由,Java提供了新的中断机制(interrupt),其他线程调用想要终止线程的interrupt()方法. 这个时候线程会根据自己的状态做出响应:</p><ul><li><p>如果线程处于阻塞状态(sleep,wait,join),则线程会抛出InterruptedException异常.</p></li><li><p>如果线程处于正常运行状态,则还是正常运行,但是中断的标志被设置为true,相当于有人通知 你该结束自己了.</p></li></ul><p>被调用线程处于阻塞状态时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">    Thread thread &#x3D; new Thread() &#123;  </span><br><span class="line">        @Override  </span><br><span class="line">        public void run() &#123;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                &#x2F;&#x2F; 被调线程阻塞自己30s  </span><br><span class="line">                sleep(30000);  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        &#x2F;&#x2F; 启动线程  </span><br><span class="line">        thread.start();  </span><br><span class="line">        &#x2F;&#x2F; 主线程阻塞自己3秒  </span><br><span class="line">        TimeUnit.SECONDS.sleep(3);  </span><br><span class="line">        &#x2F;&#x2F; 中断线程  </span><br><span class="line">        thread.interrupt();  </span><br><span class="line">    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F; ↓ out ↓  </span><br><span class="line">&#x2F;&#x2F; java.lang.InterruptedException: sleep interrupted  </span><br><span class="line">&#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure><p>被调用线程处于正常运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">    Thread thread &#x3D; new Thread() &#123;  </span><br><span class="line">        @Override  </span><br><span class="line">        public void run() &#123;  </span><br><span class="line">            while (!Thread.interrupted()) &#123;  </span><br><span class="line">                System.out.println(&quot;我还稳得住...&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        thread.start();  </span><br><span class="line">        TimeUnit.SECONDS.sleep(3);  </span><br><span class="line">        thread.interrupt();  </span><br><span class="line">    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; ↓ out ↓  </span><br><span class="line">&#x2F;&#x2F; 我能稳得住  </span><br><span class="line">&#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure><p>该程序会在检测interrupt标志,如果发现interrupt标志设置为true,则会结束自己.</p><p><code>interrupted()和isInterrupt()的区别</code></p><p>区别: 是否会清除interrupt标志. isInterrupt()方法不会改变标志,而interrupted()方法会在检测的同时,如果发现标志为true,则会返回true,然后把标志置为false.</p><h2 id="1-3-线程优先级"><a href="#1-3-线程优先级" class="headerlink" title="1.3 线程优先级"></a>1.3 线程优先级</h2><p>线程优先级范围为1-10，API提供等级分为：低（MIN_PRIORITY = 1)，中（NORM_PRIORITY=5），高（MAX_PRIORITY=10）。<br>线程优先级有以下特点：</p><ul><li><p>继承特性【线程A中启动线程B，线程B继承了A的优先级】；</p></li><li><p>随机性【线程调度的顺序不一定是根据优先级，具有随机性】；</p></li></ul><h2 id="1-4-守护线程"><a href="#1-4-守护线程" class="headerlink" title="1.4 守护线程"></a>1.4 守护线程</h2><p>Java 中有两种线程： 一种是用户线程（User Thread），一种是守护线程（Daemon Thread）。</p><p>守护线程是一种特殊的线程， 它的特殊有“陪伴”的含义， 当线程中不存在非守护线程时， 则守护线程自动销毁。</p><p><img src="dxc-msg.assets/image-20200528001322500.png" alt="image-20200528001322500"></p><p><img src="dxc-msg.assets/image-20200528001338666.png" alt="image-20200528001338666"></p><p>从上图可以看出，主线程停止DaemonThread线程也相应的停止了，但不是立即停止。</p><h2 id="1-5-线程让步yield"><a href="#1-5-线程让步yield" class="headerlink" title="1.5 线程让步yield()"></a>1.5 线程让步yield()</h2><p>线程让步【yield方法】让当前线程释放CPU资源，让其他线程抢占。</p><p><img src="dxc-msg.assets/image-20200528001353721.png" alt="image-20200528001353721"></p><p><img src="dxc-msg.assets/image-20200528001405158.png" alt="image-20200528001405158"></p><p>从以上两图可以看出，线程的让步操作比不让步耗时长。</p><h2 id="1-5线程状态、以及-sheep（）、wait-、yield-的区别"><a href="#1-5线程状态、以及-sheep（）、wait-、yield-的区别" class="headerlink" title="1.5线程状态、以及 sheep（）、wait()、yield() 的区别"></a>1.5线程状态、以及 sheep（）、wait()、yield() 的区别</h2><p><img src="dxc-msg.assets/image-20200528001421752.png" alt="image-20200528001421752"></p><p><img src="dxc-msg.assets/image-20200528001433396.png" alt="image-20200528001433396"></p><p>线程包括五种状态</p><ol><li><p>新建、初始状态（New） ：线程对象被创建后就进入了新建状态，Thread thread = new Thread();</p></li><li><p>就绪（Runnable）：也被称之为“可执行状态”，当线程被new出来后，其他的线程调用了该对象的start()方法，即thread.start()，此时线程位于“可运行线程池”中，只等待获取CPU的使用权，随时可以被CPU调用。进入就绪状态的线程除CPU之外，其他运行所需的资源都已经全部获得。</p></li><li><p>运行（Running）：线程获取CPU权限开始执行。注意：线程只能从就绪状态进入到运行状态。</p></li><li><p>阻塞（Bloacked）：阻塞状态是线程因为某种原因放弃CPU的使用权，暂时停止运行，直到线程进入就绪状态后才能有机会转到运行状态。阻塞的情况分三种：</p></li></ol><ul><li><p>a.  等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池中”。进入这个状态后是不能自动唤醒的，必须依靠其他线程调用notify()或者notifyAll()方法才能被唤醒。</p></li><li><p>b. 同步阻塞：运行的线程在获取对象的（synchronized）同步锁时，若该同步锁被其他线程占用，则JVM会吧该线程放入“锁池”中。</p></li><li><p>c. 其他阻塞：通过调用线程的sleep()或者join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新回到就绪状态</p></li></ul><ol start="5"><li>死亡（Dead）：线程执行完了或因异常退出了run()方法，则该线程结束生命周期。</li></ol><p><em>wait(), notify(), notifyAll()等方法介绍</em></p><p>这三个方法都是定义到Object类中，wait的作用是当当前线程释放它所持有的锁进入等待状态，而notify和notifyAll则是唤醒当前对象上的等待线程。</p><ul><li>notify() —— 唤醒在此对象监视器上等待的单个线程。</li><li>notifyAll() —— 唤醒在此对象监视器上等待的所有线程。</li><li>wait() —— 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。</li><li>wait(long timeout) —— 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。</li><li>wait(long timeout, int nanos) —— 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。</li><li>wait()会使“当前线程”等待，并且会释放到它所占用的“锁标志”，从而使线程所在对象中的其他synchronized数据可以被其他线程使用。</li></ul><p>waite()和notify()因为会对对象的“锁标志”进行操作，所以它们必须在synchronized函数或synchronizedblock中进行调用。如果在non-synchronized函数或non-synchronizedblock中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。</p><p>负责唤醒等待线程的那个线程(我们称为“唤醒线程”)，它只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p><h2 id="1-6-suspend-和-resume-方法"><a href="#1-6-suspend-和-resume-方法" class="headerlink" title="1.6 suspend()和 resume()方法"></a>1.6 suspend()和 resume()方法</h2><p>两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume()被调用，才能使得线程重新进入可执行状态。典型地，suspend()和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume()使其恢复。</p><p>注意区别：</p><p>初看起来wait() 和 notify() 方法与suspend()和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的suspend()及其它所有方法在线程阻塞时都不会释放占用的锁（如果占用了的话），而wait() 和 notify() 这一对方法则相反。</p><h2 id="1-7-sleep-和-yield-方法"><a href="#1-7-sleep-和-yield-方法" class="headerlink" title="1.7 sleep() 和 yield()方法"></a>1.7 sleep() 和 yield()方法</h2><p>这两个方法都定义在Thread.java中</p><p>sleep()的作用是让当前线程休眠（正在执行的线程主动让出cpu，然后cpu就可以去执行其他任务），即当前线程会从“运行状态”进入到“休眠（阻塞）状态”。sleep()会指定休眠时间，线程休眠的时候会大于或者等于该休眠时间，当时间过后该线程重新被会唤醒，他会由“阻塞状态”编程“就绪状态”，从而等待cpu的调度执行，注意：sleep方法只是让出了cpu的执行权，并不会释放同步资源锁。</p><p>yield()的作用是让步，它能够让当前线程从“运行状态”进入到“就绪状态”，从而让其他等待线程获取执行权，但是不能保证在当前线程调用yield()之后，其他线程就一定能获得执行权，也有可能是当前线程又回到“运行状态”继续运行，注意：这里我将上面的“具有相同优先级”的线程直接改为了线程，很多资料都写的是让具有相同优先级的线程开始竞争，但其实不是这样的，优先级低的线程在拿到cpu执行权后也是可以执行，只不过优先级高的线程拿到cpu执行权的概率比较大而已，并不是一定能拿到。</p><p>举个例子：一帮朋友在排队上公交车，轮到Yield的时候，他突然说：我不想先上去了，咱们大家来竞赛上公交车。然后所有人就一块冲向公交车，有可能是其他人先上车了，也有可能是Yield先上车了。但是线程是有优先级的，优先级越高的人，就一定能第一个上车吗？这是不一定的，优先级高的人仅仅只是第一个上车的概率大了一点而已，最终第一个上车的，也有可能是优先级最低的人。并且所谓的优先级执行，是在大量执行次数中才能体现出来的。</p><h2 id="1-8-wait和sleep的区别"><a href="#1-8-wait和sleep的区别" class="headerlink" title="1.8 wait和sleep的区别"></a>1.8 wait和sleep的区别</h2><p>相同点：</p><ul><li>他们都是在多线程的环境下，都可以在程序的调用出阻塞指定的毫秒数并且返回</li><li>两个方法都可以通过interrupt()方法打断线程的暂停状态，但是线程会抛出InterruptedException。需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。 </li></ul><p>不同点：</p><ul><li>Thread类的方法：sleep(),yield()，Object的方法：wait()和notify()、notifyAll()</li><li>每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。 sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 </li><li>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 。注意：wiat()必须放在synchronized block中，否则会在program runtime时扔出“java.lang.IllegalMonitorStateException”异常。</li><li>sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常</li></ul><p>综上可得两者最大的区别：sleep()睡眠时，保持对象锁，仍然占有该锁；而wait()睡眠时，释放对象锁。</p><p>注意：</p><p>第一：调用notify() 方法导致解除阻塞的线程是从因调用该对象的 wait()方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</p><p>第二：除了notify()，还有一个方法 notifyAll()也可起到类似作用，唯一的区别在于，调用 notifyAll()方法将把因调用该对象的 wait()方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</p><p>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend()方法和不指定超时期限的wait()方法的调用都可能产生死锁。遗憾的是，Java并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。</p><h2 id="1-9-join"><a href="#1-9-join" class="headerlink" title="1.9 join()"></a>1.9 join()</h2><p>join()方法能让其他线程从运行状态变为阻塞状态，直到当前线程执行完成后，其他线程才会执行。起初我对这句话理解是有误的，还好及时更正了过来。看下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Test implements Runnable &#123;  </span><br><span class="line">    private String threadName;  </span><br><span class="line">   </span><br><span class="line">    public Test(String threadName) &#123;  </span><br><span class="line">        this.threadName &#x3D; threadName;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 1000; i++) &#123;  </span><br><span class="line">            System.out.println(threadName + i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Test test1 &#x3D; new Test(&quot;线程1*&quot;);  </span><br><span class="line">        Test test2 &#x3D; new Test(&quot;线程2$&quot;);  </span><br><span class="line">        Thread thread1 &#x3D; new Thread(test1);  </span><br><span class="line">        Thread thread2 &#x3D; new Thread(test2);  </span><br><span class="line">        thread1.start();  </span><br><span class="line">        thread2.start();  </span><br><span class="line">        try &#123;  </span><br><span class="line">            thread2.join();  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我预想的结果是线程1先启动，然后执行一部分，线程2启动了，然后调用了join方法，此时线程1等待线程2执行完成后继续执行剩余部分。但是上面程序运行的结果是两个线程交替执行，并没有出现线程1等待线程2的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. public static void main(String[] args) &#123;  </span><br><span class="line">2.        Test test1 &#x3D; new Test(&quot;线程1*&quot;);  </span><br><span class="line">3.        Test test2 &#x3D; new Test(&quot;线程2$&quot;);  </span><br><span class="line">4.        Thread thread1 &#x3D; new Thread(test1);  </span><br><span class="line">5.        Thread thread2 &#x3D; new Thread(test2);  </span><br><span class="line">6.        thread2.start();  </span><br><span class="line">7.        try &#123;  </span><br><span class="line">8.            thread2.join();  </span><br><span class="line">9.        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">10.            e.printStackTrace();  </span><br><span class="line">11.        &#125;  </span><br><span class="line">12.        thread1.start();  </span><br><span class="line">13.    &#125;</span><br></pre></td></tr></table></figure><p>这次并没有出现线程1和线程2交替执行的情况。所以join方法应该这么解释：</p><p>A.join()方法之后的线程（包括主线程）会等待A线程执行结束后再执行，A线程之前的线程并不会等待A执行后再执行，而是交替执行</p><h2 id="1-10-用户线程、守护线程"><a href="#1-10-用户线程、守护线程" class="headerlink" title="1.10 用户线程、守护线程"></a>1.10 用户线程、守护线程</h2><p>在Java中有两类线程：用户线程 (User Thread)、守护线程 (Daemon Thread)。</p><p>守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。</p><p>守护线程是个服务线程，准确地来说就是服务其他的线程，这是它的作用——而其他的线程只有一种，那就是用户线程</p><p>二者其实基本上是一样的。唯一的区别在于JVM何时离开。</p><ul><li>用户线程：当存在任何一个用户线程未离开，JVM是不会离开的。就是应用程序里的自定义线程</li><li>守护线程：如果只剩下守护线程未离开，JVM是可以离开的。在JVM中，像垃圾收集器线程就是守护线程。</li></ul><p>用户线程创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                System.out.println(&quot;3.我是通过匿名内部类方式启动的线程&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;).start();</span><br></pre></td></tr></table></figure><p>守护线程创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class DamomThread &#123;  </span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        Thread thread &#x3D; new Thread( ()-&gt; &#123;  </span><br><span class="line">            while (true)&#123;  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    Thread.sleep(1000);  </span><br><span class="line">                    System.out.println(&quot;内部线程：正在执行。。。。&quot;);  </span><br><span class="line">                &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">   </span><br><span class="line">            &#125;  </span><br><span class="line">   </span><br><span class="line">        &#125;  ) ;  </span><br><span class="line">   </span><br><span class="line">        &#x2F;&#x2F;开启守护进程  </span><br><span class="line">        &#x2F;&#x2F;thread.setDaemon(true);  </span><br><span class="line">  </span><br><span class="line">        thread.start();  </span><br><span class="line">        Thread.sleep(2_000L );  </span><br><span class="line">        System.out.println(&quot;Main thread finished lifecycle !!!!!!!!!!&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码一共开启了两个线程，一个是main线程，另一个是里面执行的线程thread</p><p>未开始守护进程： thread.setDaemon(false);</p><p>外面的线程main线程，结束退出，里面的线程，依旧继续执行</p><p><img src="dxc-msg.assets/image-20200528001512362.png" alt="image-20200528001512362"></p><p>开始守护进程： thread.setDaemon(true)。main线程退出，内部线程一起退出。</p><p><img src="dxc-msg.assets/image-20200528001522567.png" alt="image-20200528001522567"></p><h2 id="1-11-锁"><a href="#1-11-锁" class="headerlink" title="1.11 锁"></a>1.11 锁</h2><p>锁有四种类型</p><ul><li>可重入锁：在执行对象中所有同步方法不用再次获得锁</li><li>可中断锁：在等待获取锁过程中可中断</li><li>公平锁： 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利</li><li>读写锁：对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写</li></ul><h3 id="1-11-1-synchronized"><a href="#1-11-1-synchronized" class="headerlink" title="1.11.1 synchronized"></a>1.11.1 synchronized</h3><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： </p><ol><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li><li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li><li>修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li><li>修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。</li></ol><ul><li>修饰代码块（注意锁对象this）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class SyncThread implements Runnable &#123;  </span><br><span class="line">        private static int count;  </span><br><span class="line">        public SyncThread() &#123;count &#x3D; 0;&#125;  </span><br><span class="line">        public void run() &#123;  </span><br><span class="line">            synchronized(this) &#123;  </span><br><span class="line">                for (int i &#x3D; 0; i &lt; 5; i++) &#123;  </span><br><span class="line">                    try &#123;  </span><br><span class="line">         System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));</span><br><span class="line">                        Thread.sleep(100);  </span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                        e.printStackTrace();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        public int getCount() &#123;  </span><br><span class="line">            return count;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SyncThread的调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.SyncThread syncThread &#x3D; new SyncThread();  </span><br><span class="line">2.Thread thread1 &#x3D; new Thread(syncThread, &quot;SyncThread1&quot;);  </span><br><span class="line">3.Thread thread2 &#x3D; new Thread(syncThread, &quot;SyncThread2&quot;);  </span><br><span class="line">4.thread1.start();  </span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure><p>使用synchronized修饰输出结果：</p><p><img src="dxc-msg.assets/image-20200528001548809.png" alt="image-20200528001548809"></p><p>取消synvhronized修饰的输出结果</p><p><img src="dxc-msg.assets/image-20200528001627365.png" alt="image-20200528001627365"></p><p>当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。Thread1和thread2是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。</p><p>我们把上方测试类稍加修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Thread thread1 &#x3D; new Thread(new SyncThread(), &quot;SyncThread1&quot;);  </span><br><span class="line">2.Thread thread2 &#x3D; new Thread(new SyncThread(), &quot;SyncThread2&quot;);  </span><br><span class="line">3.thread1.start();  </span><br><span class="line">4.thread2.start();</span><br></pre></td></tr></table></figure><p>这时创建了两个SyncThread的对象syncThread1和syncThread2，线程thread1执行的是syncThread1对象中的synchronized代码(run)，而线程thread2执行的是syncThread2对象中的synchronized代码(run)；我们知道synchronized锁定的是对象，这时会有两把锁分别锁定syncThread1对象和syncThread2对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。</p><p>当一个线程访问对象的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该对象中的非synchronized(this)同步代码块。一个线程访问一个对象的synchronized代码块时，别的线程可以访问该对象的非synchronized代码块而不受阻塞。</p><ul><li>修饰方法</li></ul><p>Synchronized修饰一个方法很简单，就是在方法的前面加synchronized，synchronized修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。</p><p>写法一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.public synchronized void method() &#123;  </span><br><span class="line">2.&#x2F;&#x2F; todo  </span><br><span class="line">3.&#125;</span><br></pre></td></tr></table></figure><p>写法二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.public void method() &#123;  </span><br><span class="line">2.    synchronized(this) &#123;  </span><br><span class="line">3.&#x2F;&#x2F; todo  </span><br><span class="line">4.    &#125;  </span><br><span class="line">5.&#125;</span><br></pre></td></tr></table></figure><p>在用synchronized修饰方法时要注意以下几点： </p><ol><li>synchronized关键字不能继承。 </li></ol><p>虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。</p><ol><li>在定义接口方法时不能使用synchronized关键字</li><li>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。</li></ol><ul><li>修饰静态方法</li></ul><p>我们知道静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class SyncThread implements Runnable &#123;  </span><br><span class="line">        private static int count;  </span><br><span class="line">  </span><br><span class="line">        public SyncThread() &#123;  </span><br><span class="line">            count &#x3D; 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public synchronized static void method() &#123;  </span><br><span class="line">            for (int i &#x3D; 0; i &lt; 5; i ++) &#123;  </span><br><span class="line">                try &#123;  </span><br><span class="line">         System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));</span><br><span class="line">                    Thread.sleep(100);  </span><br><span class="line">                &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public synchronized void run() &#123;  </span><br><span class="line">            method();  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.SyncThread syncThread1 &#x3D; new SyncThread();  </span><br><span class="line">2.SyncThread syncThread2 &#x3D; new SyncThread();  </span><br><span class="line">3.Thread thread1 &#x3D; new Thread(syncThread1, &quot;SyncThread1&quot;);  </span><br><span class="line">4.Thread thread2 &#x3D; new Thread(syncThread2, &quot;SyncThread2&quot;);  </span><br><span class="line">5.thread1.start();  </span><br><span class="line">6.thread2.start();</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.SyncThread1:0   </span><br><span class="line">2.SyncThread1:1   </span><br><span class="line">3.SyncThread1:2   </span><br><span class="line">4.SyncThread1:3   </span><br><span class="line">5.SyncThread1:4   </span><br><span class="line">6.SyncThread2:5   </span><br><span class="line">7.SyncThread2:6   </span><br><span class="line">8.SyncThread2:7   </span><br><span class="line">9.SyncThread2:8   </span><br><span class="line">SyncThread2:9</span><br></pre></td></tr></table></figure><p>syncThread1和syncThread2是SyncThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁。这与使用关键字synchronized运行结果相同</p><ul><li>修饰一个类（注意锁对象是类calss对象）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class SyncThread implements Runnable &#123;  </span><br><span class="line">        private static int count;  </span><br><span class="line">        public SyncThread() &#123;count &#x3D; 0;&#125;  </span><br><span class="line">  </span><br><span class="line">        public static void method() &#123;  </span><br><span class="line">            synchronized(SyncThread.class) &#123;  </span><br><span class="line">                for (int i &#x3D; 0; i &lt; 5; i ++) &#123;  </span><br><span class="line">                    try &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++)); </span><br><span class="line">                        Thread.sleep(100);  </span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                        e.printStackTrace();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;    </span><br><span class="line">        public synchronized void run() &#123;  </span><br><span class="line">            method();  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SyncThread syncThread1 &#x3D; new SyncThread();  </span><br><span class="line">SyncThread syncThread2 &#x3D; new SyncThread();  </span><br><span class="line">Thread thread1 &#x3D; new Thread(syncThread1, &quot;SyncThread1&quot;);  </span><br><span class="line">Thread thread2 &#x3D; new Thread(syncThread2, &quot;SyncThread2&quot;);  </span><br><span class="line">thread1.start();  </span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">11.SyncThread1:0   </span><br><span class="line">12.SyncThread1:1   </span><br><span class="line">13.SyncThread1:2   </span><br><span class="line">14.SyncThread1:3   </span><br><span class="line">15.SyncThread1:4   </span><br><span class="line">16.SyncThread2:5   </span><br><span class="line">17.SyncThread2:6   </span><br><span class="line">18.SyncThread2:7   </span><br><span class="line">19.SyncThread2:8   </span><br><span class="line">SyncThread2:9</span><br></pre></td></tr></table></figure><p>效果和上面synchronized修饰静态方法是一样的，synchronized作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁。</p><ul><li>重点知识—— wait() notify() notifyAll()的正确使用</li></ul><p>基于使用 synchronized 锁，JVM都会为锁对象维护两个集合，你必须知道的两个概念：</p><ol><li>Entry Set(别名锁池)：线程获取对象锁失败，则会进入这个对象的锁池。(若线程A获取了对象锁，那么线程B再来获取这个对象锁，必定失败，B线程则会进入锁池)</li><li>Wait Set(别名等待池)：线程获取锁后，调用了wait方法，那么就会进入这个对象的等待池。（若线程A获取了对象锁，那么线程A调用了wait方法，A会释放锁，然后进入等待池）</li></ol><p>这三个方法必须放在synchronized代码块或者方法块中使用，否则会抛出java.lang.IllegalMonitorStateException 异常</p><ol><li>wait：调用这个方法，线程就会释放锁，然后进入等待池，必须等待别的线程唤醒自己。     </li><li>notify：调用这个方法，则会随机唤醒等待池中的一个线程。Note：被唤醒的线程不会立马执行，它只是从blocked -&gt; runnable状态，形象的说是这个被唤醒的线程从等待池中进入到锁池，锁池中的线程会去竞争该对象锁，获取到了才能执行</li><li>notifyAll：唤醒等待池中的所有线程，这是和 notify 唯一的区别</li></ol><p>再来看两个常被提到的问题：</p><ol><li>wait 要放在while里面循环，不要放在if语句中，否则不安全，可能出现死锁。</li><li>唤醒最好调用notifyAll，不要使用notify，否者不安全，可能出现死锁。</li></ol><p>这两个说法并没有错，但是前提是多生产者和多消费者的情况下才是完全正确，但是如是一个生产者线程和一个消费者线程，那么问题1中也是可以使用if语句的，2中也是可以使用notify。</p><p>^ 多消费者-多生产者下为什么不要在if语句里面使用wait()？</p><p>如果只有一个生产者线程，一个消费者线程，那其实是可以用if代替while的，因为线程调度的行为是开发者可以预测的，生产者线程只有可能被消费者线程唤醒，反之亦然，因此被唤醒时条件始终满足，程序不会出错。</p><p>但是在多消费者-多生产者下，wait()的线程永远不能确定其他线程会在什么状态下notify()，所以必须在被唤醒、抢占到锁并且从wait()方法退出的时候再次进行指定条件的判断，以决定是满足条件往下执行呢还是不满足条件再次wait()</p><p>^ 多消费者-多生产者下为什么要用notifyAll？</p><p>两个生产者两个消费者的场景，如果我们代码中使用了notify()而非notifyAll()，假设消费者线程1拿到了锁，判断资源为空，那么wait()，释放锁；然后消费者2拿到了锁，同样资源为空，wait()，也就是说此时Wait Set中有两个线程；然后生产者1拿到锁，生产，有资源了，notify()了，那么可能消费者1被唤醒了，但是此时还有另一个线程生产者2在Entry Set中盼望着锁，并且最终抢占到了锁，但因为此时资源是有的，因此它要wait()；然后消费者1拿到了锁，消费，notify()；这时就有问题了，此时生产者2和消费者2都在Wait Set中，资源为空，如果唤醒生产者2，没毛病；但如果唤醒了消费者2，因为资源为空，它会再次wait()，这就尴尬了，万一生产者1已经退出不再生产了，没有其他线程在竞争锁了，只有生产者2和消费者2在Wait Set中互相等待，那传说中的死锁就发生了。</p><h3 id="1-11-2-lock"><a href="#1-11-2-lock" class="headerlink" title="1.11.2 lock"></a>1.11.2 lock</h3><p>synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？</p><p>在上面一篇文章中，我们了解到如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p><ul><li>获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</li><li>线程执行发生异常，此时JVM会让线程自动释放锁。</li></ul><p>那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。</p><p>因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p><p>再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。</p><p>但是采用synchronized关键字来实现同步的话，就会导致一个问题：</p><p>如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</p><p>另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</p><p>总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：</p><ul><li>Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</li><li>Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li></ul><h4 id="1-11-2-1java-util-concurrent-locks包下常用的类和接口"><a href="#1-11-2-1java-util-concurrent-locks包下常用的类和接口" class="headerlink" title="1.11.2.1java.util.concurrent.locks包下常用的类和接口"></a>1.11.2.1java.util.concurrent.locks包下常用的类和接口</h4><h5 id="1-Lock"><a href="#1-Lock" class="headerlink" title="1 Lock"></a>1 Lock</h5><p>首先要说明的就是Lock，通过查看Lock的源码可知，Lock是一个接口：</p><p><img src="dxc-msg.assets/image-20200527232909126.png" alt="image-20200527232909126"></p><p>​    下面来逐个讲述Lock接口中每个方法的使用，lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。newCondition()这个方法暂且不在此讲述，会在后面的线程协作一文中讲述。</p><p>在Lock中声明了四个方法来获取锁，那么这四个方法有何区别呢？</p><p>首先lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</p><p>由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：</p><p><img src="dxc-msg.assets/image-20200527232951295.png" alt="image-20200527232951295"></p><p>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p><p>　　tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</p><p>　　所以，一般情况下通过tryLock来获取锁时是这样使用的：</p><p><img src="dxc-msg.assets/image-20200527233040910.png" alt="image-20200527233040910"></p><p>lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时（也就是说想要通过interrupt()中断阻塞状态的线程，那么一定要通过lock.lockInterruptibly()获取锁），假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</p><p>　　由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。</p><p>因此lockInterruptibly()一般的使用形式如下：</p><p><img src="dxc-msg.assets/image-20200527233059509.png" alt="image-20200527233059509"></p><p>输出</p><p><img src="dxc-msg.assets/image-20200527233115123.png" alt="image-20200527233115123"></p><p>线程2在阻塞状态时被主动执行.interrupt()方法中断等待</p><p>注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为本身在前面的文章中讲过单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。</p><p>　　因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。</p><p>而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p><h5 id="2-ReentrantLock——可重入锁"><a href="#2-ReentrantLock——可重入锁" class="headerlink" title="2 ReentrantLock——可重入锁"></a>2 ReentrantLock——可重入锁</h5><p>ReentrantLock，意思是“可重入锁”，关于可重入锁的概念在下一节讲述。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。</p><p>例子1，lock()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    private ArrayList&lt;Integer&gt; arrayList &#x3D; new ArrayList&lt;Integer&gt;();  </span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();    &#x2F;&#x2F;注意这个地方，是同一个锁对象  </span><br><span class="line">    public static void main(String[] args)  &#123;  </span><br><span class="line">        final Test test &#x3D; new Test();  </span><br><span class="line">           </span><br><span class="line">        new Thread()&#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                test.insert(Thread.currentThread());  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">           </span><br><span class="line">        new Thread()&#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                test.insert(Thread.currentThread());  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">    &#125;    </span><br><span class="line">       </span><br><span class="line">    public void insert(Thread thread) &#123;  </span><br><span class="line">        lock.lock();  </span><br><span class="line">        try &#123;  </span><br><span class="line">            System.out.println(thread.getName()+&quot;得到了锁&quot;);  </span><br><span class="line">            for(int i&#x3D;0;i&lt;5;i++) &#123;  </span><br><span class="line">                arrayList.add(i);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            &#x2F;&#x2F; TODO: handle exception  </span><br><span class="line">        &#125;finally &#123;  </span><br><span class="line">            System.out.println(thread.getName()+&quot;释放了锁&quot;);  </span><br><span class="line">            lock.unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子2，tryLock()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    private ArrayList&lt;Integer&gt; arrayList &#x3D; new ArrayList&lt;Integer&gt;();  </span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();    &#x2F;&#x2F;注意这个地方，是同一个锁对象</span><br><span class="line">    public static void main(String[] args)  &#123;  </span><br><span class="line">        final Test test &#x3D; new Test();  </span><br><span class="line">           </span><br><span class="line">        new Thread()&#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                test.insert(Thread.currentThread());  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">           </span><br><span class="line">        new Thread()&#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                test.insert(Thread.currentThread());  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">    &#125;    </span><br><span class="line">       </span><br><span class="line">    public void insert(Thread thread) &#123;  </span><br><span class="line">        if(lock.tryLock()) &#123;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                System.out.println(thread.getName()+&quot;得到了锁&quot;);  </span><br><span class="line">                for(int i&#x3D;0;i&lt;5;i++) &#123;  </span><br><span class="line">                    arrayList.add(i);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; catch (Exception e) &#123;  </span><br><span class="line">                &#x2F;&#x2F; TODO: handle exception  </span><br><span class="line">            &#125;finally &#123;  </span><br><span class="line">                System.out.println(thread.getName()+&quot;释放了锁&quot;);  </span><br><span class="line">                lock.unlock();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            System.out.println(thread.getName()+&quot;获取锁失败&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="dxc-msg.assets/image-20200527233322904.png" alt="image-20200527233322904"></p><p>例子3，lockInterruptibly()响应中断的使用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();     </span><br><span class="line">    public static void main(String[] args)  &#123;  </span><br><span class="line">        Test test &#x3D; new Test();  </span><br><span class="line">        MyThread thread1 &#x3D; new MyThread(test);  </span><br><span class="line">        MyThread thread2 &#x3D; new MyThread(test);  </span><br><span class="line">        thread1.start();  </span><br><span class="line">        thread2.start();  </span><br><span class="line">           </span><br><span class="line">        try &#123;  </span><br><span class="line">            Thread.sleep(2000);  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        thread2.interrupt();  </span><br><span class="line">    &#125;    </span><br><span class="line">       </span><br><span class="line">public void insert(Thread thread) throws InterruptedException&#123;</span><br><span class="line">&#x2F;&#x2F;注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出  </span><br><span class="line">        lock.lockInterruptibly();     </span><br><span class="line">        try &#123;    </span><br><span class="line">            System.out.println(thread.getName()+&quot;得到了锁&quot;);  </span><br><span class="line">            long startTime &#x3D; System.currentTimeMillis();  </span><br><span class="line">            for(    ;     ;) &#123;  </span><br><span class="line">                if(System.currentTimeMillis() - startTime &gt;&#x3D; Integer.MAX_VALUE) </span><br><span class="line">                    break;  </span><br><span class="line">                &#x2F;&#x2F;插入数据  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        finally &#123;  </span><br><span class="line">           System.out.println(Thread.currentThread().getName()+&quot;执行finally&quot;);  </span><br><span class="line">            lock.unlock();  </span><br><span class="line">            System.out.println(thread.getName()+&quot;释放了锁&quot;);  </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    private Test test &#x3D; null;  </span><br><span class="line">    public MyThread(Test test) &#123;  </span><br><span class="line">        this.test &#x3D; test;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;          </span><br><span class="line">        try &#123;  </span><br><span class="line">            test.insert(Thread.currentThread());  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;被中断&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，发现thread2能够被正确中断。</p><h5 id="3-ReadWriteLock——读写锁"><a href="#3-ReadWriteLock——读写锁" class="headerlink" title="3 ReadWriteLock——读写锁"></a>3 ReadWriteLock——读写锁</h5><p>ReadWriteLock也是一个接口，在它里面只定义了两个方法：</p><ul><li>Lock readLock();</li><li>Lock writeLock();</li></ul><p>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。</p><h5 id="4-ReentrantReadWriteLock"><a href="#4-ReentrantReadWriteLock" class="headerlink" title="4 ReentrantReadWriteLock"></a>4 ReentrantReadWriteLock</h5><p>ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。</p><p>假如有多个线程要同时进行读操作,syncornized就不太合适了，改成读写锁如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    private ReentrantReadWriteLock rwl &#x3D; new ReentrantReadWriteLock();  </span><br><span class="line">       </span><br><span class="line">    public static void main(String[] args)  &#123;  </span><br><span class="line">        final Test test &#x3D; new Test();  </span><br><span class="line">           </span><br><span class="line">        new Thread()&#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                test.get(Thread.currentThread());  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">           </span><br><span class="line">        new Thread()&#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                test.get(Thread.currentThread());  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">           </span><br><span class="line">    &#125;    </span><br><span class="line">       </span><br><span class="line">    public void get(Thread thread) &#123;  </span><br><span class="line">        rwl.readLock().lock();  </span><br><span class="line">        try &#123;  </span><br><span class="line">            long start &#x3D; System.currentTimeMillis();  </span><br><span class="line">               </span><br><span class="line">            while(System.currentTimeMillis() - start &lt;&#x3D; 1) &#123;  </span><br><span class="line">                System.out.println(thread.getName()+&quot;正在进行读操作&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">            System.out.println(thread.getName()+&quot;读操作完毕&quot;);  </span><br><span class="line">        &#125; finally &#123;  </span><br><span class="line">            rwl.readLock().unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="dxc-msg.assets/image-20200527233630577.png" alt="image-20200527233630577"></p><p>说明thread1和thread2在同时进行读操作，这样就大大提升了读操作的效率。</p><p>不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。</p><p>　　如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</p><p>关于ReentrantReadWriteLock类中的其他方法感兴趣的朋友可以自行查阅API文档。</p><h4 id="1-11-3-Lock和synchronized的区别总结"><a href="#1-11-3-Lock和synchronized的区别总结" class="headerlink" title="1.11.3 Lock和synchronized的区别总结"></a>1.11.3 Lock和synchronized的区别总结</h4><p>总结来说，Lock和synchronized有以下几点不同：</p><ul><li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li><li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li><li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li><li>Lock可以提高多个线程进行读操作的效率。</li></ul><p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p><h4 id="1-11-4-锁的相关概念"><a href="#1-11-4-锁的相关概念" class="headerlink" title="1.11.4 锁的相关概念"></a>1.11.4 锁的相关概念</h4><h5 id="1-可重入锁"><a href="#1-可重入锁" class="headerlink" title="*.1 可重入锁"></a>*.1 可重入锁</h5><p>如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.class MyClass &#123;  </span><br><span class="line">2.    public synchronized void method1() &#123;  </span><br><span class="line">3.        method2();  </span><br><span class="line">4.    &#125;  </span><br><span class="line">5.       </span><br><span class="line">6.    public synchronized void method2() &#123;  </span><br><span class="line">7.           </span><br><span class="line">8.    &#125;  </span><br><span class="line">9.&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。</p><p>而由于synchronized和Lock都具备可重入性，所以不会发生上述现象。</p><h5 id="2-可中断锁"><a href="#2-可中断锁" class="headerlink" title="*.2 可中断锁"></a>*.2 可中断锁</h5><p>可中断锁：顾名思义，就是可以相应中断的锁。</p><p>在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</p><p>如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p><p>在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。</p><h5 id="3-公平锁"><a href="#3-公平锁" class="headerlink" title="*3. 公平锁"></a>*3. 公平锁</h5><p>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。</p><p>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p><p>在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。</p><p>而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</p><p>在ReentrantLock中定义了2个静态内部类，一个是NotFairSync，一个是FairSync，分别用来实现非公平锁和公平锁。</p><p>我们可以在创建ReentrantLock对象时，通过以下方式来设置锁的公平性：</p><p><img src="dxc-msg.assets/image-20200527234059563.png" alt="image-20200527234059563"></p><p>另外在ReentrantLock类中定义了很多方法，比如：</p><ul><li>isFair()    //判断锁是否是公平锁</li><li>isLocked()  //判断锁是否被任何线程获取了</li><li>isHeldByCurrentThread()  //判断锁是否被当前线程获取了</li><li>hasQueuedThreads()  //判断是否有线程在等待该锁</li></ul><p>在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。</p><h5 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="*4. 读写锁"></a>*4. 读写锁</h5><p>读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。</p><p>正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。</p><p>ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。</p><p>可以通过readLock()获取读锁，通过writeLock()获取写锁。</p><h2 id="1-11-Java中Volatile关键字详解"><a href="#1-11-Java中Volatile关键字详解" class="headerlink" title="1.11 Java中Volatile关键字详解"></a>1.11 Java中Volatile关键字详解</h2><h3 id="1-11-1-基本概念"><a href="#1-11-1-基本概念" class="headerlink" title="1.11.1 基本概念"></a>1.11.1 基本概念</h3><p>先补充一下概念：Java 内存模型中的可见性、原子性和有序性。</p><ul><li>可见性</li></ul><p>可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p><p>　　可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。</p><p>在 Java 中 volatile、synchronized 和 final 实现可见性。</p><ul><li>原子性：</li></ul><p>原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作是原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。</p><p>在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。</p><ul><li>有序性</li></ul><p>Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象</p><p>锁的两个同步块只能串行。</p><p>下面一段代码在多线程环境下，将存在问题。</p><p><img src="dxc-msg.assets/image-20200527234534836.png" alt="image-20200527234534836"></p><p>NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready的值。甚至NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入number的值，这种现象被称为“重排序”。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写入number，然后在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序完全相反。</p><p>　　在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，无法得到正确的结论。</p><p>这个看上去像是一个失败的设计，但却能使JVM充分地利用现代多核处理器的强大性能。例如，在缺少同步的情况下，Java内存模型允许编译器对操作顺序进行重排序，并将数值缓存在寄存器中。此外，它还允许CPU对操作顺序进行重排序，并将数值缓存在处理器特定的缓存中。</p><h3 id="1-11-2-Volatile原理"><a href="#1-11-2-Volatile原理" class="headerlink" title="1.11.2 Volatile原理"></a>1.11.2 Volatile原理</h3><p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p><p>　　在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</p><p><img src="dxc-msg.assets/image-20200527234704706.png" alt="image-20200527234704706"></p><p>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过CPU cache这一步。</p><p><strong><em>\</em>当一个变量定义为 volatile 之后，将具备两种特性：**</strong></p><p>　　1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：<a href="http://www.cnblogs.com/zhengbin/p/6407137.html" target="_blank" rel="noopener">Java内存模型</a>）来完成。</p><p>　　2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个<strong><em>\</em>内存屏障**</strong>（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。</p><p><strong><em>\</em>volatile 性能：**</strong></p><p>　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p><h1 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2.线程池"></a>2.线程池</h1><h2 id="2-1-什么是线程池"><a href="#2-1-什么是线程池" class="headerlink" title="2.1 什么是线程池"></a>2.1 什么是线程池</h2><p>线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交由线程池来管理。</p><p>为了充分利用CPU多核资源，应用都会采用多线程并行/并发计算，最大限度的利用多核提升应用程序性能。</p><p>试想一下，如果每个请求都执行一遍创建线程、执行任务、销毁线程，那么对服务器资源将是一种浪费。在高并发的情况下，甚至会耗尽服务器资源。</p><p>线程池的主要作用有两个：</p><ul><li>l 重复利用线程，无需频繁的创建和销毁线程，降低系统开销和，</li><li>l 控制线程数量上限，避免创建过多的线程耗尽进程内存空间，减少线程上下文切换次数。</li></ul><h2 id="2-2线程池的创建与使用"><a href="#2-2线程池的创建与使用" class="headerlink" title="2.2线程池的创建与使用"></a>2.2线程池的创建与使用</h2><p>在JDK5版本中增加了内置线程池实现ThreadPoolExecutor，同时提供了Executors来创建不同类型的线程池。Executors中提供了以下常见的线程池创建方法：</p><p>(1) newSingleThreadExecutor：一个单线程的线程池。如果因异常结束，会再创建一个新的，保证按照提交顺序执行。</p><p>(2) newFixedThreadPool：创建固定大小的线程池。根据提交的任务逐个增加线程，直到最大值保持不变。如果因异常结束，会新创建一个线程补充。</p><p>(3) newCachedThreadPool：创建一个可缓存的线程池。会根据任务自动新增或回收线程。</p><p>(4) newScheduledThreadPool：支持定时以及周期性执行任务的需求。·</p><p>(5) newWorkStealingPool：JDK8新增，根据所需的并行层次来动态创建和关闭线程，通过使用多个队列减少竞争，底层使用ForkJoinPool来实现。优势在于可以充分利用多CPU，把一个任务拆分成多个“小任务”，放到多个处理器核心上并行执行；当多个“小任务”执行完成之后，再将这些执行结果合并起来即可。</p><p>虽然在JDK中提供Executors类来支持以上类型的线程池创建，但通常情况下不建议开发人员直接使用（见《阿里巴巴java开发规范》）。</p><p><img src="dxc-msg.assets/image-20200527234923837.png" alt="image-20200527234923837"></p><p>Executors部分方法的弊端：</p><p>(1) newFixedThreadPool和newSingleThreadExecutor主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</p><p>(2) newCachedThreadPool和newScheduledThreadPool:主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</p><p>同时，阿里巴巴java开发规范中推荐了3种线程池创建方式。</p><p>方式一，引入commons-lang3包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;org.apache.commons.lang3.concurrent.BasicThreadFactory  </span><br><span class="line">ScheduledExecutorService executorService &#x3D; new ScheduledThreadPoolExecutor(1,      </span><br><span class="line">new BasicThreadFactory.Builder().namingPattern(&quot;example-schedule-pool-%d&quot;).daemon(true).build());</span><br></pre></td></tr></table></figure><p>方式二，引入com.google.guava包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory namedThreadFactory &#x3D; new ThreadFactoryBuilder() .setNameFormat(&quot;demo-pool-%d&quot;).build();  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Common Thread Pool  </span><br><span class="line">ExecutorService pool &#x3D; new ThreadPoolExecutor(5, 200,  0L, TimeUnit.MILLISECONDS,  </span><br><span class="line">    new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());  </span><br><span class="line"></span><br><span class="line">pool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));  </span><br><span class="line">pool.shutdown();&#x2F;&#x2F;gracefully shutdown</span><br></pre></td></tr></table></figure><p>方式三，spring配置线程池方式：自定义线程工厂bean需要实现ThreadFactory，可参考该接口的其它默认实现类，使用方式直接注入bean，调用execute(Runnable task)方法即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userThreadPool&quot;  </span><br><span class="line">    class&#x3D;&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&gt;  </span><br><span class="line">    &lt;property name&#x3D;&quot;corePoolSize&quot; value&#x3D;&quot;10&quot; &#x2F;&gt;  </span><br><span class="line">    &lt;property name&#x3D;&quot;maxPoolSize&quot; value&#x3D;&quot;100&quot; &#x2F;&gt;  </span><br><span class="line">    &lt;property name&#x3D;&quot;queueCapacity&quot; value&#x3D;&quot;2000&quot; &#x2F;&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;property name&#x3D;&quot;threadFactory&quot; value&#x3D; threadFactory &#x2F;&gt;  </span><br><span class="line">    &lt;property name&#x3D;&quot;rejectedExecutionHandler&quot;&gt;  </span><br><span class="line">        &lt;ref local&#x3D;&quot;rejectedExecutionHandler&quot; &#x2F;&gt;  </span><br><span class="line">    &lt;&#x2F;property&gt;  </span><br><span class="line">&lt;&#x2F;bean&gt;  </span><br><span class="line">&#x2F;&#x2F; 代码里使用  </span><br><span class="line">userThreadPool.execute(thread);</span><br></pre></td></tr></table></figure><h2 id="2-3ThreadPoolExecutor的构造方法"><a href="#2-3ThreadPoolExecutor的构造方法" class="headerlink" title="2.3ThreadPoolExecutor的构造方法"></a>2.3ThreadPoolExecutor的构造方法</h2><p>除了以上推荐的创建线程池的方法，还可以通过ThreadPoolExecutor的构造方法，直接创建线程池。本质上来讲，以上方法最终也是创建了ThreadPoolExecutor对象，然后进行包装处理。</p><p>ThreadPoolExecutor提供了多个构造方法，我们以调用构造方法来进行说明。</p><p><img src="dxc-msg.assets/image-20200527235208809.png" alt="image-20200527235208809"></p><p>核心参数作用解析如下：</p><p>(1) corePoolSize：线程池核心线程数最大值。</p><p>(2) maximumPoolSize：线程池最大线程数大小。</p><p>(3) keepAliveTime：线程池中非核心线程空闲的存活时间大小。</p><p>(4) unit：线程空闲存活时间单位。</p><p>(5) workQueue：存放任务的阻塞队列。</p><p>(6) threadFactory：创建新线程的工厂，所有线程都是通过该工厂创建的，有默认实现。</p><p>(7) handler：线程池的拒绝策略。</p><h2 id="2-4程池的拒绝策略"><a href="#2-4程池的拒绝策略" class="headerlink" title="2.4程池的拒绝策略"></a>2.4程池的拒绝策略</h2><p>构造方法的中最后的参数RejectedExecutionHandler用于指定线程池的拒绝策略。当请求任务不断的过来，而系统此时又处理不过来的时候，我们就需要采取对应的策略是拒绝服务。</p><p>默认有四种类型：</p><p>(1) AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。</p><p>(2) CallerRunsPolicy策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。</p><p>(3) DiscardOleddestPolicy策略：该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</p><p>(4) DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理。</p><p>当然，除了默认的4种策略之外，还可以根据业务需求自定义拒绝策略。通过实现RejectedExecutionHandler接口，在创建ThreadPoolExecutor对象时作为参数传入即可。</p><h2 id="2-5线程池的执行"><a href="#2-5线程池的执行" class="headerlink" title="2.5线程池的执行"></a>2.5线程池的执行</h2><p>创建完成ThreadPoolExecutor之后，当线程池提交任务时，通常使用execute方法。execute方法的执行流程图如下：</p><p><img src="dxc-msg.assets/image-20200527235347727.png" alt="image-20200527235347727"></p><p>(1) 如果线程池中存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。</p><p>(2) 如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</p><p>(3) 当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。</p><p>(4) 如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</p><h2 id="2-6-execute与submit的区别"><a href="#2-6-execute与submit的区别" class="headerlink" title="2.6 execute与submit的区别"></a>2.6 execute与submit的区别</h2><p>执行任务除了可以使用execute方法还可以使用submit方法。它们的主要区别是：execute适用于不需要关注返回值的场景，submit方法适用于需要关注返回值的场景。</p><h2 id="2-7-线程池中常见的队列"><a href="#2-7-线程池中常见的队列" class="headerlink" title="2.7 线程池中常见的队列"></a>2.7 线程池中常见的队列</h2><ol><li><p>ArrayBlockingQueue：有界队列，是一个用数组实现的有界阻塞队列，按FIFO排序量。</p></li><li><p>LinkedBlockingQueue：可设置容量队列，基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列。</p></li></ol><ol start="3"><li><p>DelayQueue：延迟队列，是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</p></li><li><p>PriorityBlockingQueue：优先级队列，是具有优先级的无界阻塞队列。</p></li><li><p>SynchronousQueue：同步队列，一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。</p></li></ol><h2 id="2-8关闭线程池"><a href="#2-8关闭线程池" class="headerlink" title="2.8关闭线程池"></a>2.8关闭线程池</h2><p>关闭线程池可以调用shutdownNow和shutdown两个方法来实现。</p><p>shutdownNow：对正在执行的任务全部发出interrupt()，停止执行，对还未开始执行的任务全部取消，并且返回还没开始的任务列表。</p><p>shutdown：当我们调用shutdown后，线程池将不再接受新的任务，但也不会去强制终止已经提交或者正在执行中的任务。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-线程&quot;&gt;&lt;a href=&quot;#1-线程&quot; class=&quot;headerlink&quot; title=&quot;1.线程&quot;&gt;&lt;/a&gt;1.线程&lt;/h1&gt;&lt;p&gt;线程:程序执行流的最小单元【可以理解为：进程中独立运行的子任务】。&lt;br&gt;多线程优点:最大限度的利用CPU的空闲时间来处理其他任务。
    
    </summary>
    
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
