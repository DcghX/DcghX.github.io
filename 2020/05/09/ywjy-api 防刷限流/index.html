<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>经验积累————API接口防刷限流 | 酱油村-记事录</title><meta name="description" content="在开发分布式高并发系统时有三把利器用来保护系统：缓存、降级、限流  缓存：缓存的目的是提升系统访问速度和增大系统处理容量  降级：降级是当服务出现问题或者影响到核心流程时，需要暂时屏蔽掉，待高峰或者问题解决后再打开  限流：限流的目的是通过对并发访问&#x2F;请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理   相关概念 PV：page v"><meta name="keywords" content="经验积累"><meta name="author" content="酱油君"><meta name="copyright" content="酱油君"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="经验积累————API接口防刷限流"><meta name="twitter:description" content="在开发分布式高并发系统时有三把利器用来保护系统：缓存、降级、限流  缓存：缓存的目的是提升系统访问速度和增大系统处理容量  降级：降级是当服务出现问题或者影响到核心流程时，需要暂时屏蔽掉，待高峰或者问题解决后再打开  限流：限流的目的是通过对并发访问&#x2F;请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理   相关概念 PV：page v"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="经验积累————API接口防刷限流"><meta property="og:url" content="https://dcghx.github.io/2020/05/09/ywjy-api%20%E9%98%B2%E5%88%B7%E9%99%90%E6%B5%81/"><meta property="og:site_name" content="酱油村-记事录"><meta property="og:description" content="在开发分布式高并发系统时有三把利器用来保护系统：缓存、降级、限流  缓存：缓存的目的是提升系统访问速度和增大系统处理容量  降级：降级是当服务出现问题或者影响到核心流程时，需要暂时屏蔽掉，待高峰或者问题解决后再打开  限流：限流的目的是通过对并发访问&#x2F;请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理   相关概念 PV：page v"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-05-09T03:15:27.000Z"><meta property="article:modified_time" content="2020-05-31T03:46:40.658Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://dcghx.github.io/2020/05/09/ywjy-api%20%E9%98%B2%E5%88%B7%E9%99%90%E6%B5%81/"><link rel="prev" title="spring-1" href="https://dcghx.github.io/2020/05/09/spring-1/"><link rel="next" title="经验积累————单点登录" href="https://dcghx.github.io/2020/05/09/ywjy-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="酱油村-记事录" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">27</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#相关概念"><span class="toc-number">1.</span> <span class="toc-text">相关概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#问题描述"><span class="toc-number">2.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-应用级限流"><span class="toc-number">3.</span> <span class="toc-text">3. 应用级限流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-控制并发数据量"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 控制并发数据量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-控制访问速率"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 控制访问速率</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-1-漏桶算法"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">3.1.1.1 漏桶算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-2-令牌桶算法"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">3.1.1.2 令牌桶算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-2-1-结合自定义注解方式使用"><span class="toc-number">3.1.1.2.1.</span> <span class="toc-text">3.1.1.2.1 结合自定义注解方式使用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-控制单位时间窗口内请求书"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 控制单位时间窗口内请求书</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-分布式限流"><span class="toc-number">4.</span> <span class="toc-text">4. 分布式限流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-接入层限流"><span class="toc-number">5.</span> <span class="toc-text">5. 接入层限流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-negix-限流"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 negix 限流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-请求限制"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1 请求限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-流量限制"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2 流量限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-网关限流（抽时间填坑）"><span class="toc-number">5.1.3.</span> <span class="toc-text">5.3 网关限流（抽时间填坑）</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">酱油村-记事录</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">经验积累————API接口防刷限流</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-09 11:15:27"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-09</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-31 11:46:40"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-31</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>在开发分布式高并发系统时有三把利器用来保护系统：缓存、降级、限流<a id="more"></a></p>
<ul>
<li><p>缓存：缓存的目的是提升系统访问速度和增大系统处理容量</p>
</li>
<li><p>降级：降级是当服务出现问题或者影响到核心流程时，需要暂时屏蔽掉，待高峰或者问题解决后再打开</p>
</li>
<li><p>限流：限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理</p>
</li>
</ul>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ul>
<li><p>PV：page view 页面总访问量，每刷新一次记录一次。</p>
</li>
<li><p>UV：unique view 客户端主机访问，指一天内相同IP的访问记为1次。</p>
</li>
<li><p>QPS:</p>
</li>
</ul>
<p>query per second,即每秒访问量。qps很大程度上代表了系统的繁忙度，没次请求可能存在多次的磁盘io，网络请求，多个cpu时间片，一旦qps超过了预先设置的阀值，可以考量扩容增加服务器，避免访问量过大导致的宕机。</p>
<ul>
<li>RT：response time,每次请求的响应时间,直接决定用户体验性。</li>
</ul>
<p>本文主要介绍应用级限流方法，分布式限流、流量入口限流（接入层如NGINX limitconn和limitreq 模块）。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><ol>
<li>某天A君突然发现自己的接口请求量突然涨到之前的10倍，没多久该接口几乎不可使用，并引发连锁反应导致整个系统崩溃。如何应对这种情况呢？生活给了我们答案：比如老式电闸都安装了保险丝，一旦有人使用超大功率的设备，保险丝就会烧断以保护各个电器不被强电流给烧坏。同理我们的接口也需要安装上“保险丝”，以防止非预期的请求对系统压力过大而引起的系统瘫痪，当流量过大时，可以采取拒绝或者引流等机制。整编：微信公众号，搜云库技术团队，ID：souyunku</li>
<li>缓存的目的是提升系统访问速度和增大系统能处理的容量，可谓是抗高并发流量的银弹；而降级是当服务出问题或者影响到核心流程的性能则需要暂时屏蔽掉，待高峰或者问题解决后再打开；而有些场景并不能用缓存和降级来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（评论的最后几页），因此需有一种手段来限制这些场景的并发/请求量，即限流。</li>
<li>系统在设计之初就会有一个预估容量，长时间超过系统能承受的TPS/QPS阈值，系统可能会被压垮，最终导致整个服务不够用。为了避免这种情况，我们就需要对接口请求进行限流。</li>
<li>限流的目的是通过对并发访问请求进行限速或者一个时间窗口内的的请求数量进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待。</li>
<li>一般开发高并发系统常见的限流模式有控制并发和控制速率，一个是限制并发的总数量（比如数据库连接池、线程池），一个是限制并发访问的速率（如nginx的limitconn模块，用来限制瞬时并发连接数），另外还可以限制单位时间窗口内的请求数量（如Guava的RateLimiter、nginx的limitreq模块，限制每秒的平均速率）。其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。</li>
</ol>
<h1 id="3-应用级限流"><a href="#3-应用级限流" class="headerlink" title="3. 应用级限流"></a>3. 应用级限流</h1><h2 id="3-1-控制并发数据量"><a href="#3-1-控制并发数据量" class="headerlink" title="3.1 控制并发数据量"></a>3.1 控制并发数据量</h2><p>属于一种较常见的限流手段，在实际应用中可以通过信号量机制（如Java中的Semaphore）来实现。操作系统的信号量是个很重要的概念，Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p>
<p>举个例子，我们对外提供一个服务接口，允许最大并发数为10，代码实现如下：</p>
<p>![image-20200531113217111](ywjy-api 防刷限流.assets/image-20200531113217111.png)</p>
<p>在以上代码中，虽然有30个线程在执行，但是只允许10个并发的执行。Semaphore的构造方法Semaphore(int permits) 接受一个整型的数字，表示可用的许可证数量。Semaphore(10)表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()获取一个许可证，使用完之后调用release()归还许可证，还可以用tryAcquire()方法尝试获取许可证，信号量的本质是控制某个资源可被同时访问的个数，在一定程度上可以控制某资源的访问频率，但不能精确控制，控制访问频率的模式见下文描述。</p>
<h3 id="3-1-1-控制访问速率"><a href="#3-1-1-控制访问速率" class="headerlink" title="3.1.1 控制访问速率"></a>3.1.1 控制访问速率</h3><p>在工程实践中，常见的是使用令牌桶算法来实现这种模式，常用的限流算法有两种：漏桶算法和令牌桶算法。</p>
<h4 id="3-1-1-1-漏桶算法"><a href="#3-1-1-1-漏桶算法" class="headerlink" title="3.1.1.1 漏桶算法"></a>3.1.1.1 漏桶算法</h4><p>漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。</p>
<p>![image-20200531113310495](ywjy-api 防刷限流.assets/image-20200531113310495.png)</p>
<p>对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。</p>
<h4 id="3-1-1-2-令牌桶算法"><a href="#3-1-1-2-令牌桶算法" class="headerlink" title="3.1.1.2 令牌桶算法"></a>3.1.1.2 令牌桶算法</h4><p>如图所示，令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务，令牌桶算法通过发放令牌，根据令牌的rate频率做请求频率限制，容量限制等。</p>
<p>![image-20200531113345988](ywjy-api 防刷限流.assets/image-20200531113345988.png)</p>
<p><strong><em>\</em>1、**</strong>每过1/r秒桶中增加一个令牌。</p>
<p><strong><em>\</em>2、**</strong>桶中最多存放b个令牌，如果桶满了，新放入的令牌会被丢弃。</p>
<p><strong><em>\</em>3、**</strong>当一个n字节的数据包到达时，消耗n个令牌，然后发送该数据包。</p>
<p><strong><em>\</em>4、**</strong>如果桶中可用令牌小于n，则该数据包将被缓存或丢弃。</p>
<p>令牌桶控制的是一个时间窗口内通过的数据量，在API层面我们常说的QPS、TPS，正好是一个时间窗口内的请求量或者事务量，只不过时间窗口限定在1s罢了。以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。令牌桶的另外一个好处是可以方便的改变速度，一旦需要提高速率，则按需提高放入桶中的令牌的速率。</p>
<p>在我们的工程实践中，通常使用Google开源工具包Guava提供的限流工具类RateLimiter来实现控制速率，该类基于令牌桶算法来完成限流，非常易于使用，而且非常高效。如我们不希望每秒的任务提交超过1个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">    String start &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());      &#x2F;&#x2F; 这里的1表示每秒允许处理的量为1个  </span><br><span class="line">    RateLimiter limiter &#x3D; RateLimiter.create(1.0); </span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;   </span><br><span class="line">        limiter.acquire();&#x2F;&#x2F; 请求RateLimiter, 超过permits会被阻塞  </span><br><span class="line">        System.out.println(&quot;call execute..&quot; + i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    String end &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());  </span><br><span class="line">    System.out.println(&quot;start time:&quot; + start);  </span><br><span class="line">    System.out.println(&quot;end time:&quot; + end);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过RateLimiter.create(1.0);创建一个限流器，参数代表每秒生成的令牌数，通过limiter.acquire(i);来以阻塞的方式获取令牌，令牌桶算法允许一定程度的突发（允许消费未来的令牌），所以可以一次性消费i个令牌；当然也可以通过tryAcquire(int permits, long timeout, TimeUnit unit)来设置等待超时时间的方式获取令牌，如果超timeout为0，则代表非阻塞，获取不到立即返回，支持阻塞或可超时的令牌消费。</p>
<p>从输出来看，RateLimiter支持预消费，比如在acquire(5)时，等待时间是4秒，是上一个获取令牌时预消费了3个两排，固需要等待3*1秒，然后又预消费了5个令牌，以此类推。</p>
<p><strong><em>\</em>RateLimiter通过限制后面请求的等待时间，来支持一定程度的突发请求(预消费**</strong>)，在使用过程中需要注意这一点，Guava有两种限流模式，一种为稳定模式(SmoothBursty:令牌生成速度恒定，平滑突发限流)，一种为渐进模式(SmoothWarmingUp:令牌生成速度缓慢提升直到维持在一个稳定值，平滑预热限流) 两种模式实现思路类似，主要区别在等待时间的计算上。</p>
<p><strong><em>\</em>SmoothBursty 模式：**</strong></p>
<p>RateLimiter limiter = RateLimiter.create(5); RateLimiter.create(5)表示桶容量为5且每秒新增5个令牌，即每隔200毫秒新增一个令牌；limiter.acquire()表示消费一个令牌，如果当前桶中有足够令牌则成功（返回值为0），如果桶中没有令牌则暂停一段时间，比如发令牌间隔是200毫秒，则等待200毫秒后再去消费令牌，这种实现将突发请求速率平均为了固定请求速率。</p>
<p><strong><em>\</em>SmoothWarmingUp模式：**</strong></p>
<p>RateLimiter limiter = RateLimiter.create(5,1000, TimeUnit.MILLISECONDS);</p>
<p><strong><em>\</em>创建方式：**</strong></p>
<p><strong><em>\</em>RateLimiter.create(doublepermitsPerSecond, long warmupPeriod, TimeUnit unit)*****</strong>*，permitsPerSecond表示每秒新增的令牌数，****</p>
<p>warmupPeriod表示在从冷启动速率过渡到平均速率的时间间隔。速率是梯形上升速率的，也就是说冷启动时会以一个比较大的速率慢慢到平均速率；然后趋于平均速率（梯形下降到平均速率）。可以通过调节warmupPeriod参数实现一开始就是平滑固定速率。</p>
<p>注：RateLimiter控制的是速率，Samephore控制的是并发量。RateLimiter的原理就是令牌桶，它主要由许可发出的速率来定义，如果没有额外的配置，许可证将按每秒许可证规定的固定速度分配，许可将被平滑地分发，若请求超过permitsPerSecond则RateLimiter按照每秒 1/permitsPerSecond 的速率释放许可。注意:RateLimiter适用于单体应用，且RateLimiter不保证公平性访问。</p>
<h5 id="3-1-1-2-1-结合自定义注解方式使用"><a href="#3-1-1-2-1-结合自定义注解方式使用" class="headerlink" title="3.1.1.2.1 结合自定义注解方式使用"></a>3.1.1.2.1 结合自定义注解方式使用</h5><p>使用上述方式使用RateLimiter的方式不够优雅，自定义注解+AOP的方式实现(适用于单体应用)，详细见下面代码：</p>
<ul>
<li>自定义注解：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.*;  </span><br><span class="line">   </span><br><span class="line">&#x2F;** </span><br><span class="line"> * 自定义注解可以不包含属性，成为一个标识注解 </span><br><span class="line"> *&#x2F;  </span><br><span class="line">@Inherited  </span><br><span class="line">@Documented  </span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.TYPE&#125;)  </span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)  </span><br><span class="line">public @interface RateLimitAspect &#123;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义切面类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Component  </span><br><span class="line">@Scope  </span><br><span class="line">@Aspect  </span><br><span class="line">public class RateLimitAop &#123;  </span><br><span class="line">   </span><br><span class="line">    @Autowired  </span><br><span class="line">    private HttpServletResponse response;  </span><br><span class="line">   &#x2F;&#x2F;比如说，我这里设置&quot;并发数&quot;为5  </span><br><span class="line">    private RateLimiter rateLimiter &#x3D; RateLimiter.create(5.0); </span><br><span class="line">   </span><br><span class="line"> @Pointcut(&quot;@annotation(com.simons.cn.springbootdemo.aspect.RateLimitAspect)&quot;)  </span><br><span class="line">    public void serviceLimit() &#123;  </span><br><span class="line">   </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    @Around(&quot;serviceLimit()&quot;)  </span><br><span class="line">    public Object around(ProceedingJoinPoint joinPoint) &#123;  </span><br><span class="line">        Boolean flag &#x3D; rateLimiter.tryAcquire();  </span><br><span class="line">        Object obj &#x3D; null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            if (flag) &#123;  </span><br><span class="line">                obj &#x3D; joinPoint.proceed();  </span><br><span class="line">            &#125;else&#123;  </span><br><span class="line">String result &#x3D; JSONObject.fromObject(ResultUtil.success1(100, &quot;failure&quot;)).toString();  </span><br><span class="line">                output(response, result);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; catch (Throwable e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(&quot;flag&#x3D;&quot; + flag + &quot;,obj&#x3D;&quot; + obj);  </span><br><span class="line">        return obj;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">public void output(HttpServletResponse response, String msg) throws IOException &#123;  </span><br><span class="line">        response.setContentType(&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);  </span><br><span class="line">        ServletOutputStream outputStream &#x3D; null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            outputStream &#x3D; response.getOutputStream();  </span><br><span class="line">            outputStream.write(msg.getBytes(&quot;UTF-8&quot;));  </span><br><span class="line">        &#125; catch (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; finally &#123;  </span><br><span class="line">            outputStream.flush();  </span><br><span class="line">            outputStream.close();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试controller</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody  </span><br><span class="line">@RateLimitAspect  </span><br><span class="line">@RequestMapping(&quot;&#x2F;test&quot;)  </span><br><span class="line">public String test()&#123;  </span><br><span class="line">  return ResultUtil.success1(1001, &quot;success&quot;).toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样通过自定义注解@RateLimiterAspect来动态的加到需要限流的接口上，个人认为是比较优雅的实现吧。</p>
<h2 id="3-2-控制单位时间窗口内请求书"><a href="#3-2-控制单位时间窗口内请求书" class="headerlink" title="3.2 控制单位时间窗口内请求书"></a>3.2 控制单位时间窗口内请求书</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private LoadingCache&lt;Long, AtomicLong&gt; counter &#x3D; CacheBuilder.newBuilder().expireAfterWrite(2, TimeUnit.SECONDS)  </span><br><span class="line">                    .build(new CacheLoader&lt;Long, AtomicLong&gt;() &#123;  </span><br><span class="line">                        @Override  </span><br><span class="line">                        public AtomicLong load(Long seconds) throws Exception &#123;  </span><br><span class="line">                            return new AtomicLong(0);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;);  </span><br><span class="line">  </span><br><span class="line">public static long permit &#x3D; 50;  </span><br><span class="line">  </span><br><span class="line">public ResponseEntity getData() throws ExecutionException &#123;  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;得到当前秒  </span><br><span class="line">    long currentSeconds &#x3D; System.currentTimeMillis() &#x2F; 1000;  </span><br><span class="line">    if(counter.get(currentSeconds).incrementAndGet() &gt; permit) &#123;  </span><br><span class="line">        return ResponseEntity.builder().code(404).msg(&quot;访问速率过快&quot;).build();  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F;业务处理  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此应用级限流的一些方法就介绍完了。假设将应用部署到多台机器，应用级限流方式只是单应用内的请求限流，不能进行全局限流。因此我们需要分布式限流和接入层限流来解决这个问题。</p>
<h1 id="4-分布式限流"><a href="#4-分布式限流" class="headerlink" title="4. 分布式限流"></a>4. 分布式限流</h1><p>自定义注解+拦截器+Redis实现限流 (单体和分布式均适用，全局限流)</p>
<ul>
<li>自定义注解：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Inherited  </span><br><span class="line">@Documented  </span><br><span class="line">@Target(&#123;ElementType.FIELD,ElementType.TYPE,ElementType.METHOD&#125;)  </span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)  </span><br><span class="line">public @interface AccessLimit &#123;  </span><br><span class="line">    &#x2F;&#x2F;标识 指定sec时间段内的访问次数限制  </span><br><span class="line">    int limit() default 5;    </span><br><span class="line">    &#x2F;&#x2F;标识 时间段  </span><br><span class="line">    int sec() default 5;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>拦截器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class AccessLimitInterceptor implements HandlerInterceptor &#123;  </span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F;使用RedisTemplate操作redis  </span><br><span class="line">    @Autowired  </span><br><span class="line">    private RedisTemplate&lt;String, Integer&gt; redisTemplate;    </span><br><span class="line">   </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;  </span><br><span class="line">        if (handler instanceof HandlerMethod) &#123;  </span><br><span class="line">            HandlerMethod handlerMethod &#x3D; (HandlerMethod) handler;  </span><br><span class="line">            Method method &#x3D; handlerMethod.getMethod();  </span><br><span class="line">            if (!method.isAnnotationPresent(AccessLimit.class)) &#123;  </span><br><span class="line">                return true;  </span><br><span class="line">            &#125;  </span><br><span class="line">            AccessLimit accessLimit &#x3D; method.getAnnotation(AccessLimit.class);  </span><br><span class="line">            if (accessLimit &#x3D;&#x3D; null) &#123;  </span><br><span class="line">                return true;  </span><br><span class="line">            &#125;  </span><br><span class="line">            int limit &#x3D; accessLimit.limit();  </span><br><span class="line">            int sec &#x3D; accessLimit.sec();  </span><br><span class="line">            String key &#x3D; IPUtil.getIpAddr(request) + request.getRequestURI();  </span><br><span class="line">            Integer maxLimit &#x3D; redisTemplate.opsForValue().get(key);  </span><br><span class="line">            if (maxLimit &#x3D;&#x3D; null) &#123;  </span><br><span class="line">                &#x2F;&#x2F;set时一定要加过期时间  </span><br><span class="line">                redisTemplate.opsForValue().set(key, 1, sec, TimeUnit.SECONDS);    </span><br><span class="line">            &#125; else if (maxLimit &lt; limit) &#123;  </span><br><span class="line">                redisTemplate.opsForValue().set(key, maxLimit + 1, sec, TimeUnit.SECONDS);  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                output(response, &quot;请求太频繁!&quot;);  </span><br><span class="line">                return false;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">  public void output(HttpServletResponse response, String msg) throws IOException &#123;   response.setContentType(&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);  </span><br><span class="line">        ServletOutputStream outputStream &#x3D; null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            outputStream &#x3D; response.getOutputStream();  </span><br><span class="line">            outputStream.write(msg.getBytes(&quot;UTF-8&quot;));  </span><br><span class="line">        &#125; catch (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; finally &#123;  </span><br><span class="line">            outputStream.flush();  </span><br><span class="line">            outputStream.close();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    @Override  </span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;  </span><br><span class="line">   </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    @Override  </span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;  </span><br><span class="line">   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>controller</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.@Controller  </span><br><span class="line">2.@RequestMapping(&quot;&#x2F;activity&quot;)  </span><br><span class="line">3.public class AopController &#123;  </span><br><span class="line">4.    @ResponseBody  </span><br><span class="line">5.    @RequestMapping(&quot;&#x2F;seckill&quot;)  </span><br><span class="line">6.    @AccessLimit(limit &#x3D; 4,sec &#x3D; 10)  &#x2F;&#x2F;加上自定义注解即可  </span><br><span class="line">7.    public String test (HttpServletRequest request,String userName)&#123;  </span><br><span class="line">8.        &#x2F;&#x2F;TODO somethings……  </span><br><span class="line">9.        return   &quot;hello world !&quot;;  </span><br><span class="line">10.    &#125;  </span><br><span class="line">11.&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*springmvc的配置文件中加入自定义拦截器*&#x2F;  </span><br><span class="line">&lt;mvc:interceptors&gt;  </span><br><span class="line">   &lt;mvc:interceptor&gt;  </span><br><span class="line">      &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;  </span><br><span class="line">&lt;bean class&#x3D;&quot;com.pptv.activityapi.controller.pointsmall.AccessLimitInterceptor&quot;&#x2F;&gt;  </span><br><span class="line">   &lt;&#x2F;mvc:interceptor&gt;  </span><br><span class="line">&lt;&#x2F;mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>



<h1 id="5-接入层限流"><a href="#5-接入层限流" class="headerlink" title="5. 接入层限流"></a>5. 接入层限流</h1><h2 id="5-1-negix-限流"><a href="#5-1-negix-限流" class="headerlink" title="5.1 negix 限流"></a>5.1 negix 限流</h2><p>限制原理:可一句话概括为：“根据客户端特征，限制其访问频率”，客户端特征主要指IP、UserAgent等。使用IP比UserAgent更可靠，因为IP无法造假，UserAgent可随意伪造。</p>
<p>Nginx为我们提供了两种限流方式：</p>
<ul>
<li><p>请求限制模块（ngx_http_limit_req_module）</p>
</li>
<li><p>基于令牌桶算法的流量限制模块（ngx_stream_limit_conn_module），可以方便的控制令牌速率，自定义调节限流，实现基本的限流控制</p>
</li>
</ul>
<h3 id="5-1-1-请求限制"><a href="#5-1-1-请求限制" class="headerlink" title="5.1.1 请求限制"></a>5.1.1 请求限制</h3><p>请求限制的功能来自于 ngx_http_limit_req_module 模块。使用它需要首先在 http 配置段中定义限制的参照标准和状态缓存区大小。</p>
<ul>
<li><p>limit_req_zone 只能配置在 http 范围内；</p>
</li>
<li><p>$binary_remote_addr 表示客户端请求的IP地址；</p>
</li>
<li><p>mylimit 自己定义的变量名；</p>
</li>
<li><p>rate 请求频率，每秒允许多少请求；</p>
</li>
<li><p>limit_req 与 limit_req_zone 对应</p>
</li>
<li><p>burst 表示缓存住的请求数，也就是任务队列。</p>
</li>
</ul>
<p>下面的配置就是定义了使用客户端的 IP 作为参照依据，并使用一个 10M 大小的状态缓存区。结尾的 rate=1r/s 表示针对每个 IP 的请求每秒只接受一次。</p>
<p>10M 的状态缓存空间够不够用呢？官方给出的答案是 1M 的缓存空间可以在 32 位的系统中服务 3.2 万 IP 地址，在 64 位的系统中可以服务 1.6 万 IP 地址，所以需要自己看情况调整。如果状态缓存耗光，后面所有的请求都会收到 503(Service Temporarily Unavailable) 错误。</p>
<p>脚本代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 定义了一个 mylimit 缓冲区（容器），请求频率为每秒 1 个请求（nr&#x2F;s）  </span><br><span class="line">limit_req_zone $binary_remote_addr zone&#x3D;mylimit:10m rate&#x3D;1r&#x2F;s;  </span><br><span class="line">server &#123;  </span><br><span class="line">    listen  70;  </span><br><span class="line">    location &#x2F; &#123;  </span><br><span class="line">        # nodelay 不延迟处理  </span><br><span class="line">        # burst 是配置超额处理,可简单理解为队列机制  </span><br><span class="line">        # 上面配置同一个 IP 没秒只能发送一次请求（1r&#x2F;s），这里配置了缓存3个请求，就意味着同一秒内只能允许 4 个任务响应成功，其它任务请求则失败（503错误）  </span><br><span class="line">        limit_req zone&#x3D;mylimit burst&#x3D;3 nodelay;  </span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:7070;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便此处提供 JAVA、AB 两种测试代码：</p>
<p>AB:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.# -n 即指定压力测试总共的执行次数  </span><br><span class="line">2.# -c 即指定的并发数  </span><br><span class="line">ab -n 5 -c 5 http:&#x2F;&#x2F;192.168.0.133:70&#x2F;index</span><br></pre></td></tr></table></figure>

<p>java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.public static void main(String[] args) throws ExecutionException, InterruptedException &#123;  </span><br><span class="line">2.        ExecutorService service &#x3D; Executors.newFixedThreadPool(5);  </span><br><span class="line">3.        for (int i &#x3D; 0; i &lt; 6; i++) &#123;  </span><br><span class="line">4.            CompletableFuture.supplyAsync(() -&gt; &#123;  </span><br><span class="line">5.                final ResponseEntity&lt;String&gt; entity &#x3D; new RestTemplate().getForEntity(&quot;http:&#x2F;&#x2F;192.168.0.133:70&#x2F;index&quot;, String.class);  </span><br><span class="line">6.                return entity.getBody();  </span><br><span class="line">7.            &#125;, service).thenAccept(System.out::println);  </span><br><span class="line">8.        &#125;  </span><br><span class="line">9.        service.shutdown();  </span><br><span class="line">10.    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-1-2-流量限制"><a href="#5-1-2-流量限制" class="headerlink" title="5.1.2 流量限制"></a>5.1.2 流量限制</h3><p>Nginx 并发限制的功能来自于 ngx_http_limit_conn_module 模块，跟请求配置一样，使用它之前，需要先定义参照标准和状态缓存区。</p>
<ul>
<li><p>imit_conn_zone 只能配置在 http 范围内；</p>
</li>
<li><p>$binary_remote_addr 表示客户端请求的IP地址；</p>
</li>
<li><p>myconn 自己定义的变量名（缓冲区）；</p>
</li>
<li><p>limit_rate 限制传输速度</p>
</li>
<li><p>limit_conn 与 limit_conn_zone 对应，限制网络连接数</p>
</li>
</ul>
<p>下面的配置就是定义了使用客户端的 IP 作为参照依据，并使用一个 10M 大小的状态缓存区。限定了每个IP只允许建立一个请求连接，同时传输的速度最大为 1024KB</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.# 定义了一个 myconn 缓冲区（容器）  </span><br><span class="line">2.limit_conn_zone $binary_remote_addr zone&#x3D;myconn:10m;  </span><br><span class="line">3.server &#123;  </span><br><span class="line">4.    listen  70;  </span><br><span class="line">5.    location &#x2F; &#123;  </span><br><span class="line">6.        # 每个 IP 只允许一个连接  </span><br><span class="line">7.        limit_conn myconn 1;  </span><br><span class="line">8.        # 限制传输速度（如果有N个并发连接，则是 N * limit_rate）  </span><br><span class="line">9.        limit_rate 1024k;  </span><br><span class="line">10.        proxy_pass http:&#x2F;&#x2F;localhost:7070;  </span><br><span class="line">11.    &#125;  </span><br><span class="line">12.&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-网关限流（抽时间填坑）"><a href="#5-3-网关限流（抽时间填坑）" class="headerlink" title="5.3 网关限流（抽时间填坑）"></a>5.3 网关限流（抽时间填坑）</h3></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">酱油君</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dcghx.github.io/2020/05/09/ywjy-api%20%E9%98%B2%E5%88%B7%E9%99%90%E6%B5%81/">https://dcghx.github.io/2020/05/09/ywjy-api%20%E9%98%B2%E5%88%B7%E9%99%90%E6%B5%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dcghx.github.io" target="_blank">酱油村-记事录</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/">经验积累</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/09/spring-1/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">spring-1</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/09/ywjy-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">经验积累————单点登录</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/09/ywjy-单点登录/" title="经验积累————单点登录"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">经验积累————单点登录</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/09/ywjy-分布式锁/" title="经验积累————分布式锁"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">经验积累————分布式锁</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/09/ywjy-缓存双写一致性/" title="经验积累————缓存双写一致性"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">经验积累————缓存双写一致性</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/09/ywjy-接口幂等性/" title="经验积累————接口幂等性"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">经验积累————接口幂等性</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/09/ywjy-系统如何支撑高并发-思路 副本/" title="经验积累————系统如何支撑高并发-思路"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">经验积累————系统如何支撑高并发-思路</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/09/ywjy-基于代码级别的读写分离/" title="经验积累————基于代码级别的读写分离"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">经验积累————基于代码级别的读写分离</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 酱油君</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script></body></html>