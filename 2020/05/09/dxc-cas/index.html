<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>多线程————CAS | 酱油村-记事录</title><meta name="description" content="什么是悲观锁、乐观锁？在java语言里，总有一些名词看语义跟本不明白是啥玩意儿，也就总有部分面试官拿着这样的词来忽悠面试者，以此来找优越感，其实理解清楚了，这些词也就唬不住人了。  synchronized是悲观锁，这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁。  CAS操作的就是乐观锁，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。   在进入正"><meta name="keywords" content="多线程"><meta name="author" content="酱油君"><meta name="copyright" content="酱油君"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="多线程————CAS"><meta name="twitter:description" content="什么是悲观锁、乐观锁？在java语言里，总有一些名词看语义跟本不明白是啥玩意儿，也就总有部分面试官拿着这样的词来忽悠面试者，以此来找优越感，其实理解清楚了，这些词也就唬不住人了。  synchronized是悲观锁，这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁。  CAS操作的就是乐观锁，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。   在进入正"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="多线程————CAS"><meta property="og:url" content="https://dcghx.github.io/2020/05/09/dxc-cas/"><meta property="og:site_name" content="酱油村-记事录"><meta property="og:description" content="什么是悲观锁、乐观锁？在java语言里，总有一些名词看语义跟本不明白是啥玩意儿，也就总有部分面试官拿着这样的词来忽悠面试者，以此来找优越感，其实理解清楚了，这些词也就唬不住人了。  synchronized是悲观锁，这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁。  CAS操作的就是乐观锁，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。   在进入正"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-05-09T03:15:27.000Z"><meta property="article:modified_time" content="2020-05-29T14:29:20.204Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://dcghx.github.io/2020/05/09/dxc-cas/"><link rel="next" title="JVM——(1)" href="https://dcghx.github.io/2020/05/09/jvm-1/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="酱油村-记事录" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">27</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-什么是CAS机制"><span class="toc-number">1.</span> <span class="toc-text">1.什么是CAS机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-CAS的缺点"><span class="toc-number">2.</span> <span class="toc-text">2.CAS的缺点</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">酱油村-记事录</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">多线程————CAS</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-09 11:15:27"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-09</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-29 22:29:20"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-29</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>什么是悲观锁、乐观锁？在java语言里，总有一些名词看语义跟本不明白是啥玩意儿，也就总有部分面试官拿着这样的词来忽悠面试者，以此来找优越感，其实理解清楚了，这些词也就唬不住人了。<a id="more"></a></p>
<ul>
<li><p>synchronized是悲观锁，这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁。</p>
</li>
<li><p>CAS操作的就是乐观锁，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p>
</li>
</ul>
<p>在进入正题之前，我们先理解下下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.private static int count &#x3D; 0;  </span><br><span class="line">2.  </span><br><span class="line">3.   public static void main(String[] args) &#123;  </span><br><span class="line">4.       for (int i &#x3D; 0; i &lt; 2; i++) &#123;  </span><br><span class="line">5.           new Thread(new Runnable() &#123;  </span><br><span class="line">6.               @Override  </span><br><span class="line">7.               public void run() &#123;  </span><br><span class="line">8.                   try &#123;  </span><br><span class="line">9.                       Thread.sleep(10);  </span><br><span class="line">10.                   &#125; catch (Exception e) &#123;  </span><br><span class="line">11.                       e.printStackTrace();  </span><br><span class="line">12.                   &#125;  </span><br><span class="line">13.                   &#x2F;&#x2F;每个线程让count自增100次  </span><br><span class="line">14.                   for (int i &#x3D; 0; i &lt; 100; i++) &#123;  </span><br><span class="line">15.                       count++;  </span><br><span class="line">16.                   &#125;  </span><br><span class="line">17.               &#125;  </span><br><span class="line">18.           &#125;).start();  </span><br><span class="line">19.       &#125;  </span><br><span class="line">20.  </span><br><span class="line">21.       try&#123;  </span><br><span class="line">22.           Thread.sleep(2000);  </span><br><span class="line">23.       &#125;catch (Exception e)&#123;  </span><br><span class="line">24.           e.printStackTrace();  </span><br><span class="line">25.       &#125;  </span><br><span class="line">26.       System.out.println(count);  </span><br><span class="line">27.   &#125;</span><br></pre></td></tr></table></figure>

<p>请问cout的输出值是否为200？答案是否定的，因为这个程序是线程不安全的，所以造成的结果count值可能小于200;</p>
<p>那么如何改造成线程安全的呢，其实我们可以使用上Synchronized同步锁,我们只需要在count++的位置添加同步锁，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.private static int count &#x3D; 0;  </span><br><span class="line">2.  </span><br><span class="line">3.    public static void main(String[] args) &#123;  </span><br><span class="line">4.        for (int i &#x3D; 0; i &lt; 2; i++) &#123;  </span><br><span class="line">5.            new Thread(new Runnable() &#123;  </span><br><span class="line">6.                @Override  </span><br><span class="line">7.                public void run() &#123;  </span><br><span class="line">8.                    try &#123;  </span><br><span class="line">9.                        Thread.sleep(10);  </span><br><span class="line">10.                    &#125; catch (Exception e) &#123;  </span><br><span class="line">11.                        e.printStackTrace();  </span><br><span class="line">12.                    &#125;  </span><br><span class="line">13.                    &#x2F;&#x2F;每个线程让count自增100次  </span><br><span class="line">14.                    for (int i &#x3D; 0; i &lt; 100; i++) &#123;  </span><br><span class="line">15.                        synchronized (ThreadCas.class)&#123;  </span><br><span class="line">16.                            count++;  </span><br><span class="line">17.                        &#125;  </span><br><span class="line">18.                    &#125;  </span><br><span class="line">19.                &#125;  </span><br><span class="line">20.            &#125;).start();  </span><br><span class="line">21.        &#125;  </span><br><span class="line">22.  </span><br><span class="line">23.        try&#123;  </span><br><span class="line">24.            Thread.sleep(2000);  </span><br><span class="line">25.        &#125;catch (Exception e)&#123;  </span><br><span class="line">26.            e.printStackTrace();  </span><br><span class="line">27.        &#125;  </span><br><span class="line">28.        System.out.println(count);  </span><br><span class="line">29.    &#125;</span><br></pre></td></tr></table></figure>

<p>加了同步锁之后，count自增的操作变成了原子性操作，所以最终的输出一定是count=200，代码实现了线程安全。</p>
<p>但是Synchronized虽然确保了线程的安全，但是在性能上却不是最优的，Synchronized关键字会让没有得到锁资源的线程进入BLOCKED状态，而后在争夺到锁资源后恢复为RUNNABLE状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。</p>
<p>尽管Java1.6为Synchronized做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度，但是在最终转变为重量级锁之后，性能仍然较低。</p>
<p>所谓原子操作类，指的是java.util.concurrent.atomic包下，一系列以Atomic开头的包装类。例如AtomicBoolean，AtomicInteger，AtomicLong。它们分别用于Boolean，Integer，Long类型的原子性操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.private static AtomicInteger count &#x3D; new AtomicInteger(0);  </span><br><span class="line">2.  </span><br><span class="line">3.public static void main(String[] args) &#123;  </span><br><span class="line">4.    for (int i &#x3D; 0; i &lt; 2; i++) &#123;  </span><br><span class="line">5.        new Thread(new Runnable() &#123;  </span><br><span class="line">6.            @Override  </span><br><span class="line">7.            public void run() &#123;  </span><br><span class="line">8.                try &#123;  </span><br><span class="line">9.                    Thread.sleep(10);  </span><br><span class="line">10.                &#125; catch (Exception e) &#123;  </span><br><span class="line">11.                    e.printStackTrace();  </span><br><span class="line">12.                &#125;  </span><br><span class="line">13.                &#x2F;&#x2F;每个线程让count自增100次  </span><br><span class="line">14.                for (int i &#x3D; 0; i &lt; 100; i++) &#123;  </span><br><span class="line">15.                    count.incrementAndGet();  </span><br><span class="line">16.                &#125;  </span><br><span class="line">17.            &#125;  </span><br><span class="line">18.        &#125;).start();  </span><br><span class="line">19.    &#125;  </span><br><span class="line">20.  </span><br><span class="line">21.    try&#123;  </span><br><span class="line">22.        Thread.sleep(2000);  </span><br><span class="line">23.    &#125;catch (Exception e)&#123;  </span><br><span class="line">24.        e.printStackTrace();  </span><br><span class="line">25.    &#125;  </span><br><span class="line">26.    System.out.println(count);  </span><br><span class="line">27.&#125;</span><br></pre></td></tr></table></figure>

<p>使用AtomicInteger之后，最终的输出结果同样可以保证是200。并且在某些情况下，代码的性能会比Synchronized更好。</p>
<p>而Atomic操作的底层实现正是利用的CAS机制，好的，我们切入到这个博客的正点。</p>
<h1 id="1-什么是CAS机制"><a href="#1-什么是CAS机制" class="headerlink" title="1.什么是CAS机制"></a>1.什么是CAS机制</h1><p>CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。</p>
<p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p>
<p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p>
<p>这样说或许有些抽象，我们来看一个例子：</p>
<p>1.在内存地址V当中，存储着值为10的变量。</p>
<p><img src="dxc-cas.assets/image-20200528232719629.png" alt="image-20200528232719629"></p>
<p>2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。</p>
<p><img src="dxc-cas.assets/image-20200528232743294.png" alt="image-20200528232743294"></p>
<p>3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</p>
<p><img src="dxc-cas.assets/image-20200528232801348.png" alt="image-20200528232801348"></p>
<p>4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。</p>
<p><img src="dxc-cas.assets/image-20200528232844170.png" alt="image-20200528232844170"></p>
<p>5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋</p>
<p><img src="dxc-cas.assets/image-20200528232902372.png" alt="image-20200528232902372"></p>
<p>6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。</p>
<p><img src="dxc-cas.assets/image-20200528232917312.png" alt="image-20200528232917312"></p>
<p>7.线程1进行SWAP，把地址V的值替换为B，也就是12</p>
<p><img src="dxc-cas.assets/image-20200528232933270.png" alt="image-20200528232933270"></p>
<p>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p>
<p>看到上面的解释是不是索然无味，查找了很多资料也没完全弄明白，通过几次验证后，终于明白，最终可以理解成一个无阻塞多线程争抢资源的模型。先上代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicBoolean;    </span><br><span class="line">public class AtomicBooleanTest implements Runnable &#123;    </span><br><span class="line">    </span><br><span class="line">    private static AtomicBoolean flag &#x3D; new AtomicBoolean(true);    </span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;    </span><br><span class="line">        AtomicBooleanTest ast &#x3D; new AtomicBooleanTest();    </span><br><span class="line">        Thread thread1 &#x3D; new Thread(ast);    </span><br><span class="line">        Thread thread &#x3D; new Thread(ast);    </span><br><span class="line">        thread1.start();    </span><br><span class="line">        thread.start();    </span><br><span class="line">    &#125;    </span><br><span class="line">    @Override    </span><br><span class="line">    public void run() &#123;    </span><br><span class="line">        System.out.println(&quot;thread:&quot;+Thread.currentThread().getName()+&quot;;flag:&quot;+flag.get());    </span><br><span class="line">        if (flag.compareAndSet(true,false))&#123;    </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;&quot;+flag.get());    </span><br><span class="line">            try &#123;    </span><br><span class="line">                Thread.sleep(5000);    </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;    </span><br><span class="line">                e.printStackTrace();    </span><br><span class="line">            &#125;    </span><br><span class="line">            flag.set(true);    </span><br><span class="line">        &#125;else&#123;    </span><br><span class="line">System.out.println(&quot;重试机制thread:&quot;+Thread.currentThread().getName()+&quot;;flag:&quot;+flag.get());    </span><br><span class="line">            try &#123;    </span><br><span class="line">                Thread.sleep(500);    </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;    </span><br><span class="line">                e.printStackTrace();    </span><br><span class="line">            &#125;    </span><br><span class="line">            run();    </span><br><span class="line">        &#125;    </span><br><span class="line">    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.thread:Thread-1;flag:true  </span><br><span class="line">2.thread:Thread-0;flag:true  </span><br><span class="line">3.Thread-1false  </span><br><span class="line">4.重试机制thread:Thread-0;flag:false  </span><br><span class="line">5.thread:Thread-0;flag:false  </span><br><span class="line">6.重试机制thread:Thread-0;flag:false  </span><br><span class="line">7.thread:Thread-0;flag:false  </span><br><span class="line">8.重试机制thread:Thread-0;flag:false  </span><br><span class="line">9.thread:Thread-0;flag:false  </span><br><span class="line">10.重试机制thread:Thread-0;flag:false  </span><br><span class="line">11.thread:Thread-0;flag:false  </span><br><span class="line">12.重试机制thread:Thread-0;flag:false  </span><br><span class="line">13.thread:Thread-0;flag:false  </span><br><span class="line">14.重试机制thread:Thread-0;flag:false  </span><br><span class="line">15.thread:Thread-0;flag:false  </span><br><span class="line">16.重试机制thread:Thread-0;flag:false  </span><br><span class="line">17.thread:Thread-0;flag:false  </span><br><span class="line">18.重试机制thread:Thread-0;flag:false  </span><br><span class="line">19.thread:Thread-0;flag:false  </span><br><span class="line">20.重试机制thread:Thread-0;flag:false  </span><br><span class="line">21.thread:Thread-0;flag:false  </span><br><span class="line">22.重试机制thread:Thread-0;flag:false  </span><br><span class="line">23.thread:Thread-0;flag:true  </span><br><span class="line">24.Thread-0false</span><br></pre></td></tr></table></figure>

<p>这里无论怎么运行，Thread-1、Thread-0都会执行if=true条件，而且还不会产生线程脏读脏写，这是如何做到的了，这就用到了我们的compareAndSet(boolean expect,boolean update)方法<br>我们看到当Thread-1在进行操作的时候，Thread一直在进行重试机制，程序原理图:</p>
<p><img src="dxc-cas.assets/image-20200528233056168.png" alt="image-20200528233056168"></p>
<p>这个图中重最要的是compareAndSet(true,false)方法要拆开成compare(true)方法和Set(false)方法理解，是compare(true)是等于true后，就马上设置共享内存为false，这个时候，其它线程无论怎么走都无法走到只有得到共享内存为true时的程序隔离方法区。</p>
<p>看到这里，这种CAS机制就是完美的吗？这个程序其实存在一个问题，不知道大家注意到没有？</p>
<p>但是这种得不到状态为true时使用递归算法是很耗cpu资源的，所以一般情况下，都会有线程sleep。</p>
<h1 id="2-CAS的缺点"><a href="#2-CAS的缺点" class="headerlink" title="2.CAS的缺点"></a>2.CAS的缺点</h1><ul>
<li>ABA问题。当第一个线程执行CAS操作，尚未修改为新值之前，内存中的值已经被其他线程连续修改了两次，使得变量值经历 A -&gt; B -&gt; A的过程。</li>
</ul>
<p>l解决方案：添加版本号作为标识，每次修改变量值时，对应增加版本号； 做CAS操作前需要校验版本号。JDK1.5之后，新增AtomicStampedReference类来处理这种情况。</p>
<ul>
<li><p>循环时间长开销大。如果有很多个线程并发，CAS自旋可能会长时间不成功，会增大CPU的执行开销。</p>
</li>
<li><p>只能对一个变量进原子操作。JDK1.5之后，新增AtomicReference类来处理这种情况，可以将多个变量放到一个对象中。</p>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">酱油君</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dcghx.github.io/2020/05/09/dxc-cas/">https://dcghx.github.io/2020/05/09/dxc-cas/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dcghx.github.io" target="_blank">酱油村-记事录</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/05/09/jvm-1/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM——(1)</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/09/dxc-synchronized/" title="多线程————synchronized底层原理"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">多线程————synchronized底层原理</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/09/dxc-threadlocal/" title="多线程—-—ThreadLocal"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">多线程—-—ThreadLocal</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/09/dxc-msg/" title="多线程(1)"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">多线程(1)</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 酱油君</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script></body></html>