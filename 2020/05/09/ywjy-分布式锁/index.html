<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>经验积累————分布式锁 | 酱油村-记事录</title><meta name="description" content="前言分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要通过一些互斥手段来防止彼此之间的干扰，以保证一致性，在这种情况下，就需要使用分布式锁了。 简而言之，分布式锁就是指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。 分布式锁要满足哪些要求呢？ 1、互斥性–在分布式系统环境下"><meta name="keywords" content="经验积累"><meta name="author" content="酱油君"><meta name="copyright" content="酱油君"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="经验积累————分布式锁"><meta name="twitter:description" content="前言分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要通过一些互斥手段来防止彼此之间的干扰，以保证一致性，在这种情况下，就需要使用分布式锁了。 简而言之，分布式锁就是指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。 分布式锁要满足哪些要求呢？ 1、互斥性–在分布式系统环境下"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="经验积累————分布式锁"><meta property="og:url" content="https://dcghx.github.io/2020/05/09/ywjy-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"><meta property="og:site_name" content="酱油村-记事录"><meta property="og:description" content="前言分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要通过一些互斥手段来防止彼此之间的干扰，以保证一致性，在这种情况下，就需要使用分布式锁了。 简而言之，分布式锁就是指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。 分布式锁要满足哪些要求呢？ 1、互斥性–在分布式系统环境下"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-05-09T03:15:27.000Z"><meta property="article:modified_time" content="2020-05-31T05:09:45.328Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://dcghx.github.io/2020/05/09/ywjy-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"><link rel="prev" title="MQ————理解、区别、选型、安全" href="https://dcghx.github.io/2020/05/09/mq-%E7%90%86%E8%A7%A3%E3%80%81%E5%8C%BA%E5%88%AB%E3%80%81%E9%80%89%E5%9E%8B%E3%80%81%E5%AE%89%E5%85%A8/"><link rel="next" title="经验积累————缓存双写一致性" href="https://dcghx.github.io/2020/05/09/ywjy-%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="酱油村-记事录" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">27</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-基于数据库的分布式锁"><span class="toc-number">2.</span> <span class="toc-text">1.基于数据库的分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-悲观锁机制"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 悲观锁机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-乐观锁机制"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 乐观锁机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-使用数据库实现分布式锁的问题"><span class="toc-number">2.3.</span> <span class="toc-text">1.3 使用数据库实现分布式锁的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Redis"><span class="toc-number">3.</span> <span class="toc-text">2. Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-redistemplate"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 redistemplate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-分布式redis的原理"><span class="toc-number">3.2.</span> <span class="toc-text">2.1 分布式redis的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-redission"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 redission</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1看门狗watch-dog自动延期机制"><span class="toc-number">3.3.1.</span> <span class="toc-text">2.3.1看门狗watch dog自动延期机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#"><span class="toc-number">3.3.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-锁的原理"><span class="toc-number">3.3.3.</span> <span class="toc-text">2.3.2 锁的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-1-加锁"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">2.3.2.1 加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-2-解锁"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">2.3.2.2 解锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-锁的种类"><span class="toc-number">3.3.4.</span> <span class="toc-text">2.3.3 锁的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-1-可重入锁"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">2.3.3.1 可重入锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-2-公平锁"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">2.3.3.2 公平锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-3-联锁"><span class="toc-number">3.3.4.3.</span> <span class="toc-text">2.3.3.3 联锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-4-红锁"><span class="toc-number">3.3.4.4.</span> <span class="toc-text">2.3.3.4 红锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-5-读写锁"><span class="toc-number">3.3.4.5.</span> <span class="toc-text">2.3.3.5 读写锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-6-信号量"><span class="toc-number">3.3.4.6.</span> <span class="toc-text">2.3.3.6 信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-7-可过期信号量"><span class="toc-number">3.3.4.7.</span> <span class="toc-text">2.3.3.7 可过期信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-8-闭锁"><span class="toc-number">3.3.4.8.</span> <span class="toc-text">2.3.3.8 闭锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4Spring项目集成配置"><span class="toc-number">3.3.5.</span> <span class="toc-text">2.3.4Spring项目集成配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-zookeeper（过段时间填坑）"><span class="toc-number">4.</span> <span class="toc-text">3. zookeeper（过段时间填坑）</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">酱油村-记事录</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">经验积累————分布式锁</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-09 11:15:27"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-09</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-31 13:09:45"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-31</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要通过一些互斥手段来防止彼此之间的干扰，以保证一致性，在这种情况下，就需要使用分布式锁了。<a id="more"></a></p>
<p>简而言之，分布式锁就是指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。</p>
<p>分布式锁要满足哪些要求呢？</p>
<p>1、互斥性–在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；<br>2、高可用的获取锁与释放锁；<br>3、高性能的获取锁与释放锁；<br>4、具备可重入特性–当一个客户端获取锁之后，这个客户端可以再次获取锁。<br>5、具备锁失效机制，防止死锁；<br>6、具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。<br>7、持锁人解锁–加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</p>
<p>一般有三种实现方案</p>
<ul>
<li><p>数据库(乐观锁/悲观锁)</p>
</li>
<li><p>Redis缓存——&gt;Redission</p>
</li>
<li><p>Zookeeper</p>
</li>
</ul>
<p>三种方案比较</p>
<ul>
<li><p>从性能角度：缓存&gt;Zookeeper&gt;MySQL</p>
</li>
<li><p>从实现角度：MySQL&gt;缓存&gt;Zookeeper</p>
</li>
<li><p>从可靠性角度：Zookeeper&gt;缓存&gt;MySQL</p>
</li>
</ul>
<h1 id="1-基于数据库的分布式锁"><a href="#1-基于数据库的分布式锁" class="headerlink" title="1.基于数据库的分布式锁"></a>1.基于数据库的分布式锁</h1><p>基于数据库来做分布式锁的话，通常有两种做法：</p>
<ul>
<li><p>基于数据库的悲观锁</p>
</li>
<li><p>基于数据库的乐观锁</p>
</li>
</ul>
<h2 id="1-1-悲观锁机制"><a href="#1-1-悲观锁机制" class="headerlink" title="1.1 悲观锁机制"></a>1.1 悲观锁机制</h2><p>在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁 （需要注意的是，在InnoDB中只有字段加了索引的，才会是行级锁，否者是表级锁，所以就要给要执行的方法字段名添加索引），当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。我们可以认为获得排他锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后释放锁。</p>
<h2 id="1-2-乐观锁机制"><a href="#1-2-乐观锁机制" class="headerlink" title="1.2 乐观锁机制"></a>1.2 乐观锁机制</h2><p>乐观锁机制其实就是在数据库表中引入一个版本号（version）字段来实现的。</p>
<p>当我们要从数据库中读取数据的时候，同时把这个version字段也读出来，如果要对读出来的数据进行更新后写回数据库，则需要将version加1，同时将新的数据与新的version更新到数据表中，且必须在更新的时候同时检查目前数据库里version值是不是之前的那个version，如果是，则正常更新。如果不是，则更新失败，说明在这个过程中有其它的进程去更新过数据了。</p>
<h2 id="1-3-使用数据库实现分布式锁的问题"><a href="#1-3-使用数据库实现分布式锁的问题" class="headerlink" title="1.3 使用数据库实现分布式锁的问题"></a>1.3 使用数据库实现分布式锁的问题</h2><p>1.因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换。</p>
<p>2.不具备可重入的特性。在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁。</p>
<p>3.没有锁失效机制。在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据。</p>
<p>4.不具备阻塞锁特性。获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。</p>
<p>5.非公平的。再建一张中间表，将等待锁的线程全记录下来，并根据创建时间排序，只有最先创建的允许获取锁。</p>
<h1 id="2-Redis"><a href="#2-Redis" class="headerlink" title="2. Redis"></a>2. Redis</h1><h2 id="2-1-redistemplate"><a href="#2-1-redistemplate" class="headerlink" title="2.1 redistemplate"></a>2.1 redistemplate</h2><p>分布式锁实现的关键是在分布式的应用服务器外，搭建一个存储服务器，存储锁信息，这时候我们很容易就想到了Redis。首先我们要搭建一个Redis服务器，用Redis服务器来存储锁信息。</p>
<p>在实现的时候要注意的几个关键点：</p>
<p>1、锁信息必须是会过期超时的，不能让一个线程长期占有一个锁而导致死锁；</p>
<p>2、同一时刻只能有一个线程获取到锁。</p>
<p>RedisTemplate中定义了5种数据结构操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue();　　&#x2F;&#x2F;操作字符串  </span><br><span class="line">redisTemplate.opsForHash();　　 &#x2F;&#x2F;操作hash  </span><br><span class="line">redisTemplate.opsForList();　　 &#x2F;&#x2F;操作list  </span><br><span class="line">redisTemplate.opsForSet();　　  &#x2F;&#x2F;操作set  </span><br><span class="line">redisTemplate.opsForZSet();　 　&#x2F;&#x2F;操作有序set</span><br></pre></td></tr></table></figure>

<p>StringRedisTemplate常用操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;向redis里存入数据和设置缓存时间  </span><br><span class="line">stringRedisTemplate.opsForValue().set(&quot;test&quot;, &quot;100&quot;,60*10,TimeUnit.SECONDS);    </span><br><span class="line">stringRedisTemplate.boundValueOps(&quot;test&quot;).increment(-1);&#x2F;&#x2F;val做-1操作  </span><br><span class="line">stringRedisTemplate.opsForValue().get(&quot;test&quot;)&#x2F;&#x2F;根据key获取缓存中的val  </span><br><span class="line">stringRedisTemplate.boundValueOps(&quot;test&quot;).increment(1);&#x2F;&#x2F;val +1   </span><br><span class="line">stringRedisTemplate.getExpire(&quot;test&quot;)&#x2F;&#x2F;根据key获取过期时间  </span><br><span class="line">&#x2F;&#x2F;根据key获取过期时间并换算成指定单位   </span><br><span class="line">stringRedisTemplate.getExpire(&quot;test&quot;,TimeUnit.SECONDS)   </span><br><span class="line">stringRedisTemplate.delete(&quot;test&quot;);&#x2F;&#x2F;根据key删除缓存  </span><br><span class="line">tringRedisTemplate.hasKey(&quot;546545&quot;);&#x2F;&#x2F;检查key是否存在，返回boolean值    </span><br><span class="line">&#x2F;&#x2F;向指定key中存放set集合  </span><br><span class="line">stringRedisTemplate.opsForSet().add(&quot;red_123&quot;, &quot;1&quot;,&quot;2&quot;,&quot;3&quot;);  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;设置过期时间  </span><br><span class="line">stringRedisTemplate.expire(&quot;red_123&quot;,1000 , TimeUnit.MILLISECONDS);  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;根据key查看集合中是否存在指定数据  </span><br><span class="line">stringRedisTemplate.opsForSet().isMember(&quot;red_123&quot;, &quot;1&quot;)  </span><br><span class="line">  </span><br><span class="line">stringRedisTemplate.opsForSet().members(&quot;red_123&quot;);&#x2F;&#x2F;根据key获取set集合</span><br></pre></td></tr></table></figure>

<p>利用redis实现一套简单的加锁解锁流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.log.info(Thread.currentThread()+&quot;开始尝试加锁！&quot;);  </span><br><span class="line">2.&#x2F;&#x2F;尝试加锁，加锁成功则返回true，否则则返回false，设置锁的有效时间  </span><br><span class="line">3.boolean b &#x3D; stringRedisTemplate.opsForValue().setIfAbsent(&quot;k1&quot;,null,60, TimeUnit.SECONDS);  </span><br><span class="line">4.&#x2F;&#x2F;返回true，该线程争取到锁  </span><br><span class="line">5.if(b)&#123;  </span><br><span class="line">6.    &#x2F;&#x2F;执行逻辑  </span><br><span class="line">7.    log.info(Thread.currentThread()+&quot;加锁成功，执行业务逻辑！&quot;);  </span><br><span class="line">8.    &#x2F;&#x2F;执行无异常，释放锁  </span><br><span class="line">9.    stringRedisTemplate.delete(&quot;k1&quot;);  </span><br><span class="line">10.&#125;  </span><br><span class="line">11.&#x2F;&#x2F;没有争取到锁：策略1——直接失败  策略2——循环一段时间长获取锁  </span><br><span class="line">12.else &#123;  </span><br><span class="line">13.      </span><br><span class="line">14.&#125;</span><br></pre></td></tr></table></figure>

<p>从上边代码我们可以看到整个流程是可以简单地实现分布式锁的要求的：锁有超时自毁机制、同时只能有一个客户端线程拿到锁。看着是没什么毛病，但是有一个很大的问题存在：如果执行业务逻辑需要时间超过了锁的的有效时间怎么办？种种原因不可能知道业务需要多久执行完毕，这就可能导致多个客户端线程拿到锁，产生异常。如何解决呢？就需要一种机制可以在锁的有效时间内检查锁是否仍然没有被释放，自动延长有效时间，Ression就可以做到。</p>
<h2 id="2-1-分布式redis的原理"><a href="#2-1-分布式redis的原理" class="headerlink" title="2.1 分布式redis的原理"></a>2.1 分布式redis的原理</h2><p>由上文可知，Redis是以哈希槽的形式对集群进行划分的，整个集群的哈希槽一共有16384个，在有3个Redis实例的情况下，节点A包含从0到5500的哈希槽，节点B包含从5501到11000 的哈希槽，节点C包含从11001到16384的哈希槽。当有新的节点添加进来的时候，会从当前的各个节点中选取一定的槽分配给新添加的节点，当有节点从集群中被删除时，则会将当前节点的槽分配给集群中其他正在运行的节点。每当有新的key添加到Redis中时，会根据算法算出相应的哈希槽来找到对应的集群节点。</p>
<h2 id="2-3-redission"><a href="#2-3-redission" class="headerlink" title="2.3 redission"></a>2.3 redission</h2><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<p>简单理解Redisson是一个工具集，封装了多个调用redis的api方法，功能强大。我们回到上节中提到的问题：业务没有执行完，锁超时释放了怎么办？Ression是如何解决的呢？</p>
<h3 id="2-3-1看门狗watch-dog自动延期机制"><a href="#2-3-1看门狗watch-dog自动延期机制" class="headerlink" title="2.3.1看门狗watch dog自动延期机制"></a>2.3.1看门狗watch dog自动延期机制</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="ywjy-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.assets/image-20200531125537691.png" alt="image-20200531125537691"></h3><p>我们来已一段代码demo来看看aip的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Config config &#x3D; new Config(); </span><br><span class="line">2.config.useSingleServer().setAddress(&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;);  </span><br><span class="line">3.RedissonClient redisson &#x3D; Redisson.create(config);  </span><br><span class="line">4.RLock lock &#x3D; redisson.getLock(&quot;anyLock&quot;);  </span><br><span class="line">5.  </span><br><span class="line">6.lock.lock(); </span><br><span class="line">7.&#x2F;&#x2F;lock.unlock();</span><br></pre></td></tr></table></figure>

<p>我们来看看getLoack方法的源码：</p>
<p><img src="ywjy-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.assets/image-20200531125607556.png" alt="image-20200531125607556"></p>
<p>从这里我们知道,internalLockLeaseTime 和 lockWatchdogTimeout这两个参数是相等的.<br>lockWatchdogTimeout默认值如下（Config类）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.public class Config &#123;  </span><br><span class="line">2.  </span><br><span class="line">3.private long lockWatchdogTimeout &#x3D; 30 * 1000;  </span><br><span class="line">4.  </span><br><span class="line">5.public long getLockWatchdogTimeout() &#123;  </span><br><span class="line">6.  </span><br><span class="line">7.return lockWatchdogTimeout;  </span><br><span class="line">8.  </span><br><span class="line">9.&#125;  </span><br><span class="line">10.  </span><br><span class="line">11.&#x2F;&#x2F;省略无关代码  </span><br><span class="line">12.  </span><br><span class="line">13.&#125;</span><br></pre></td></tr></table></figure>

<p>从internalLockLeaseTime这个单词也可以看出,这个加的分布式锁的超时时间默认是30秒.但是还有一个问题,那就是这个看门狗,多久来延长一次有效期呢?我们往下看Lock方法</p>
<p><img src="ywjy-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.assets/image-20200531125648876.png" alt="image-20200531125648876"></p>
<p>从我图中框起来的地方我们就知道了,获取锁成功就会开启一个定时任务,也就是watchdog,定时任务会定期检查去续期renewExpirationAsync(threadId).这里定时用的是netty-common包中的HashedWheelTimer,从图中我们明白,该定时调度每次调用的时间差是internalLockLeaseTime / 3.也就10秒.</p>
<p>通过源码分析我们知道,默认情况下,加锁的时间是30秒.如果加锁的业务没有执行完,那么到 30-10 = 20秒的时候,就会进行一次续期,把锁重置成30秒.那这个时候可能又有同学问了,那业务的机器万一宕机了呢?宕机了定时任务跑不了,就续不了期,那自然30秒之后锁就解开了呗.</p>
<p>原理图：</p>
<p><img src="ywjy-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.assets/image-20200531130005949.png" alt="image-20200531130005949"></p>
<h3 id="2-3-2-锁的原理"><a href="#2-3-2-锁的原理" class="headerlink" title="2.3.2 锁的原理"></a>2.3.2 锁的原理</h3><p>在Redisson中，使用key来作为是否上锁的标志，当通过getLock(String key)方法获得相应的锁之后，这个key即作为一个锁存储到Redis集群中，在接下来如果有其他的线程尝试获取名为key的锁时，便会向集群中进行查询，如果能够查到这个锁并发现相应的value的值不为0，则表示已经有其他线程申请了这个锁同时还没有释放，则当前线程进入阻塞，否则由当前线程获取这个锁并将value值加一，如果是可重入锁的话，则当前线程每获得一个自身线程的锁，就将value的值加一，而每释放一个锁则将value值减一，直到减至0，完全释放这个锁。因为底层是基于分布式的Redis集群，所以Redisson实现了分布式的锁机制。</p>
<h4 id="2-3-2-1-加锁"><a href="#2-3-2-1-加锁" class="headerlink" title="2.3.2.1 加锁"></a>2.3.2.1 加锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Future tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId) &#123;  </span><br><span class="line">    internalLockLeaseTime &#x3D; unit.toMillis(leaseTime);  </span><br><span class="line">    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_LONG,  </span><br><span class="line">        &#x2F;&#x2F; 检查是否key已经被占用，如果没有则设置超时时间和唯一标识，初始化value&#x3D;1  </span><br><span class="line">        &quot;if (redis.call(&#39;exists&#39;, KEYS[1]) &#x3D;&#x3D; 0) then &quot; +  </span><br><span class="line">            &quot;redis.call(&#39;hset&#39;, KEYS[1], ARGV[2], 1); &quot; +  </span><br><span class="line">            &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot; +  </span><br><span class="line">            &quot;return nil; &quot; +  </span><br><span class="line">        &quot;end; &quot; +  </span><br><span class="line">        &#x2F;&#x2F; 如果锁重入,需要判断锁的key field 都一直情况下 value 加一  </span><br><span class="line">        &quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) &#x3D;&#x3D; 1) then &quot; +  </span><br><span class="line">            &quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot; +  </span><br><span class="line">            &#x2F;&#x2F;锁重入重新设置超时时间  </span><br><span class="line">            &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot; +  </span><br><span class="line">            &quot;return nil; &quot; +  </span><br><span class="line">        &quot;end; &quot; +  </span><br><span class="line">        &#x2F;&#x2F; 返回剩余的过期时间  </span><br><span class="line">        &quot;return redis.call(&#39;pttl&#39;, KEYS[1]);&quot;,  </span><br><span class="line">        Collections.singletonList(getName()), internalLockLeaseTime, getLockName(threadId));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Redisson中，加锁需要以下三个参数：</p>
<ul>
<li><p>KEYS[1] ：需要加锁的key，这里需要是字符串类型。</p>
</li>
<li><p>ARGV[1] ：锁的超时时间，防止死锁</p>
</li>
<li><p>ARGV[2] ：锁的唯一标识，id（UUID.randomUUID()） + “:” + threadId</p>
</li>
</ul>
<h4 id="2-3-2-2-解锁"><a href="#2-3-2-2-解锁" class="headerlink" title="2.3.2.2 解锁"></a>2.3.2.2 解锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;  </span><br><span class="line">        Boolean opStatus &#x3D; commandExecutor.evalWrite(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,  </span><br><span class="line">        &#x2F;&#x2F; 如果key已经不存在，说明已经被解锁，直接发布（publihs）redis消息  </span><br><span class="line">        &quot;if (redis.call(&#39;exists&#39;, KEYS[1]) &#x3D;&#x3D; 0) then &quot; +  </span><br><span class="line">        &quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &quot; +  </span><br><span class="line">        &quot;return 1; &quot; +  </span><br><span class="line">        &quot;end;&quot; +  </span><br><span class="line">        &#x2F;&#x2F; key和field不匹配，说明当前客户端线程没有持有锁，不能主动解锁。  </span><br><span class="line">        &quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[3]) &#x3D;&#x3D; 0) then &quot; +  </span><br><span class="line">        &quot;return nil;&quot; +  </span><br><span class="line">        &quot;end; &quot; +  </span><br><span class="line">        &quot;local counter &#x3D; redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[3], -1); &quot; +  </span><br><span class="line">        &#x2F;&#x2F; 如果counter&gt;0说明锁在重入，不能删除key  </span><br><span class="line">        &quot;if (counter &gt; 0) then &quot; +  </span><br><span class="line">        &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[2]); &quot; +  </span><br><span class="line">        &quot;return 0; &quot; +  </span><br><span class="line">        &quot;else &quot; +  </span><br><span class="line">        &#x2F;&#x2F; 删除key并且publish 解锁消息  </span><br><span class="line">        &quot;redis.call(&#39;del&#39;, KEYS[1]); &quot; +  </span><br><span class="line">        &quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &quot; +  </span><br><span class="line">        &quot;return 1; &quot;+  </span><br><span class="line">        &quot;end; &quot; +  </span><br><span class="line">        &quot;return nil;&quot;,  </span><br><span class="line">        Arrays.asList(getName(), getChannelName()), LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(Thread.currentThread().getId()));  </span><br><span class="line">        if (opStatus &#x3D;&#x3D; null) &#123;  </span><br><span class="line">                throw new IllegalMonitorStateException(&quot;attempt to unlock lock, not locked by current thread by node id: &quot;  </span><br><span class="line">                        + id + &quot; thread-id: &quot; + Thread.currentThread().getId());  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#x2F;&#x2F; 解锁成功之后取消更新锁expire的时间任务  </span><br><span class="line">        if (opStatus) &#123;  </span><br><span class="line">                cancelExpirationRenewal();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在Redisson中解锁需要以下五个参数：</p>
<ul>
<li><p>KEYS[1] ：需要加锁的key，这里需要是字符串类型。</p>
</li>
<li><p>KEYS[2] ：redis消息的ChannelName,一个分布式锁对应唯一的一个channelName:“redisson_lock__channel__{” + getName() + “}”</p>
</li>
<li><p>ARGV[1] ：reids消息体，这里只需要一个字节的标记就可以，主要标记redis的key已经解锁，再结合redis的Subscribe，能唤醒其他订阅解锁消息的客户端线程申请锁。</p>
</li>
<li><p>ARGV[2] ：锁的超时时间，防止死锁</p>
</li>
<li><p>ARGV[3] ：锁的唯一标识，也就是刚才介绍的 id（UUID.randomUUID()） + “:” + threadId</p>
</li>
</ul>
<h3 id="2-3-3-锁的种类"><a href="#2-3-3-锁的种类" class="headerlink" title="2.3.3 锁的种类"></a>2.3.3 锁的种类</h3><h4 id="2-3-3-1-可重入锁"><a href="#2-3-3-1-可重入锁" class="headerlink" title="2.3.3.1 可重入锁"></a>2.3.3.1 可重入锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.RLock lock &#x3D; redisson.getLock(&quot;anyLock&quot;);  </span><br><span class="line">2.&#x2F;&#x2F; 最常见的使用方法  </span><br><span class="line">3.lock.lock();  </span><br><span class="line">4....  </span><br><span class="line">5.lock.unlock()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;&#x2F; 加锁以后10秒钟自动解锁 </span><br><span class="line">2.lock.lock(10, TimeUnit.SECONDS);    </span><br><span class="line">3.&#x2F;&#x2F; 尝试加锁，最多等待100秒，上锁以后10秒自动解锁  </span><br><span class="line">4.boolean res &#x3D; lock.tryLock(100, 10, TimeUnit.SECONDS);  </span><br><span class="line">5....  </span><br><span class="line">6.lock.unlock();</span><br></pre></td></tr></table></figure>



<h4 id="2-3-3-2-公平锁"><a href="#2-3-3-2-公平锁" class="headerlink" title="2.3.3.2 公平锁"></a>2.3.3.2 公平锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.RLock fairLock &#x3D; redisson.getFairLock(&quot;anyLock&quot;);  </span><br><span class="line">2.&#x2F;&#x2F; 最常见的使用方法  </span><br><span class="line">3.fairLock.lock();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;&#x2F; 10秒钟以后自动解锁  </span><br><span class="line">2.fairLock.lock(10, TimeUnit.SECONDS);    </span><br><span class="line">3.&#x2F;&#x2F; 尝试加锁，最多等待100秒，上锁以后10秒自动解锁  </span><br><span class="line">4.boolean res &#x3D; fairLock.tryLock(100, 10, TimeUnit.SECONDS);  </span><br><span class="line">5....  </span><br><span class="line">6.fairLock.unlock();</span><br></pre></td></tr></table></figure>

<p>Redisson同时还为分布式可重入公平锁提供了异步执行的相关方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.RLock fairLock &#x3D; redisson.getFairLock(&quot;anyLock&quot;);  </span><br><span class="line">2.fairLock.lockAsync();  </span><br><span class="line">3.fairLock.lockAsync(10, TimeUnit.SECONDS);  </span><br><span class="line">Future&lt;Boolean&gt; res &#x3D; fairLock.tryLockAsync(100, 10, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>



<h4 id="2-3-3-3-联锁"><a href="#2-3-3-3-联锁" class="headerlink" title="2.3.3.3 联锁"></a>2.3.3.3 联锁</h4><p>基于Redis的Redisson分布式联锁RedissonMultiLock对象可以将多个RLock对象关联为一个联锁，每个RLock对象实例可以来自于不同的Redisson实例。所有的锁都上锁成功才算成功。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.RLock lock1 &#x3D; redissonInstance1.getLock(&quot;lock1&quot;);  </span><br><span class="line">2.RLock lock2 &#x3D; redissonInstance2.getLock(&quot;lock2&quot;);  </span><br><span class="line">3.RLock lock3 &#x3D; redissonInstance3.getLock(&quot;lock3&quot;);  </span><br><span class="line">4.  </span><br><span class="line">5.RedissonMultiLock lock &#x3D; new RedissonMultiLock(lock1, lock2, lock3);  </span><br><span class="line">6.&#x2F;&#x2F; 同时加锁：lock1 lock2 lock3，所有的锁都上锁成功才算成功。  </span><br><span class="line">7.lock.lock();  </span><br><span class="line">8....  </span><br><span class="line">9.lock.unlock();</span><br></pre></td></tr></table></figure>



<h4 id="2-3-3-4-红锁"><a href="#2-3-3-4-红锁" class="headerlink" title="2.3.3.4 红锁"></a>2.3.3.4 红锁</h4><p>基于Redis的Redisson红锁RedissonRedLock对象实现了Redlock介绍的加锁算法。该对象也可以用来将多个RLock对象关联为一个红锁，每个RLock对象实例可以来自于不同的Redisson实例。红锁在大部分节点上加锁成功就算成功。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.RLock lock1 &#x3D; redissonInstance1.getLock(&quot;lock1&quot;);  </span><br><span class="line">2.RLock lock2 &#x3D; redissonInstance2.getLock(&quot;lock2&quot;);  </span><br><span class="line">3.RLock lock3 &#x3D; redissonInstance3.getLock(&quot;lock3&quot;);  </span><br><span class="line">4.  </span><br><span class="line">5.RedissonRedLock lock &#x3D; new RedissonRedLock(lock1, lock2, lock3);  </span><br><span class="line">6.&#x2F;&#x2F; 同时加锁：lock1 lock2 lock3，红锁在大部分节点上加锁成功就算成功。  </span><br><span class="line">7.lock.lock();  </span><br><span class="line">8....  </span><br><span class="line">9.lock.unlock();</span><br></pre></td></tr></table></figure>

<p>另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.RedissonRedLock lock &#x3D; new RedissonRedLock(lock1, lock2, lock3);  </span><br><span class="line">2.&#x2F;&#x2F; 给lock1，lock2，lock3加锁，如果没有手动解开的话，10秒钟后将会自动解开  </span><br><span class="line">3.lock.lock(10, TimeUnit.SECONDS);    </span><br><span class="line">4.&#x2F;&#x2F; 为加锁等待100秒时间，并在加锁成功10秒钟后自动解开  </span><br><span class="line">5.boolean res &#x3D; lock.tryLock(100, 10, TimeUnit.SECONDS);  </span><br><span class="line">6....  </span><br><span class="line">7.lock.unlock();</span><br></pre></td></tr></table></figure>



<h4 id="2-3-3-5-读写锁"><a href="#2-3-3-5-读写锁" class="headerlink" title="2.3.3.5 读写锁"></a>2.3.3.5 读写锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.RReadWriteLock rwlock &#x3D; redisson.getLock(&quot;anyRWLock&quot;);  </span><br><span class="line">2.&#x2F;&#x2F; 最常见的使用方法  </span><br><span class="line">3.rwlock.readLock().lock();  </span><br><span class="line">4.&#x2F;&#x2F; 或  </span><br><span class="line">5.rwlock.writeLock().lock();</span><br></pre></td></tr></table></figure>



<h4 id="2-3-3-6-信号量"><a href="#2-3-3-6-信号量" class="headerlink" title="2.3.3.6 信号量"></a>2.3.3.6 信号量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.RSemaphore semaphore &#x3D; redisson.getSemaphore(&quot;semaphore&quot;);  </span><br><span class="line">2.semaphore.acquire();  </span><br><span class="line">3.&#x2F;&#x2F;或  </span><br><span class="line">4.semaphore.acquireAsync();  </span><br><span class="line">5.semaphore.acquire(23);  </span><br><span class="line">6.semaphore.tryAcquire();  </span><br><span class="line">7.&#x2F;&#x2F;或  </span><br><span class="line">8.semaphore.tryAcquireAsync();  </span><br><span class="line">9.semaphore.tryAcquire(23, TimeUnit.SECONDS);  </span><br><span class="line">10.&#x2F;&#x2F;或  </span><br><span class="line">11.semaphore.tryAcquireAsync(23, TimeUnit.SECONDS);  </span><br><span class="line">12.semaphore.release(10);  </span><br><span class="line">13.semaphore.release();  </span><br><span class="line">14.&#x2F;&#x2F;或  </span><br><span class="line">15.semaphore.releaseAsync();</span><br></pre></td></tr></table></figure>



<h4 id="2-3-3-7-可过期信号量"><a href="#2-3-3-7-可过期信号量" class="headerlink" title="2.3.3.7 可过期信号量"></a>2.3.3.7 可过期信号量</h4><p>基于Redis的Redisson可过期性信号量（PermitExpirableSemaphore）是在RSemaphore对象的基础上，为每个信号增加了一个过期时间。每个信号可以通过独立的ID来辨识，释放时只能通过提交这个ID才能释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RPermitExpirableSemaphore semaphore &#x3D; redisson.getPermitExpirableSemaphore(&quot;mySemaphore&quot;);  </span><br><span class="line">String permitId &#x3D; semaphore.acquire();  </span><br><span class="line">&#x2F;&#x2F; 获取一个信号，有效期只有2秒钟。  </span><br><span class="line">String permitId &#x3D; semaphore.acquire(2, TimeUnit.SECONDS);  </span><br><span class="line">&#x2F;&#x2F; ...  </span><br><span class="line">semaphore.release(permitId);</span><br></pre></td></tr></table></figure>



<h4 id="2-3-3-8-闭锁"><a href="#2-3-3-8-闭锁" class="headerlink" title="2.3.3.8 闭锁"></a>2.3.3.8 闭锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.RCountDownLatch latch &#x3D; redisson.getCountDownLatch(&quot;anyCountDownLatch&quot;);  </span><br><span class="line">2.latch.trySetCount(1);  </span><br><span class="line">3.latch.await();  </span><br><span class="line">4.  </span><br><span class="line">5.&#x2F;&#x2F; 在其他线程或其他JVM里  </span><br><span class="line">6.RCountDownLatch latch &#x3D; redisson.getCountDownLatch(&quot;anyCountDownLatch&quot;);  </span><br><span class="line">7.latch.countDown();</span><br></pre></td></tr></table></figure>



<h3 id="2-3-4Spring项目集成配置"><a href="#2-3-4Spring项目集成配置" class="headerlink" title="2.3.4Spring项目集成配置"></a>2.3.4Spring项目集成配置</h3><ul>
<li>pom</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.&lt;dependency&gt;  </span><br><span class="line">2.    &lt;groupId&gt;org.redisson&lt;&#x2F;groupId&gt;  </span><br><span class="line">3.    &lt;artifactId&gt;redisson&lt;&#x2F;artifactId&gt;  </span><br><span class="line">4.    &lt;version&gt;2.2.12&lt;&#x2F;version&gt;  </span><br><span class="line">5.&lt;&#x2F;dependency&gt;  </span><br><span class="line">6.&lt;dependency&gt;  </span><br><span class="line">7.    &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;  </span><br><span class="line">8.    &lt;artifactId&gt;jackson-annotations&lt;&#x2F;artifactId&gt;  </span><br><span class="line">9.    &lt;version&gt;2.6.0&lt;&#x2F;version&gt;  </span><br><span class="line">10.&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>xml配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;redisson:client  </span><br><span class="line">    id&#x3D;&quot;redisson&quot;  </span><br><span class="line">    name&#x3D;&quot;redisson1,redisson2&quot;  </span><br><span class="line">    threads&#x3D;&quot;0&quot;  </span><br><span class="line">    netty-threads&#x3D;&quot;0&quot;  </span><br><span class="line">    codec-ref&#x3D;&quot;myCodec&quot;   </span><br><span class="line">    transport-mode&#x3D;&quot;NIO&quot;  </span><br><span class="line">    redisson-reference-enabled&#x3D;&quot;true&quot;  </span><br><span class="line">    codec-provider-ref&#x3D;&quot;myCodecProvider&quot;  </span><br><span class="line">    resolver-provider-ref&#x3D;&quot;myResolverProvider&quot;  </span><br><span class="line">    executor-ref&#x3D;&quot;myExecutor&quot;  </span><br><span class="line">    event-loop-group-ref&#x3D;&quot;myEventLoopGroup&quot;&gt;  </span><br><span class="line"> &lt;!--这里的name属性和qualifier子元素不能同时使用。id和name的属性都可以被用来作为qualifier的备选值。  --&gt;  </span><br><span class="line">    &lt;!--&lt;qualifier value&#x3D;&quot;redisson3&quot;&#x2F;&gt;--&gt;  </span><br><span class="line">    &lt;redisson:cluster-servers  </span><br><span class="line">        idle-connection-timeout&#x3D;&quot;10000&quot;  </span><br><span class="line">        ping-timeout&#x3D;&quot;1000&quot;  </span><br><span class="line">        connect-timeout&#x3D;&quot;10000&quot;  </span><br><span class="line">        timeout&#x3D;&quot;3000&quot;  </span><br><span class="line">        retry-attempts&#x3D;&quot;3&quot;  </span><br><span class="line">        retry-interval&#x3D;&quot;1500&quot;  </span><br><span class="line">        reconnection-timeout&#x3D;&quot;3000&quot;  </span><br><span class="line">        failed-attempts&#x3D;&quot;3&quot;  </span><br><span class="line">        password&#x3D;&quot;do_not_use_if_it_is_not_set&quot;  </span><br><span class="line">        subscriptions-per-connection&#x3D;&quot;5&quot;  </span><br><span class="line">        client-name&#x3D;&quot;none&quot;  </span><br><span class="line">        load-balancer-ref&#x3D;&quot;myLoadBalancer&quot;  </span><br><span class="line">        subscription-connection-minimum-idle-size&#x3D;&quot;1&quot;  </span><br><span class="line">        subscription-connection-pool-size&#x3D;&quot;50&quot;  </span><br><span class="line">        slave-connection-minimum-idle-size&#x3D;&quot;10&quot;  </span><br><span class="line">        slave-connection-pool-size&#x3D;&quot;64&quot;  </span><br><span class="line">        master-connection-minimum-idle-size&#x3D;&quot;10&quot;  </span><br><span class="line">        master-connection-pool-size&#x3D;&quot;64&quot;  </span><br><span class="line">        read-mode&#x3D;&quot;SLAVE&quot;  </span><br><span class="line">        subscription-mode&#x3D;&quot;SLAVE&quot;  </span><br><span class="line">        scan-interval&#x3D;&quot;1000&quot;&gt;  </span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot; &#x2F;&gt;  </span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6380&quot; &#x2F;&gt;  </span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6381&quot; &#x2F;&gt;  </span><br><span class="line">    &lt;&#x2F;redisson:cluster-servers&gt;  </span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>最基本配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.&lt;!-- 最基本配置 --&gt;  </span><br><span class="line">2.&lt;redisson:client&gt;  </span><br><span class="line">3.    &lt;redisson:cluster-servers&gt;  </span><br><span class="line">4.        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot; &#x2F;&gt;  </span><br><span class="line">5.        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6380&quot; &#x2F;&gt;  </span><br><span class="line">6.        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6381&quot; &#x2F;&gt;  </span><br><span class="line">7.        ...  </span><br><span class="line">8.    &lt;&#x2F;redisson:cluster-servers&gt;  </span><br><span class="line">9.&lt;&#x2F;redisson:client&gt;</span><br></pre></td></tr></table></figure>



<h1 id="3-zookeeper（过段时间填坑）"><a href="#3-zookeeper（过段时间填坑）" class="headerlink" title="3. zookeeper（过段时间填坑）"></a>3. zookeeper（过段时间填坑）</h1></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">酱油君</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dcghx.github.io/2020/05/09/ywjy-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">https://dcghx.github.io/2020/05/09/ywjy-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dcghx.github.io" target="_blank">酱油村-记事录</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/">经验积累</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/09/mq-%E7%90%86%E8%A7%A3%E3%80%81%E5%8C%BA%E5%88%AB%E3%80%81%E9%80%89%E5%9E%8B%E3%80%81%E5%AE%89%E5%85%A8/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MQ————理解、区别、选型、安全</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/09/ywjy-%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">经验积累————缓存双写一致性</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/09/ywjy-api 防刷限流/" title="经验积累————API接口防刷限流"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">经验积累————API接口防刷限流</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/09/ywjy-单点登录/" title="经验积累————单点登录"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">经验积累————单点登录</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/09/ywjy-缓存双写一致性/" title="经验积累————缓存双写一致性"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">经验积累————缓存双写一致性</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/09/ywjy-接口幂等性/" title="经验积累————接口幂等性"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">经验积累————接口幂等性</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/09/ywjy-系统如何支撑高并发-思路 副本/" title="经验积累————系统如何支撑高并发-思路"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">经验积累————系统如何支撑高并发-思路</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/09/ywjy-基于代码级别的读写分离/" title="经验积累————基于代码级别的读写分离"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">经验积累————基于代码级别的读写分离</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 酱油君</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script></body></html>