<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>spring-1 | 酱油村-记事录</title><meta name="description" content="简单认识一下spring 1.Spring Framework 模块 1.1 spring核心容器该层基本上是 Spring Framework 的核心。它包含以下模块：  Spring Core Spring Bean SpEl (Spring Expression language) Spring Context  1.2数据访问&#x2F;集成该层提供与数据库交互的支持。它包含以下模块：  JDBC"><meta name="keywords" content="spring"><meta name="author" content="酱油君"><meta name="copyright" content="酱油君"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="spring-1"><meta name="twitter:description" content="简单认识一下spring 1.Spring Framework 模块 1.1 spring核心容器该层基本上是 Spring Framework 的核心。它包含以下模块：  Spring Core Spring Bean SpEl (Spring Expression language) Spring Context  1.2数据访问&#x2F;集成该层提供与数据库交互的支持。它包含以下模块：  JDBC"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="spring-1"><meta property="og:url" content="https://dcghx.github.io/2020/05/09/spring-1/"><meta property="og:site_name" content="酱油村-记事录"><meta property="og:description" content="简单认识一下spring 1.Spring Framework 模块 1.1 spring核心容器该层基本上是 Spring Framework 的核心。它包含以下模块：  Spring Core Spring Bean SpEl (Spring Expression language) Spring Context  1.2数据访问&#x2F;集成该层提供与数据库交互的支持。它包含以下模块：  JDBC"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-05-09T03:15:27.000Z"><meta property="article:modified_time" content="2020-05-30T16:18:32.281Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://dcghx.github.io/2020/05/09/spring-1/"><link rel="prev" title="IO————1" href="https://dcghx.github.io/2020/05/09/IO-1/"><link rel="next" title="经验积累————API接口防刷限流" href="https://dcghx.github.io/2020/05/09/ywjy-api%20%E9%98%B2%E5%88%B7%E9%99%90%E6%B5%81/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="酱油村-记事录" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">35</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Spring-Framework-模块"><span class="toc-number">1.</span> <span class="toc-text">1.Spring Framework 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-spring核心容器"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 spring核心容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2数据访问-集成"><span class="toc-number">1.2.</span> <span class="toc-text">1.2数据访问&#x2F;集成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-web"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 web</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4AOP"><span class="toc-number">1.4.</span> <span class="toc-text">1.4AOP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5Instrumentation"><span class="toc-number">1.5.</span> <span class="toc-text">1.5Instrumentation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6Test"><span class="toc-number">1.6.</span> <span class="toc-text">1.6Test</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-Messaging"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 Messaging</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-Aspect"><span class="toc-number">1.8.</span> <span class="toc-text">1.8 Aspect</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-IOC"><span class="toc-number">2.</span> <span class="toc-text">2. IOC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1什么是IOC-DI"><span class="toc-number">2.1.</span> <span class="toc-text">2.1什么是IOC&#x2F;DI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-spring-IOC"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 spring IOC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-总结"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-面向切面编程AOP"><span class="toc-number">3.</span> <span class="toc-text">3. 面向切面编程AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-AOP名词"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 AOP名词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-pointcut用法"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 pointcut用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-一个例子"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 一个例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-动态代理-静待代理"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 动态代理&#x2F;静待代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-静态代理"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1 静态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-动态代理"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2 动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-1-JDK动态代理"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">3.4.2.1 JDK动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-2-CGLB动态代理"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">3.4.2.2 CGLB动态代理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-spring原理概述"><span class="toc-number">4.</span> <span class="toc-text">4. spring原理概述</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">酱油村-记事录</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">spring-1</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-09 11:15:27"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-09</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-31 00:18:32"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-31</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>简单认识一下spring<a id="more"></a></p>
<h1 id="1-Spring-Framework-模块"><a href="#1-Spring-Framework-模块" class="headerlink" title="1.Spring Framework 模块"></a>1.Spring Framework 模块</h1><p><img src="spring-1.assets/image-20200530234642332.png" alt="image-20200530234642332"></p>
<h2 id="1-1-spring核心容器"><a href="#1-1-spring核心容器" class="headerlink" title="1.1 spring核心容器"></a>1.1 spring核心容器</h2><p>该层基本上是 Spring Framework 的核心。它包含以下模块：</p>
<ul>
<li>Spring Core</li>
<li>Spring Bean</li>
<li>SpEl (Spring Expression language)</li>
<li>Spring Context</li>
</ul>
<h2 id="1-2数据访问-集成"><a href="#1-2数据访问-集成" class="headerlink" title="1.2数据访问/集成"></a>1.2数据访问/集成</h2><p>该层提供与数据库交互的支持。它包含以下模块：</p>
<ul>
<li><p>JDBC (Java DataBase Connectivity)</p>
</li>
<li><p>ORM (Object Re<em>ationa</em> Mapping)</p>
</li>
<li><p>OXM (Object XMl Mappers)</p>
</li>
<li><p>JMS (Java Messaging Service)</p>
</li>
<li><p>Transaction</p>
</li>
</ul>
<h2 id="1-3-web"><a href="#1-3-web" class="headerlink" title="1.3 web"></a>1.3 web</h2><p>该层提供了创建 Web 应用程序的支持。它包含以下模块：</p>
<ul>
<li><p>Web</p>
</li>
<li><p>Web – Servlet</p>
</li>
<li><p>Web – Socket</p>
</li>
<li><p>Web – Portlet</p>
</li>
</ul>
<h2 id="1-4AOP"><a href="#1-4AOP" class="headerlink" title="1.4AOP"></a>1.4AOP</h2><p>该层支持面向切面编程</p>
<h2 id="1-5Instrumentation"><a href="#1-5Instrumentation" class="headerlink" title="1.5Instrumentation"></a>1.5Instrumentation</h2><p>该层为类检测和类加载器实现提供支持。</p>
<h2 id="1-6Test"><a href="#1-6Test" class="headerlink" title="1.6Test"></a>1.6Test</h2><p>该层为使用 JUnit 和 TestNG 进行测试提供支持。</p>
<h2 id="1-7-Messaging"><a href="#1-7-Messaging" class="headerlink" title="1.7 Messaging"></a>1.7 Messaging</h2><p>该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</p>
<h2 id="1-8-Aspect"><a href="#1-8-Aspect" class="headerlink" title="1.8 Aspect"></a>1.8 Aspect</h2><p>该模块为与 AspectJ 的集成提供支持。</p>
<h1 id="2-IOC"><a href="#2-IOC" class="headerlink" title="2. IOC"></a>2. IOC</h1><p>Spring拥有两大特性：IoC和AOP。</p>
<p>Spring核心容器的主要组件是Bean工厂（BeanFactory），Bean工厂使用控制反转（IoC）模式来降低程序代码之间的耦合度，并提供了面向切面编程（AOP）的实现。</p>
<h2 id="2-1什么是IOC-DI"><a href="#2-1什么是IOC-DI" class="headerlink" title="2.1什么是IOC/DI"></a>2.1什么是IOC/DI</h2><ul>
<li><p>IOC(Inversion of Control)控制反转：所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们可配置的文件。</p>
</li>
<li><p>DI(Dependency Injection)依赖注入：就是指对象是被动接受依赖类而不是自己主动去找，换句话说就是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。Spring依赖注入的方式主要有四个，基于注解注入方式、set注入方式、构造器注入方式、静态工厂注入方式。推荐使用基于注解注入方式，配置较少，比较方便。</p>
</li>
</ul>
<ul>
<li>IoC容器：具有依赖注入功能的容器，可以创建对象的容器。IoC容器负责实例化、定位、配置应用程序中的对象并建立这些对象之间的依赖。IoC的主要实现方式有两种：依赖查找、依赖注入。依赖注入是一种更可取的方式,以来查找已经配抛弃</li>
</ul>
<p>那么依赖查找和依赖注入有什么区别呢？</p>
<ul>
<li><p>依赖查找，主要是容器为组件提供一个回调接口和上下文环境。这样一来，组件就必须自己使用容器提供的API来查找资源和协作对象，控制反转仅体现在那些回调方法上，容器调用这些回调方法，从而应用代码获取到资源。</p>
</li>
<li><p>依赖注入，组件不做定位查询，只提供标准的Java方法让容器去决定依赖关系。容器全权负责组件的装配，把符合依赖关系的对象通过Java Bean属性或构造方法传递给需要的对象。</p>
</li>
</ul>
<h2 id="2-2-spring-IOC"><a href="#2-2-spring-IOC" class="headerlink" title="2.2 spring IOC"></a>2.2 spring IOC</h2><p>控制反转，简单点说，就是创建对象的控制权，由原本自己代码new被反转到了Spring框架上</p>
<p>Spring 的 IoC 设计支持以下功能：·</p>
<ul>
<li><p>依赖注入·</p>
</li>
<li><p>依赖检查·</p>
</li>
<li><p>自动装配</p>
</li>
<li><p>支持集合</p>
</li>
<li><p>指定初始化方法和销毁方法</p>
</li>
<li><p>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）</p>
</li>
</ul>
<p>其中，最重要的就是依赖注入，从 XML 的配置上说， 即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p>
<p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</p>
<p>那么， Spring 如何设计容器的呢？</p>
<p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器：BeanFactory、ApplicationContext</p>
<p>l BeanFactory 粗暴简单，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p>
<p>l ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口的一个实现类ConfigurableApplicationContext定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p>
<p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，我这里通过常用的 ClassPathXmlApplicationContext 类（我们常用的还有ClassPathweblApplicationContext ），来展示整个容器的层级 UML 关系。</p>
<p><img src="spring-1.assets/image-20200530235332029.png" alt="image-20200530235332029"></p>
<p>最上面的 BeanFactory 知道吧？我就不讲了。</p>
<p>下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p>
<p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p>
<p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p>
<p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置。生命周期事件回调等。</p>
<p>好，解释了低级容器和高级容器，我们可以看看一个 IoC 启动过程是什么样子的。说白了，就是 ClassPathXmlApplicationContext 这个类，在启动时，都做了啥。（由于我这是 interface21 的代码，肯定和你的 Spring 4.x 系列不同）。</p>
<p>下图是 ClassPathXmlApplicationContext 的构造过程，实际就是 Spring IoC 的初始化过程。</p>
<p><img src="spring-1.assets/image-20200530235345604.png" alt="image-20200530235345604"></p>
<p>这里再用文字来描述这个过程：</p>
<ol>
<li>用户构造 ClassPathXmlApplicationContext（简称 CPAC）</li>
<li>CPAC 首先访问了 “抽象高级容器” 的 final 的 refresh 方法，这个方法是模板方法。所以要回调子类（低级容器）的 refreshBeanFactory 方法，这个方法的作用是使用低级容器加载所有 BeanDefinition 和 Properties 到容器中。</li>
<li>低级容器加载成功后，高级容器开始处理一些回调，例如 Bean 后置处理器。回调 setBeanFactory 方法。或者注册监听器等，发布事件，实例化单例 Bean 等等功能，这些功能，随着 Spring 的不断升级，功能越来越多，很多人在这里迷失了方向 ：）。</li>
</ol>
<p>简单说就是：</p>
<ol>
<li>低级容器 加载配置文件（从 XML，数据库，Applet），并解析成 BeanDefinition 到低级容器中。</li>
<li>加载成功后，高级容器启动高级功能，例如接口回调，监听器，自动实例化单例，发布事件等等功能。</li>
</ol>
<p>所以，一定要把 “低级容器” 和“高级容器” 的区别弄清楚。不能一叶障目不见泰山。</p>
<p>好，当我们创建好容器，就会使用 getBean 方法，获取 Bean，而 getBean 的流程如下：</p>
<p><img src="spring-1.assets/image-20200530235428020.png" alt="image-20200530235428020"></p>
<p>从图中可以看出，getBean 的操作都是在低级容器里操作的。其中有个递归操作，这个是什么意思呢？</p>
<p>假设 ： 当 Bean_A 依赖着 Bean_B，而这个 Bean_A 在加载的时候，其配置的 ref = “Bean_B” 在解析的时候只是一个占位符，被放入了 Bean_A 的属性集合中，当调用 getBean 时，需要真正 Bean_B 注入到 Bean_A 内部时，就需要从容器中获取这个 Bean_B，因此产生了递归。</p>
<p>为什么不是在加载的时候，就直接注入呢？因为加载的顺序不同，很可能 Bean_A 依赖的 Bean_B 还没有加载好，也就无法从容器中获取，你不能要求用户把 Bean 的加载顺序排列好，这是不人道的。</p>
<p>所以，Spring 将getBean分为了 2 个步骤：</p>
<ol>
<li>加载所有的 Bean 配置成 BeanDefinition 到容器中，如果 Bean 有依赖关系，则使用占位符暂时代替。</li>
<li>然后，在调用 getBean 的时候，进行真正的依赖注入，即如果碰到了属性是 ref 的（占位符），那么就从容器里获取这个 Bean，然后注入到实例中 —— 称之为依赖注入。</li>
</ol>
<p>可以看到，依赖注入实际上，只需要 “低级容器” 就可以实现。</p>
<p>这就是 IoC。</p>
<p>所以 ApplicationContext refresh 方法里面的操作不只是 IoC，是高级容器的所有功能（包括 IoC），IoC 的功能在低级容器里就可以实现。</p>
<h2 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h2><p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p>
<p>1) 加载配置文件，解析成 BeanDefinition 放在 Map 里。</p>
<p>2) 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</p>
<p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p>
<p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p>
<h1 id="3-面向切面编程AOP"><a href="#3-面向切面编程AOP" class="headerlink" title="3. 面向切面编程AOP"></a>3. 面向切面编程AOP</h1><p>AOP的定义：面向切面编程，核心原理是使用动态代理模式在方法执行前后或出现异常时加入相关逻辑。</p>
<ol>
<li>AOP是基于动态代理模式。</li>
<li>AOP是方法级别的（要测试的方法不能为static修饰，因为接口中不能存在静态方法，编译就会报错）。</li>
<li>AOP可以分离业务代码和关注点代码（重复代码），在执行业务代码时，动态的注入关注点代码。切面就是关注点代码形成的类</li>
</ol>
<p>我们知道java是一个面向对象(OOP)的语言，但它有一些弊端,比如当我们需要为多个不具有继承关系的对象引入一个公共行为，只能在在每个对象里引用公共行为，这样做不便于维护，而且有大量重复代码。AOP的出现弥补了OOP的这点不足。</p>
<p>面向切面编程（AOP）就是纵向的编程。比如业务A和业务B现在需要一个相同的操作，传统方法我们可能需要在A、B中都加入相关操作代码，而应用AOP就可以只写一遍代码，A、B共用这段代码。并且，当A、B需要增加新的操作时，可以在不改动原代码的情况下，灵活添加新的业务逻辑实现。</p>
<p>在实际开发中，比如商品查询、促销查询等业务，都需要记录日志、异常处理等操作，AOP把所有共用代码都剥离出来，单独放置到某个类中进行集中管理，在具体运行时，由容器进行动态织入这些公共代码。</p>
<p>AOP主要一般应用于签名验签、参数校验、日志记录、事务控制、权限控制、性能统计、异常处理等。</p>
<h2 id="3-1-AOP名词"><a href="#3-1-AOP名词" class="headerlink" title="3.1 AOP名词"></a>3.1 AOP名词</h2><ul>
<li><p>切面（Aspect）：共有功能的实现。如日志切面、权限切面、验签切面等。在实际开发中通常是一个存放共有功能实现的标准Java类。当Java类使用了@Aspect注解修饰时，就能被AOP容器识别为切面。</p>
</li>
<li><p>通知（Advice）：切面的具体实现。就是要给目标对象织入的事情。以目标方法为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际开发中通常是切面类中的一个方法，具体属于哪类通知，通过方法上的注解区分。</p>
</li>
<li><p>连接点（JoinPoint）：程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出等。Spring只支持方法级的连接点。一个类的所有方法前、后、抛出异常时等都是连接点。</p>
</li>
</ul>
<ul>
<li>切入点（Pointcut）：用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。</li>
</ul>
<p>比如，在上面所说的连接点的基础上，来定义切入点。我们有一个类，类里有10个方法，那就产生了几十个连接点。但是我们并不想在所有方法上都织入通知，我们只想让其中的几个方法，在调用之前检验下入参是否合法，那么就用切点来定义这几个方法，让切点来筛选连接点，选中我们想要的方法。切入点就是来定义哪些类里面的哪些方法会得到通知。</p>
<ul>
<li><p>目标对象（Target）：那些即将切入切面的对象，也就是那些被通知的对象。这些对象专注业务本身的逻辑，所有的共有功能等待AOP容器的切入。</p>
</li>
<li><p>代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象本身业务逻辑加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。目标对象被织入共有功能后产生的对象。</p>
</li>
<li><p>织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译时、类加载时、运行时。Spring是在运行时完成织入，运行时织入通过Java语言的反射机制与动态代理机制来动态实现。</p>
</li>
</ul>
<h2 id="3-2-pointcut用法"><a href="#3-2-pointcut用法" class="headerlink" title="3.2 pointcut用法"></a>3.2 pointcut用法</h2><p><img src="spring-1.assets/image-20200530235925884.png" alt="image-20200530235925884"></p>
<ul>
<li><p>修饰符匹配 modifier-pattern? 例：public private</p>
</li>
<li><p>返回值匹配 ret-type-pattern 可以用 * 表示任意返回值</p>
</li>
<li><p>类路径匹配 declaring-type-pattern? 全路径的类名</p>
</li>
<li><p>方法名匹配 name-pattern 可以指定方法名或者用 * 表示所有方法；set* 表示所有以set开头的方法</p>
</li>
<li><p>参数匹配 (param-pattern) 可以指定具体的参数类型，多个参数用“,”分隔；可以用 * 表示匹配任意类型的参数；可以用 (..) 表示零个或多个任意参数</p>
</li>
<li><p>异常类型匹配throws-pattern? 例：throws Exception</p>
</li>
</ul>
<p>其中后面跟着 ? 表示可选项</p>
<p><img src="spring-1.assets/image-20200530235955265.png" alt="image-20200530235955265"></p>
<h2 id="3-3-一个例子"><a href="#3-3-一个例子" class="headerlink" title="3.3 一个例子"></a>3.3 一个例子</h2><p>以 <a href="https://blog.csdn.net/dkbnull/article/details/82847647" target="_blank" rel="noopener">Spring Boot入门：使用AOP实现拦截器</a> 中的AOP为例</p>
<p><img src="spring-1.assets/image-20200531000026341.png" alt="image-20200531000026341"></p>
<p>SignAop类使用了@Aspect注解，则该类可以被AOP容器识别为切面</p>
<img src="spring-1.assets/image-20200531000038057.png" alt="image-20200531000038057" style="zoom:150%;" />

<p>@Pointcut声明一个切入点，范围为controller包下所有的类的所有方法。注：作为切入点签名的方法必须返回void类型</p>
<img src="spring-1.assets/image-20200531000104386.png" alt="image-20200531000104386" style="zoom:150%;" />

<p>doBefore()方法使用@Before(“signAop()”)注解，表示前置通知（在某连接点之前执行的通知），但这个通知不能阻止连接点之前的执行流程，除非它抛出一个异常。</p>
<p>doAfterReturning()方法使用@AfterReturning(value = “signAop()”, returning = “params”)注解，表示后置通知（在某连接点正常完成后执行的通知），通常在一个匹配的方法返回的时候执行。</p>
<p>实际运行时，在进入controller包下所有方法前，都会进入doBefore()方法，在controller包下方法执行完成后，都会进入doAfterReturning()方法。</p>
<h2 id="3-4-动态代理-静待代理"><a href="#3-4-动态代理-静待代理" class="headerlink" title="3.4 动态代理/静待代理"></a>3.4 动态代理/静待代理</h2><p>AOP有两种实现方式：静态代理、动态代理</p>
<p>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</p>
<ul>
<li><p>编译时编织（特殊编译器实现）</p>
</li>
<li><p>类加载时编织（特殊的类加载器实现）。</p>
</li>
</ul>
<p>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</p>
<ul>
<li><p>JDK 动态代理</p>
</li>
<li><p>CGLIB</p>
</li>
</ul>
<h3 id="3-4-1-静态代理"><a href="#3-4-1-静态代理" class="headerlink" title="3.4.1 静态代理"></a>3.4.1 静态代理</h3><p>静态代理模式：静态代理说白了就是在程序运行前就已经存在代理类的字节码文件，代理类和原始类的关系在运行前就已经确定。</p>
<p><img src="spring-1.assets/image-20200531000307922.png" alt="image-20200531000307922"></p>
<p>测试结果</p>
<img src="spring-1.assets/image-20200531000332393.png" alt="image-20200531000332393" style="zoom:150%;" />

<p>静态代理虽然保证了业务类只需关注逻辑本身，代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理。再者，如果增加一个方法，除了实现类需要实现这个方法外，所有的代理类也要实现此方法。增加了代码的维护成本。那么要如何解决呢?答案是使用动态代理。</p>
<h3 id="3-4-2-动态代理"><a href="#3-4-2-动态代理" class="headerlink" title="3.4.2 动态代理"></a>3.4.2 动态代理</h3><p>动态代理模式：动态代理类的源码是在程序运行期间通过JVM反射等机制动态生成，代理类和委托类的关系是运行时才确定的。实例如下:</p>
<h4 id="3-4-2-1-JDK动态代理"><a href="#3-4-2-1-JDK动态代理" class="headerlink" title="3.4.2.1 JDK动态代理"></a>3.4.2.1 JDK动态代理</h4><p><img src="spring-1.assets/image-20200531000437033.png" alt="image-20200531000437033"></p>
<p>测试结果如下：</p>
<p><img src="spring-1.assets/image-20200531000450599.png" alt="image-20200531000450599"></p>
<p>在运行测试类中创建测试类对象代码中</p>
<p><img src="spring-1.assets/wps1.jpg" alt="img"> </p>
<p>其实是jdk动态生成了一个类去实现接口,隐藏了这个过程:</p>
<p><img src="spring-1.assets/wps2.jpg" alt="img"> </p>
<p>使用jdk生成的动态代理的前提是目标类必须有实现的接口。</p>
<h4 id="3-4-2-2-CGLB动态代理"><a href="#3-4-2-2-CGLB动态代理" class="headerlink" title="3.4.2.2 CGLB动态代理"></a>3.4.2.2 CGLB动态代理</h4><p>使用jdk生成的动态代理的前提是目标类必须有实现的接口。但这里又引入一个问题,如果某个类没有实现接口,就不能使用jdk动态代理,所以Cglib代理就是解决这个问题的。</p>
<p>Cglib是以动态生成的子类继承目标的方式实现，在运行期动态的在内存中构建一个子类，如下:</p>
<p><img src="spring-1.assets/image-20200531000540009.png" alt="image-20200531000540009"></p>
<p>Cglib使用的前提是目标类不能为final修饰。因为final修饰的类不能被继承。</p>
<p>首先，导入 CGLIB 的 Maven 依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">  &lt;groupId&gt;cglib&lt;&#x2F;groupId&gt;  </span><br><span class="line">  &lt;artifactId&gt;cglib&lt;&#x2F;artifactId&gt;  </span><br><span class="line">  &lt;version&gt;3.2.11&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;  </span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>Spring AOP 的 org.springframework.cglib 包中包含了 CGLIB 的相关代码(和 CGLIB Maven 依赖中代码的一样，版本可能不同)，所以也可以选择导入 Spring AOP 的 Maven 依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;  </span><br><span class="line">  &lt;artifactId&gt;spring-aop&lt;&#x2F;artifactId&gt;  </span><br><span class="line">  &lt;version&gt;5.1.6.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;  </span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>然后，定义一个 Service 类，其有两个方法并且其中一个方法用 final 来修饰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.public class Service &#123;  </span><br><span class="line">2.    &#x2F;** </span><br><span class="line">3.     *  final 方法不能被子类覆盖 </span><br><span class="line">4.     *&#x2F;  </span><br><span class="line">5.    public final void finalMethod() &#123;  </span><br><span class="line">6.        System.out.println(&quot;Service.finalMethod 执行了&quot;);  </span><br><span class="line">7.    &#125;  </span><br><span class="line">8.  </span><br><span class="line">9.    public void publicMethod() &#123;  </span><br><span class="line">10.        System.out.println(&quot;Service.publicMethod 执行了&quot;);  </span><br><span class="line">11.    &#125;  </span><br><span class="line">12.&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，定义一个 MethodInterceptor 的实现类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class CglibDynamicProxy implements MethodInterceptor &#123;  </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;目标对象（也被称为被代理对象）  </span><br><span class="line">    private Object target;  </span><br><span class="line">  </span><br><span class="line">    public CglibDynamicProxy(Object target) &#123;  </span><br><span class="line">        this.target &#x3D; target;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;** </span><br><span class="line">     * @param obj       CGLIB 生成的代理对象 </span><br><span class="line">     * @param method    被代理对象方法 </span><br><span class="line">     * @param args      方法入参 </span><br><span class="line">     * @param proxy     方法代理 </span><br><span class="line">     * @return </span><br><span class="line">     * @throws Throwable </span><br><span class="line">     *&#x2F;  </span><br><span class="line">    @Override  </span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;  </span><br><span class="line">        System.out.println(&quot;CglibDynamicProxy intercept 方法执行前--&quot;);  </span><br><span class="line">  </span><br><span class="line">        System.out.println(&quot;obj &#x3D; &quot; + obj.getClass());  </span><br><span class="line">        System.out.println(&quot;method &#x3D; &quot; + method);  </span><br><span class="line">        System.out.println(&quot;proxy &#x3D; &quot; + proxy);  </span><br><span class="line">  </span><br><span class="line">        Object object &#x3D; proxy.invoke(target, args);  </span><br><span class="line">        System.out.println(&quot;CglibDynamicProxy intercept 方法执行后--&quot;);  </span><br><span class="line">        return object;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    &#x2F;** </span><br><span class="line">     * 获取被代理接口实例对象 </span><br><span class="line">     * 通过 enhancer.create 可以获得一个代理对象，它继承了 target.getClass() 类 </span><br><span class="line">     * @param &lt;T&gt; </span><br><span class="line">     * @return </span><br><span class="line">     *&#x2F;  </span><br><span class="line">    public &lt;T&gt; T getProxy() &#123;  </span><br><span class="line">        Enhancer enhancer &#x3D; new Enhancer();  </span><br><span class="line">        enhancer.setSuperclass(target.getClass());  </span><br><span class="line">        enhancer.setCallback(this);  </span><br><span class="line">        return (T) enhancer.create();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        &#x2F;&#x2F; 1. 构造目标对象  </span><br><span class="line">        Service target &#x3D; new Service();  </span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 2. 根据目标对象生成代理对象  </span><br><span class="line">        CglibDynamicProxy proxy &#x3D; new CglibDynamicProxy(target);  </span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 获取 CGLIB 代理类  </span><br><span class="line">        Service proxyObject &#x3D; proxy.getProxy();  </span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 调用代理对象的方法  </span><br><span class="line">        proxyObject.finalMethod();  </span><br><span class="line">        proxyObject.publicMethod();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下所示：</p>
<p><img src="spring-1.assets/image-20200531000715166.png" alt="image-20200531000715166"></p>
<p>原理</p>
<p><a href="https://www.jianshu.com/p/7700a48811e0" target="_blank" rel="noopener">https://www.jianshu.com/p/7700a48811e0</a></p>
<h1 id="4-spring原理概述"><a href="#4-spring原理概述" class="headerlink" title="4. spring原理概述"></a>4. spring原理概述</h1><p><img src="spring-1.assets/image-20200531000823596.png" alt="image-20200531000823596"></p>
<ol>
<li>用户发送请求至前端控制器DispatcherServlet(也叫中央处理器).</li>
<li>DispatcherServlet调用HandlerMappering处理器映射器，处理器映射器找到具体的处理器（可以根据xml配置、注解进行查找），生成处理器对象及处理器拦截器（如果有则生成）一并返回给DispatcherServlet.</li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器。</li>
<li>HandlerAdapter经过适配调用具体的处理器（Controller,也叫后端控制器）。</li>
<li>Controller执行完成返回ModelAndView.</li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet.</li>
<li>DisPatcherServlet将ModelAndView传给ViewReslover视图解析器。</li>
<li>ViewReslover解析后返回具体View.</li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li>
<li>DispatcherServlet响应用户。</li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">酱油君</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dcghx.github.io/2020/05/09/spring-1/">https://dcghx.github.io/2020/05/09/spring-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dcghx.github.io" target="_blank">酱油村-记事录</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/spring/">spring</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/09/IO-1/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">IO————1</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/09/ywjy-api%20%E9%98%B2%E5%88%B7%E9%99%90%E6%B5%81/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">经验积累————API接口防刷限流</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 酱油君</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script></body></html>